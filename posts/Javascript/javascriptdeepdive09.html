<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>자바스크립트 딥다이브: 09.타입 변환과 단축평가</title><meta name="description" content="자바스크립트 딥다이브 책 내용 중 &#x27;타입 변환과 단축평가&#x27;의 정리 내용입니다."/><meta property="og:title" content="자바스크립트 딥다이브: 09.타입 변환과 단축평가"/><meta property="og:description" content="자바스크립트 딥다이브 책 내용 중 &#x27;타입 변환과 단축평가&#x27;의 정리 내용입니다."/><meta property="og:image" content="https://phnml1.github.io/posts/Javascript/javascriptdeepdive09/javascript.png"/><meta property="og:url" content="https://phnml1.github.io/posts/Javascript/javascriptdeepdive09"/><meta property="og:type" content="article"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/e946bf76803169e7.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/e946bf76803169e7.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/570acc098c248c2f.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/570acc098c248c2f.css" crossorigin="" data-n-p=""/><link rel="preload" href="/_next/static/css/0407c34f82b3c3db.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/0407c34f82b3c3db.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-6f336cc197ef678d.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-aa55ffd08992d156.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-e287481ee6e74633.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/135-4ea70e0295549ad8.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/393-7217afb82985f4a5.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/979-7390dd4fc9e19803.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/%5B...detail%5D-8188b3d88e2a5757.js" defer="" crossorigin=""></script><script src="/_next/static/RYnp_NyzrQPZMofDPtHX9/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/RYnp_NyzrQPZMofDPtHX9/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"slug":"posts/Javascript/javascriptdeepdive09","title":"자바스크립트 딥다이브: 09.타입 변환과 단축평가","date":"2024-04-22T12:00:24.000Z","image":"javascript.png","summary":"자바스크립트 딥다이브 책 내용 중 '타입 변환과 단축평가'의 정리 내용입니다.","tags":["JavaScript"],"content":"\r\n# 타입 변환과 단축 평가\r\n개발자가 의도적으로 값의 타입을 변환하는 것: `명시적 타입 변환` or `타입캐스팅`\r\n\r\n개발자의 의도와는 상관없이 표현식을 평가하는 도중에 **자바스크립트 엔진에 의해 암묵적으로 타입이 변환**되는 것: `암묵적 타입 변환` or `타입강제 변환`\r\n\r\n## 암묵적 타입 변환\r\n\u003e 자바스크립트 엔진이 표현식을 평가할 때 개발자의 의도와는 상관없이 `코드의 문맥을 고려해 암묵적으로` 데이터 타입을 강제 변환(암묵적 타입 변환)할 때가 있다.\r\n\r\n암묵적 타입 변환은 문자, 숫자, 불리언 같은 **원시 타입**중 하나로 타입을 자동 변환한다.\r\n\r\n### 문자열 타입으로 변환\r\n```js\r\n// 숫자 타입 \r\n0+'' // '0'\r\nNaN + '' // 'NaN'\r\nInfinity + '' // 'Infinity'\r\n\r\n// 불리언 타입\r\ntrue + '' // 'true'\r\n\r\n// null 타입\r\nnull + '' // 'null'\r\n\r\n// undefined 타입\r\nundefined + '';       // \"undefined\"\r\n\r\n// 심벌 타입\r\n(Symbol()) + '';      // TypeError: Cannot convert a Symbol value to a string\r\n\r\n// 객체 타입\r\n({}) + '';            // \"[object Object]\"\r\nMath + '';            // \"[object Math]\"\r\n[] + '';              // \"\"\r\n[10, 20] + '';        // \"10,20\"\r\n(function(){}_ + '';  // \"function(){}\"\r\nArray + '';           // \"function Array() { [native code] }\"\r\n```\r\n\r\n### 숫자 타입으로 변환\r\n```js\r\n// 문자열 타입(+ 단항연산자는 피연산자가 숫자타입이 아니면 숫자 타입으로 암묵적 타입 변환 수행)\r\n+'' // -\u003e 0\r\n+'0' // 0\r\n+'string' // -\u003e NaN\r\n\r\n// 불리언 타입\r\n+true // -\u003e 1\r\n\r\n// null 타입\r\n+null // -\u003e 0\r\n\r\n//undefined 타입\r\n+undefined // -\u003e NaN\r\n\r\n// 심벌 타입\r\n+Symbol(); // TypeError: Cannot convert a Symbol value to a number\r\n\r\n// 객체 타입\r\n+{}; // -\u003e NaN\r\n+[]; // -\u003e 0\r\n+[10, 20]; // NaN\r\n+function () {}; // NaN\r\n```\r\n**빈 문자열 (''), 빈 배열([]), null, false**는 **0**으로, **true**는 **1**로 변환된다. **객체와 빈 배열이 아닌 배열,undefined**는 변환되지 않아 **NaN**이 된다는 것에 주의하자\r\n\r\n### 불리언 타입으로 변환\r\nif문, for문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참/거짓으로 평가 되어야 하는 표현식이다.\r\n```js\r\n// 모두 코드 블록 실행됨\r\nif(!false) console.log(false + ' is falsy value')\r\nif(!undefined) console.log(undefined + 'is falsy value')\r\nif(!NaN) console.log(NaN + 'is falsy value');\r\nif(!null) console.log(null + 'is falsy value');\r\n```\r\n자바스크립트 엔진은 불리언 타입이 아닌 값을 `Truthy 값(참으로 평가되는 값)` or `Falsy 값(거짓으로 평가되는 값)` 으로 구분한다.\r\n\r\n**자바스크립트 엔진이 Falsy 값으로 판단하는 값**\r\n+ false\r\n+ undefined\r\n+ null\r\n+ 0, -0\r\n+ NaN\r\n+ ''(빈 문자열)\r\n\r\n## 명시적 타입 변환\r\n**개발자의 의도에 따라 명시적으로 타입을 변환하는 것** \r\n\r\n**표준 빌트인 함수(String,Number,Boolean)**을  new연산자 없이 호출하는 방법과 **빌트인 메서드를 사용하는 방법**, 그리고 **암묵적 타입 변환**을 이용하는 방법이 있다.\r\n\r\n### 문자열 타입으로 변환\r\n```js\r\n// String 생성자 함수를 new 연산 없이 호출\r\nString(1); // -\u003e \"1\"\r\nString(NaN); // -\u003e \"NaN\"\r\nString(Infinity); // -\u003e \"Infinity\"\r\nString(false); // -\u003e \"false\"\r\n\r\n// Object.prototype.toString 메서드를 사용하는 방법\r\n(NaN).toString() // -\u003e 'NaN'\r\n(true).toString() // -\u003e 'true'\r\n\r\n// 문자열 연결 연산자\r\nNaN + '' // -\u003e \"NaN\"\r\n```\r\n\r\n### 숫자 타입으로 변환\r\n```js\r\n// Number 생성자 함수를 new 연산자 없이 호출하는 방법\r\nNumber('0') // -\u003e 0\r\nNumber(10.53) // -\u003e 10.53\r\n\r\n// parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)\r\nparseInt('0') // -\u003e 0\r\nparseFloat('10.53') // -\u003e 10.53\r\n\r\n// + 단항 산술 연산자를 이용하는 방법\r\n// 문자열 타입 =\u003e 숫자 타입\r\n+'0'\r\n+'-1'\r\n// 불리언 타입 =\u003e 숫자 타입\r\n+true; //-\u003e1\r\n\r\n// * 산술 연산자를 이용하는 방법\r\n// 문자열 타입 =\u003e 숫자 타입\r\n'0' * 1;\r\n'-1' * 1; //1\r\n// 불리언 타입 =\u003e 숫자 타입\r\ntrue * 1; //-\u003e1\r\n```\r\n\r\n### 불리언 타입으로 변환\r\n```js\r\n// 1. Boolean 생성자 함수를 new 키워드 없이 호출하는 방법\r\nBoolean('x'); // true\r\n\r\nBoolean(0) // false\r\nBoolean(NaN) // false\r\nBoolean(Infinity) // true\r\n\r\nBoolean(null) // false\r\nBoolean(undefined) // false\r\n\r\nBoolean({}) //True\r\n\r\n//2. !(부정 논리 연산자) 두 번 사용\r\n!!'x';  // true ( !(!'x') === !(false) -\u003e true )\r\n```\r\n\r\n## 단축 평가\r\n\u003e `단축 평가` : 논리 연산의 결과를 결정하는 피연산자를 `타입 변환하지 않고 그대로 반환`\r\n-  단축 평가는 표현식을 평가하는 도중에 평가결과가 확정 경우 → 나머지 평가 과정을 생략한다.\r\n단축 평가 표현식\r\n\r\n| 단축 평가 표현식 | 평가 결과 |\r\n|--|--|\r\n|true ll anything  | true |\r\n|false ll anything | anything |\r\n| true \u0026\u0026 anything |  anything|\r\n| false \u0026\u0026 anything | false |\r\n\r\n### 논리 연산자를 단축 평가\r\n`논리곱(\u0026\u0026)` 에서 논리 연산의 결과를 결정하는 것은 **두 번째 피연산자**\r\n```js\r\n'Cat' \u0026\u0026 'Dog'; // Dog\r\n```\r\n\r\n`논리곱(\u0026\u0026) 연산자` 는 두 개의 피연산자가 `모두 true로 평가될 때 true를 반환`, `좌항 -\u003e 우항으로 평가가 진행` \r\n\r\n\r\n`논리합(||)` 에서  논리 연산의 결과를 결정하는 것은 **첫 번째 피연산자**  그러므로 첫 번째 연산자 그대로 반환\r\n```js\r\n'Cat' || 'Dog' // Cat\r\n```\r\n\r\n`논리합 (||) 연산자` 는 `두 개의 피연자 중 하나만 true로 평가되어도 true로 반환`하며, 역시 `좌항에서 우항으로 평가가 진행`\r\n\r\n ```js\r\n // 논리합(||) 연산\r\n\"Cat\" || \"Dog\"; // \"Cat\"\r\nfalse || \"Dog\"; // \"Dog\"\r\n\"Cat\" || false; // \"Cat\"\r\n\r\n// 논리곱(\u0026\u0026) 연산\r\n\"Cat\" \u0026\u0026 \"Dog\"; // \"Dog\"\r\nfalse \u0026\u0026 \"Dog\"; // \"false\"\r\n\"Cat\" \u0026\u0026 false; // \"false\"\r\n ```\r\n **단축평가 사용 예시**\r\n - **if 문대체**\r\n논리 연산자 단축평가를 통해서 if문도 대체할 수 있으며, 값 할당시 보다 더 깔끔할 수 있다.\r\n\t```js\r\n\tvar done = false;\r\n\tvar message = \"\";\r\n\r\n\t// 조건문으로 값 할당\r\n\tif (!done) message = \"미완료\";\r\n\r\n\tmeessage = done || \"미완료\";\r\n\tconsole.log(message) // 미완료\r\n\t```\r\n- **객체를 가리키기를 기대하는 변수의 값이 객체가 아니라 null또는 undefined일 경우** \r\n\r\n\t이러한 경우 타입 에러가 발생한다. 하지만, 단축평가를 사용하면 에러 발생 x\r\n\t```js\r\n\t// elem이 null 또는 undefined같은 Falsy값이면 elem으로 평가\r\n\t// elem이 Truthy값이면 elem.value 값으로 평가\r\n\tvar elem = null;\r\n\tvar value = elem \u0026\u0026 elem.value // null\r\n\t```\r\n- **함수 매개변수에 기본값을 설정**\r\n함수를 호출할 때 인수를 전달하지 않으면 매개변수에는 undefined가 할당된다.  단축평가 사용해 매개변수에 기본값을 설정한다면 에러 방지 가능\r\n\t```js\r\n\t// 단축 평가를 사용한 매개변수의 기본값 설정\r\n\tfunction getStringLength(str) {\r\n\t  str = str || \"\";\r\n\t  return str.length;\r\n\t}\r\n\tgetStringLength(); // 0\r\n\tgetStringLength('hi'); //2\r\n\t//  Es6의 매개변수 default parameter 설정\r\n\tfunction getStringLength(str = \"\") {\r\n\t  return str.length;\r\n\t}\r\n\tgetStringLength(); // 0\r\n\t```\r\n\r\n## 옵셔널 체이닝 연산자\r\n`?` : 좌항의 피 연산자가 null 또는 undefined인 경우 `undefined 반환`, 그렇지않으면 `우항의 포로퍼티 참조`\r\n```js\r\nvar elem = null;\r\nvar value = elem?.value; // undefined\r\n```\r\n-   객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 안전하게 참조할 때 유용\r\n-   옵셔널 체이닝 도입 이전에는  `논리곱(\u0026\u0026)을 사용한 단축 평가`를 통해 변수가 null 또는 undefined 인지 확인했음\r\n```js\r\n// 좌항이 Falsy라면 좌항 그대로 반환(0이나 ''반환 할 때도)\r\nvar str = \"\"; //\r\nvar length = str \u0026\u0026 str.length; // ''\r\n\r\n// 좌항 피연산자가 Falsy값이라도 null 또는 undefined 만 아니면, 우항의 프로퍼티를 참조한다.\r\nvar str = \"\";\r\nvar length = str?.length; // 0\r\n```\r\n\r\n## null 병합 연산자 \r\n`??` : 좌항의 피연산자가 **null또는 undefined인 경우** `우항의 피연산자 반환` 그렇지 않으면 `좌항 피연산자 반환`한다.\r\n```js\r\nvar foo = null ?? \"default string\"; // \"default string\"\r\n```\r\n- 변수에 기본값을 설정할 때 유용하며, 그전에는 논리합(||)을 사용한 단축평가로 변수에 기본값 설정\r\n\t```js\r\n\t// 좌항의 피연산자가 Falsy값이면, 우항의 피연산자를 반환 \r\n\t//(Falsy 값인 0 이나 ''도 기본값으로서 유효하다면 예기치 않은 동작이 발생한다.)\r\n\tvar foo = \"\" || \"default string\"; // \"default string\"\r\n\r\n\t//  좌항의 피연산자가 Falsy값이라도 null 또는 undefined 가 아니면, 좌항의 피연산자를 그대로 반환한다.\r\n\tvar foo = \"\" ?? \"default string\"; // ''\r\n\t```","readingMinutes":11},"category":"Javascript","prevData":{"title":"React useState 훅과 클로저","slug":"posts/React/React useState 훅과 클로저","summary":"클로저를 이용한 React useState 훅의 작동 원리를 이해해보자"},"nextData":{"title":"원시 값과 객체의 비교","slug":"posts/Javascript/javascriptdeepdive11","summary":"자바스크립트 딥다이브 책 내용 중 '원시 값과 객체의 비교'의 정리 내용입니다."}},"__N_SSG":true},"page":"/[...detail]","query":{"detail":["posts","Javascript","javascriptdeepdive09"]},"buildId":"RYnp_NyzrQPZMofDPtHX9","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
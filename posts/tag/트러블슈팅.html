<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/media/a15f2fce4b98b461-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/3d9ea938b6afa941-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/ee285b05ac47a625-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/1de9c871cd3a3669-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/bf54e24be5d8358f-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/02701f268eb7de16-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/69510bfdb63b0012.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/69510bfdb63b0012.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-aa55ffd08992d156.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-9f85f92bf56823a0.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/108-ababe0d3bb81df72.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/tag/%5Btag%5D-6f0344953c5fcd5a.js" defer="" crossorigin=""></script><script src="/_next/static/s88PCpXBXr-JVfKLNHdeM/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/s88PCpXBXr-JVfKLNHdeM/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"tags":["react native","트러블슈팅","google map","expo-location","졸업작품","react","JavaScript","deepdive","useState","hook","next.js","SSR","Suspense","렌더링","테스트","dev tools","SSG","Algorithm","프로그래머스","PCCP","lv2","이분탐색","클로저","생명주기","Virtual DOM","백준","gold","dfs","lv3","bfs"],"currentTag":"트러블슈팅","posts":[{"slug":"posts/React Native/React Native에서 Google Maps 연동 및 위치 추적 기능 구현하기","title":"React Native에서 Google Maps 연동 및 위치 추적 기능 구현하기","date":"2025-03-25T13:40:00.000Z","image":"index.png","summary":"React Native에서 Google Maps 연동 및 위치 추적 기능 구현하고, 초기 위치 설정하는 과정에서 발생한 문제를 해결하는 과정입니다.","tags":["react native","트러블슈팅","google map","expo-location","졸업작품"],"content":"\r\n# React Native에서 Google Maps 연동 및 위치 추적 기능 구현하기\r\n\r\n## 1. 개요\r\n\r\n최근 졸업작품인 러닝 크루 앱을 개발하면서 `react native`를 처음 써보았다. 앱에서 사용자의 현재 위치 및 코스 표시를 위해  `react-native-maps`를 활용해 Google Maps를 연동하였고, 사용자의 위치는 `expo-location`을 활용해 실시간으로 받아왔다.\r\n\r\n본 게시글에서는 `expo-location`을 통해 사용자의 위치를 받아오는 방법, `react-native-maps`를 통해 구글맵을 연동하는 방법 및 위치를 지도에 마커로 표시하는 과정, 그리고 러닝 중이라는 가정하에 지도의 중심이 사용자의 위치를 따라가도록 하는 것을 다뤄볼 것이다.\r\n그리고 끝으로 지도의 초기 위치를 내위치로 설정하던 과정에서 발생했던 문제도 다뤄볼 예정이다.\r\n\r\n## 2. 환경 설정\r\n\r\n### 2.1. 라이브러리 설치\r\n\r\nGoogle Maps를 React Native에서 사용하기 위해 `react-native-maps`를 설치한다.\r\n\r\n```\r\nnpx expo install react-native-maps\r\n```\r\n\r\n추가로, 현재 위치를 가져오기 위해 `expo-location`을 설치한다.\r\n\r\n```\r\nnpx expo install expo-location\r\n```\r\n\u003e npx expo install로 설치하는 이유: \r\n\u003e나 같은 경우 expo를 사용하여 react native개발을 하고 있고, 이 명령어를 사용하면 expo에서 공식적으로 지원하는 패키지 버전으로 라이브러리가 설치된다고 한다. \r\n\u003e그렇기 때문에 expo를 사용할때는 가급적 npm install 보다는 npx expo install을 권장한다고 한다.\r\n\r\n### 2.2. Google Maps API 키 설정\r\n\r\nGoogle Maps API를 사용하려면 Google Cloud Platform에서 API 키를 발급받아야 한다.\r\n\r\n그러기 위해서\r\n\r\n1. 구글 콘솔에서 프로젝트를 만든다\r\n2. api 및 서비스에 들어가서 `Maps for javascript sdk`를 허용한다.\r\n\u003cimg src=\"1.png\" alt=\"api 및 서비스 허용\"/\u003e\r\n3. 그 다음 키 및 사용자 인증정보 항목에서 api키를 만들기로 api 키를 만든다.\r\n\u003cimg src=\"2.png\" alt=\"api키 생성\"/\u003e\r\n- 키의 제한은 따로 없게했다. 보안을 위해서는 android용과  ios까지 따로따로 하는게 좋지만, 우선 본 게시글에선 따로 제한은 없게 할 것이다.\r\n\u003cimg src=\"3.png\" alt=\"키의 제한없도록 하기\"/\u003e\r\n4. app.json에서 이런식으로 키를 넣어 구글맵을 설정한다.\r\n- android는 app.json의 \"android\"안에 아래 코드를 추가한다.\r\n```json\r\n\"config\": {\r\n\t\"googleMaps\": {\r\n\t\t\"apiKey\": \"apikey\"\r\n}\r\n```\r\n\r\n-  ios까지 설정해주려면면 이런식으로 app.json안에 설정해준다.\r\n```json\r\n\"ios\": {\r\n\t\"bundleIdentifier\": \"com.company.runnershigh\",\r\n\t\"supportsTablet\": true,\r\n\t\"config\": {\r\n\t\t\"googleMapsApiKey\": \"apikey\"\r\n\t}\r\n},\r\n```\r\n이렇게 하면 기본적인 설정은 끝이난다.\r\n## 3. 구현\r\n\r\n### 3.1 MapView를 사용하여 지도를 보여주기\r\n```js\r\nimport MapView, { PROVIDER_GOOGLE } from \"react-native-maps\";\r\n      \u003cMapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: 37.78825,\r\n          longitude: -122.4324,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n      \u003e\r\n      \u003c/MapView\u003e\r\n```\r\n`PROVIDER_GOOGLE`을 사용하면 MapView에 굳이 키를 직접 추가하지 않더라도 미리 키가 설정되어있다면 google map을 사용할 수 있다.\r\n`initialRegion`은 말그대로 맵이 로드될 때 처음 위치를 말한다.\r\n### 3.2. MapView에 현재 위치 표시하기\r\n사용자의 현재 위치를 받아오기 위해 `expo-location`을 사용했다.\r\n\r\n\r\n\r\n```js\r\nimport * as Location from \"expo-location\";\r\n\r\n  const [permissionStatus, requestPermission] =\r\n    Location.useForegroundPermissions();\r\n```\r\n` Location.useForegroundPermissions()`을 통해, 앱이 켜져있을 때 사용자의 위치를 받는 것의 권한을 물어볼 수 있다.\r\n이를 포함하여 askPermission이라는 함수로\r\n```js\r\nconst askPermission = async () =\u003e {\r\n    if (!permissionStatus || !permissionStatus.granted) {\r\n      const permission = await requestPermission();\r\n      if (!permission.granted) {\r\n        return Alert.alert(\"위치 권한 필요\", \"위치 권한을 허용해주세요.\");\r\n      }\r\n    }\r\n  };\r\n```\r\n이렇게 권한을 받도록 하였다.\r\n이 `askPermission`이라는 코드는 \r\n```js\r\n  const [myLocation, setMyLocation] =\r\n    useState\u003cLocation.LocationObjectCoords | null\u003e(null);\r\n  const [subscription, setSubscription] =\r\n    useState\u003cLocation.LocationSubscription | null\u003e(null);\r\n```\r\n사용자의 위치를 받는 myLocation과 위치 구독정보를 받는 subscription이라는 상태를 지정해준다음,\r\n\r\n```js\r\n// 위치 추적 시작\r\nconst startLocationTracking = async () =\u003e {\r\n  const sub = await Location.watchPositionAsync(\r\n    {\r\n      accuracy: Location.Accuracy.High,\r\n      timeInterval: 3000, // 3초마다 업데이트\r\n      distanceInterval: 5, // 5m 이동마다 업데이트\r\n    },\r\n    (newLocation) =\u003e {\r\n      setMyLocation(newLocation.coords);\r\n    }\r\n  );\r\n  setSubscription(sub);\r\n};\r\n```\r\n`Location.watchPositionAsync()` 함수는 사용자의 위치를 실시간으로 받아오게 하고, 이것을 활용하여, 사용자의 위치와 위치 구독 정보를 업데이트한다.\r\n\r\n```js\r\nconst stopLocationTracking = () =\u003e {\r\n  if (subscription) {\r\n    subscription.remove();\r\n    setSubscription(null);\r\n  }\r\n};\r\n```\r\n위치 추적을 멈추게하는 코드는 다음과 같다. 위치 구독정보를 삭제해주는 코드이다.\r\n\r\n이를 `useEffect`를 통해 \r\n```js\r\nuseEffect(() =\u003e {\r\n  startLocationTracking();\r\n  return () =\u003e {\r\n    stopLocationTracking();\r\n  };\r\n}, []);\r\n```\r\n이런식으로 지정해주어 컴포넌트가 처음 마운트 될 때에 위치추적을 시작하고, 언마운트되면 위치추적을 그만둔다.\r\n\r\n`initialRegion`도 사용자의 위치를 지정해준다.\r\n```js\r\nconst mapRef = useRef\u003cMapView\u003e(null);\r\nmyLocation \u0026\u0026 (\r\n  \u003cMapView\r\n    ref = {mapRef}\r\n    style={{ flex: 1 }}\r\n    provider={PROVIDER_GOOGLE}\r\n    initialRegion={{\r\n            latitude: myLocation?.latitude,\r\n            longitude: myLocation?.longitude,\r\n            latitudeDelta: 0.02,\r\n            longitudeDelta: 0.02,\r\n          }}\r\n/\u003e\r\n)\r\n```\r\n\r\n### 3.3. 지도 중심이 사용자의 위치에 맞게 이동하게 하기\r\n\r\n이제 러닝중이라는 것을 가정하고, 현재 위치를 기준으로 지도 중심을 이동시켜 볼 것이다.\r\n우선 `MapView`의 인스턴스에 직접 접근하기 위해 ref를 사용해야 한한다.\r\n\r\n```js\r\nconst mapRef = useRef\u003cMapView\u003e(null);\r\n\r\n\u003cMapView\r\n  ref = {mapRef}\r\n  style={{ flex: 1 }}\r\n  provider={PROVIDER_GOOGLE}\r\n  {/*...*/}  \r\n\u003e\r\n```\r\n이런식으로 `mapRef`를 통해 `MapView`의 인스턴스에 직접 접근할 수 있도록 한다.\r\n그 다음 만일 사용자의 위치를 카메라가 따라가고 싶게 만들고 싶다면, \r\n```js\r\nconst mapRef = useRef\u003cMapView\u003e(null);\r\n\r\nuseEffect(() =\u003e {\r\n  if (myLocation) {\r\n    mapRef.current?.animateCamera({\r\n      center: myLocation,\r\n      zoom: 18,\r\n    });\r\n  }\r\n}, [myLocation]);\r\n```\r\n이런식으로 아까 지정해 준 `myLocation`을 `useEffect`의 의존성으로 집어넣어 주고, `MapView`의 인스턴스중 `animateCamera`라는 인스턴스를 이렇게 사용하여 `myLocation`에 카메라가 고정이 되도록(카메라가 사용자의 위치를 따라가도록) 할 수 있다.\r\n\r\n\r\n## 문제 해결 : 초기 위치의 범위가 지나치게 커지는 현상\r\n`initialRegion`의 latitudeDelta와 longitudeDelta가 적용이 되지 않았고, 마커자체는 내 위치이지만 지도 범위가 초기에 대한민국 한반도 전체가 보이는 문제가 발생했다.\r\n```js\r\nmyLocation \u0026\u0026 (\r\n\u003cMapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: myLocation?.latitude,\r\n          longitude: myLocation?.longitude,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n      \u003e\r\n      \u003c/MapView\u003e\r\n)\r\n```\r\ninitialRegion은 처음에만 위치가 적용이되고, 그 이후에 위치가 바뀌는 것은 적용이 되지 않는다고 하는데, myLocation은 지속적으로 위치추적을 하는 코드이기 때문에 지속적으로 비동기적으로 업데이트가 된다. 그래서 그 부분에서 꼬이지 않았나 생각이 든다. \r\n\r\n그래서 이부분에 대해서 고민을 해보았고, 지도의 레이아웃이 처음에 지도를 로드할 때만 바뀌고, 그 이후에는 바뀌지 않는다라는 생각에 `MapView`의 `onLayout`이에 `animateToRegion`으로 지도의 중심 및 범위를 이동시키는 코드를 넣어봤다.\r\n\r\n- `onLayout`: MapView가 화면에 배치될 때(즉, 첫 렌더링될 때) 호출되는 이벤트(뷰의 위치와 크기를 할당하는 단계이다.)\r\n- `animateToRegion(region, duration)`: 지도 영역을 애니메이션으로 이동하는 함수\r\n```js\r\n\u003cMapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: myLocation?.latitude,\r\n          longitude: myLocation?.longitude,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n        onLayout={() =\u003e {\r\n              if (mapRef.current) {\r\n                mapRef.current.animateToRegion(\r\n                  {\r\n                    latitude: myLocation?.latitude,\r\n                    longitude: myLocation?.longitude,\r\n                    latitudeDelta: 0.02,\r\n                    longitudeDelta: 0.02,\r\n                  },\r\n                  0\r\n                );\r\n              }\r\n            }}\r\n      /\u003e\r\n\r\n```\r\n\r\n하지만, 헤더에서 장소를 검색하여 위치를 이동시키는 기능을 구현하던 도중 문제가 발생했는데, 키보드를 열 때마다 지도가 자동으로 리사이징이 되면서 `onLayout` 안의 코드가 실행이 되는 것이었다.\r\n\r\n내가 원하는건 지도가 처음 로드가 될 때 초기에 한번만 지도가 내 위치로 설정이 되는 것인데, 키보드가 열릴때마다 원치않게 내 위치로 지도가 자동 이동이 되는 문제가 발생했다.\r\n\r\n결국 `onLayout`이 아닌 MapView의 또다른 콜백 메소드인 **onMapReady**를 통해 문제를 해결했다.\r\n\r\n- `onMapReady`: 지도가 준비되었을 때 호출되는 콜백 메서드이며, 안의 코드는 지도가 준비되었을 때 초기에 한번만 실행된다.\r\n\r\n```js\r\n\u003cMapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: myLocation?.latitude,\r\n          longitude: myLocation?.longitude,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n        onMapReady={() =\u003e {\r\n              if (mapRef.current) {\r\n                mapRef.current.animateToRegion(\r\n                  {\r\n                    latitude: myLocation?.latitude,\r\n                    longitude: myLocation?.longitude,\r\n                    latitudeDelta: 0.02,\r\n                    longitudeDelta: 0.02,\r\n                  },\r\n                  0\r\n                );\r\n              }\r\n            }}\r\n      /\u003e\r\n```\r\n이제 키보드가 열려도 위치가 이동하지 않았다!\r\n"},{"slug":"posts/React/React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험","title":"React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험","date":"2024-11-11T17:00:24.000Z","image":"index.png","summary":"React 개발자 도구(React dev tools)의 기능들과 이를 활용해본 경험을 공유해보겠다.","tags":["react","next.js","렌더링","트러블슈팅","deepdive","dev tools"],"content":"\r\n# React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험\r\n\r\n## 들어가며\r\n\r\nReact Deep dive를 스터디에서 공부하며 리액트 앱을 디버깅하고 검사할 때 보다 효율적으로 할 수 있는 도구인, **React dev tools**(React 개발자 도구)라는 것을 처음 접하게되었다.\r\n이번 포스팅에서는 React 개발자 도구의 각종 기능에 대해 설명한 후, 이것을 통해 본인의 블로그의 페이지에서 본래 모르고 있었던 지속적으로 발생하고 있던 불필요한 렌더링을 없앤 경험도 공유하고자 한다.\r\n\r\n## React Dev tools란?\r\nReact 애플리케이션을 디버깅하고 최적화하는 데 도움을 주는 브라우저 확장 도구이다. 브라우저의 확장 프로그램으로써 설치하면 사용할 수 있다.  \r\n\r\n참고로 React app의 development모드에서만 원활하게 모든 기능을 사용할 수 있으며 production 모드로 빌드되었을시에는 profiler 기능은 비활성화된다.\r\n \u003cimg src=\"2.png\" alt=\"nextjs\" width = '40' height = '40'/\u003e\r\n만일 production 빌드시에는 이런식으로\r\n이 도구를 사용할 수 있을 때는 \r\n\u003cimg src=\"1.png\" alt=\"nextjs\" width = '40' height = '40'/\u003e\r\n이런식으로 색깔이 들어오게 된다.\r\n\r\n그럼 React dev tools의 기능들인 **Components**, **Profiler** 탭을 보는 방법에 대해서 함께 알아보자\r\n\r\n## Components\r\nComponents 탭에서는 현재 리액트 애플리케이션의 컴포넌트 트리를 확인할 수 있으며, 단순히 구조 뿐만이 아니라, props와 내부 hooks 등 다양한 정보를 확인할 수 있다.\r\n### Components 탭의 기능\r\n- 컴포넌트 트리의 전체적인 구조를 확인할 수 있다.\r\n \u003cimg src=\"3.png\" alt=\"nextjs\"/\u003e\r\n- 보통 state, props의 값을 브라우저에서 확인 하려면 `console.log(...)`이런식으로 로그를 출력하여 확인하는데 컴포넌트 탭에서는 특정 컴포넌트를 그 안에 있는 state, props의 값을 확인할 수 있다.\r\n \u003cimg src=\"4.png\" alt=\"nextjs\"/\u003e\r\n- 또한 단지 state, props 뿐만 아니라 컴포넌트에서 사용된 훅을 볼 수 있는 hooks 도 있는걸 볼 수 있다.\r\n\t- state : useState\r\n\t- Reducer: useReducer\r\n\t- Context: useContext\r\n\t- Callback: useCallback\r\n\t- Ref: useRef\r\n\t- id: useId\r\n\t- LayoutEffect: useLayoutEffect\r\n\t- Effect: useEffect\r\n\t- 그외의 사용자 훅: use가 빠진채로 보여짐( ex. useCounter면 Counter로)\r\n - 또한 rendered by를 통해 해당 컴포넌트를 렌더링한 부모컴포넌트까지 확인할 수 있다.\r\n- 벌레 모양의 버튼을 클릭하면 `log this component data to the console`이라는 문자가 뜨는데 이걸 클릭하면 컴포넌트의 관한 데이터를 콘솔에 찍어볼 수 있다.\r\n \t\u003cimg src=\"5.png\" alt=\"nextjs\"/\u003e\r\n\t\t콘솔에 컴포넌트의 정보가 나타난다.\r\n \t\u003cimg src=\"6.png\" alt=\"nextjs\"/\u003e\r\n\r\nComponents탭의 대표적인 기능들만을 소개했지만, 이외에도 직접 에러를 발생시킨다거나, 컴포넌트의 state, props값을 임의로 바꿔본다든가 등의 기능 역시 사용할 수 있다.\r\n\r\n## Profiler\r\n프로파일러는 리액트가 렌더링하는 과정에서 발생하는 상황을 확인하기 위한 도구다. 즉 리액트 애플리케이션이 렌더링되는 과정에서 어떤 컴포넌트가 렌더링됐는지, 또 몇 차례나 렌더링이 일어났으며 어떤 작업에서 오래 걸렸는지와 같은 것을 확인할 수 있다.\r\n\r\n### 프로파일링 시작하기\r\n처음 프로파일러 탭을 열고, \r\n첫번째 버튼 \"🔵\" 버튼을 누르면 기록이 진행된다. 기록을 시작하면 렌더링 관련 정보들이 자동으로 수집되며, 🔴 버튼을 누르면 수집이 중단되고 결과가 나타난다.\r\n\r\n두번째 버튼을 누르면 새로고침 후 동시에 프로파일링이 시작된다 마찬가지로 첫번째 버튼이 🔴로 바뀌며, 이를 누르면 프로파일링이 중단되고, 결과가 나타난다. \r\n\r\n### Flame Chart\r\n \u003cimg src=\"7.png\" alt=\"nextjs\"/\u003e\r\nFlame Chart는 특정 커밋에 대한 애플리케이션 상태를 보여준다. \r\n차트의 각 막대는 컴포넌트들을 뜻하며 너비가 넓을 수록 해당 컴포넌트를 렌더링 하는데 오래 걸렸다는 것을 의미한다.\r\n\r\n각 컴포넌트에 마우스를 가져다 대면 해당 컴포넌트의 렌더링과 관련된 정보를 확인할 수 있다. \r\n\r\n또한 오른쪽위의 화살표 혹은 막대 그래프를 누르면 각 렌더 커밋별로 리액트에서 발생한 렌더링 정보와 발생한 횟수를 확인할 수 있어 의도한 횟수만큼 렌더링이 발생했는지도 알 수 있다.\r\n\r\n### Ranked\r\n해당 커밋에서 렌더링하는데 오랜시간이 걸린 컴포넌트를 순서대로 나열한 그래프이다.\r\n \u003cimg src=\"8.png\" alt=\"nextjs\"/\u003e\r\nFlamegraph와의 차이점은 모든 컴포넌트가 아닌 단순히 렌더링이 발생한 컴포넌트만 보여준다는 것이다.\r\n\r\n### TimeLine\r\n \u003cimg src=\"9.png\" alt=\"nextjs\"/\u003e\r\n리액트 18이상의 환경에서만 확인할 수 있으며, 시간의 흐름에 따라 리액트가 작동하는 내용을 추적하는데 유용하다. 시간 단위로 프로파일링 기간동안 무슨 일이 있었는지 무엇이 렌더링됐고, 어느 시점에 렌더링됐는지 등에 대해 자세히 확인할 수 있다.\r\n\r\n## 이를 직접  활용하여 불필요한 렌더링 줄여본 경험\r\n### 문제 상황\r\n내 블로그 페이지에는 글을 검색할 수 있는 SearchPage가 있다.\r\nprofiler 탭에서 프로파일링을 시작하고 검색어 입력창에 키워드를 입력하고, 프로파일링을 끝내 보았는데, 문제가 발견되었다.\r\n \u003cimg src=\"10.png\" alt=\"nextjs\"/\u003e\r\n \u003cimg src=\"11.png\" alt=\"nextjs\"/\u003e\r\n검색어를 입력만 했는데 검색어에 따른 포스트들을 보여주는 `PostItem`을 제외하고 이와 관련없는 NavBar, Footer 등 페이지의 모든 요소가 함께 렌더링이 되고 있었다. Ranked로 보니까 시간 역시 제법 차지 하고 있었다.\r\n\r\n또한 검색페이지 뿐만이 아니더라도 카테고리 선택 페이지에서도 마찬가지로 카테고리만 선택했는데도 이와 같은 현상으로 불필요하게 렌더링이 발생하고 있었다.\r\n\r\n... 왜 이런지 Components 탭으로 Header와 Footer와 같은 컴포넌트를 포함하는 컴포넌트인 **Layout 컴포넌트**의 정보를 보니 다음과 같았다.\r\n\r\n그 전에 참고: Layout 컴포넌트 코드 (모달창, 헤더, 푸터등을 관리한다.)\r\n```js\r\nexport default function Layout({ children }: React.PropsWithChildren) {\r\n  const [sidebar,setSideBar] = useState(false);\r\n\t// 사이드바에 관한 useEffect 코드들 (생략)\r\n\treturn (\r\n\t\t\t\u003cProviders\u003e\r\n\t\t\t\t\u003cmain\r\n\t\t\t\t\tclassName={cls(\r\n\t\t\t\t\t\tnotoSansKr.className,\r\n\t\t\t\t\t\topensans.variable,\r\n\t\t\t\t\t\tkanit.variable,\r\n\t\t\t\t\t\t'w-full relative flex flex-col items-center dark:bg-dark-primary dark:text-dark-primary transition-[background]',\r\n\t\t\t\t\t)}\r\n\t\t\t\t\u003e\r\n\t\t\t\t\t\u003cNavbar setSideBar = {setSideBar}/\u003e\r\n\t\t\t\t\t\u003cdiv className=\"w-full flex flex-col items-center\"\u003e{children}\u003c/div\u003e\r\n\t\t\t\t\t{sidebar \u0026\u0026 (\u003cSideBar setSideBar={setSideBar}/\u003e)}\r\n\t\t\t\t\t\u003cFooter /\u003e\r\n\t\t\t\t\u003c/main\u003e\r\n\t\t\t\u003c/Providers\u003e\r\n\t\t);\r\n}\r\n\r\n```\r\n**Layout 컴포넌트 정보**\r\n  \u003cimg src=\"12.png\" alt=\"nextjs\"/\u003e\r\nrendered by PostSearchPage... 참고로 **PostSearchPage의 컴포넌트 정보**는 다음과 같다.\r\n  \u003cimg src=\"13.png\" alt=\"nextjs\"/\u003e\r\n1번째 State인 검색결과,  2번째 State인 검색 키워드 까지 여기서 관리되고 있었기에 당연히 검색을 할 때마다 PostSearchPage이 렌더링되고 이에 따라 **자식 컴포넌트인 Layout역시 같이 렌더링**이 되는 것 이었다.\r\n\r\nPostSearchPage의 코드를 보면,\r\n```js\r\nexport  default  function  PostSearchPage(props: {posts:Post[]}) {\r\n\tconst [posts,setPosts] =  useState\u003cPost[]\u003e(props.posts);\r\n\tconst [keyword,setKeyword] =  useState\u003cstring\u003e('');\r\n\tuseEffect(()=\u003e{\r\n\t\tconst  filteredPosts:Post[] =  searchPosts(props.posts,keyword);\r\n\t\tsetPosts(filteredPosts);\r\n\t},[keyword, props.posts]);\r\n\treturn (\r\n\t\u003cLayout\u003e\r\n\t\t\u003cdiv  className='w-full mt-8 md:w-4/5 px-8'\u003e\r\n\t\t\t\u003cSearchInput  keyword={keyword}  setKeyword  =  {setKeyword}/\u003e\r\n\t\t\u003c/div\u003e\r\n\t\t{/* 검색결과를 보여주는 레이아웃 */}\r\n\t\t\u003cPostLayout  posts={posts}  currentCategory={keyword}  theme='search'/\u003e\r\n\t\u003c/Layout\u003e\r\n\t);\r\n}\r\n```\r\nLayout이 자식으로 있는걸 볼 수 있다.\r\n\r\n### 해결 방법\r\n\r\n이에 대한 해결 방법으로 물론, `Layout`을  메모이제이션을 통해서 변경이 발생할 때만 렌더링 되도록 최적화 할 수도 있지만, `Layout` 컴포넌트가 모든 페이지에서 공통으로 사용되고, `Layout` 자체에서 각 페이지에 의존하는 상태가 없는 점을 고려하여 `_app.tsx`에서 이를 최상위 레이아웃으로 설정하는 것이 더 적절해 보였다.\r\n\r\n ```\r\n Next.js의 page router에서 `_app.tsx` 파일은 애플리케이션 전체의 최상위 컴포넌트를 정의하는 역할을 한다.\r\n```\r\n_app.tsx\r\n```js\r\nexport  default  function  App({ Component, pageProps }:  AppProps) {\r\n\treturn (\r\n\t\t\u003cThemeProvider  attribute='class'  \u003e\r\n\t\t\t\u003cLayout\u003e\r\n\t\t\t\t\u003cComponent  {...pageProps}  /\u003e\r\n\t\t\t\u003c/Layout\u003e\r\n\t\t\u003c/ThemeProvider\u003e\r\n\t);\r\n}\r\n```\r\n변경된 PostSearchPage의 return문\r\n```js\r\nreturn (\r\n\u003c\u003e\r\n\t\u003cdiv  className='w-full mt-8 md:w-4/5 px-8'\u003e\r\n\t\t\u003cSearchInput  keyword={keyword}  setKeyword  =  {setKeyword}/\u003e\r\n\t\u003c/div\u003e\r\n\t{/* 검색결과를 보여주는 레이아웃 */}\r\n\t\u003cPostLayout  posts={posts}  currentCategory={keyword}  theme='search'/\u003e\r\n\u003c/\u003e\r\n);\r\n```\r\n\r\n이와같이 변경하고 다시 프로파일링을 해보니\r\n \u003cimg src=\"14.png\" alt=\"nextjs\"/\u003e\r\nLayout이 더이상 렌더링이 되지않고, 당연히 그전에 불필요하게 렌더링 되었던 Navbar와 Footer도 렌더링이 되지않는다! \r\n\r\n## 마치며\r\n지금까지 React Devtools의 기능에 대해 알아보고, 필자가 이를 이용해서 본인의 블로그에서 발생되는 불필요한 렌더링을 없앤 경험까지 소개해보았다.\r\n\r\n후후.. 지나가는 형님들은 이걸 보며 '뭐야 이 바보는 당연한거 아닌가' 라고 생각할 수도 있겠지만 지금까지 '구현만 되어라' 만 생각했던 구현충인 내가 나름 처음으로 한 최적화? 경험이기에 조금 뿌듯했다. \r\n\r\n그리고 React Devtools를 사용하며 기능 자체는 좋았는데, 뭐가 문제인진 모르겠는데 자꾸 중간에 멈추고 먹통이 되어서 짜증났다. 해결되기 전까지는 chrome 개발자 도구 사용하련다. "}]},"__N_SSG":true},"page":"/posts/tag/[tag]","query":{"tag":"트러블슈팅"},"buildId":"s88PCpXBXr-JVfKLNHdeM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
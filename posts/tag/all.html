<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/f4eeca13f57c12b5.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/f4eeca13f57c12b5.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-aa55ffd08992d156.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-b75415f3abaef78a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/108-ababe0d3bb81df72.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/tag/%5Btag%5D-2e4bb339156220c6.js" defer="" crossorigin=""></script><script src="/_next/static/M_ik3B_k46au3dvCt_K_P/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/M_ik3B_k46au3dvCt_K_P/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"tags":["react","테스트","deepdive","next.js","렌더링","트러블슈팅","dev tools","SSR","SSG","Algorithm","프로그래머스","PCCP","lv2","이분탐색","JavaScript","useState","hook","클로저","생명주기","Virtual DOM","백준","gold","dfs","lv3","bfs"],"currentTag":"all","posts":[{"slug":"posts/React/리액트 컴포넌트 테스트 코드 시작하기","title":"리액트 컴포넌트 테스트 코드 시작하기","date":"2024-11-18T17:00:24.000Z","image":"index.png","summary":"React Deepdive 서적의 React 컴포넌트의 테스트 코드를 정리하였다.","tags":["react","테스트","deepdive"],"content":"\r\n## 들어가며\r\n리액트에서 테스트라는 개념이 있다는 걸 알고 있었지만, 정확히 무슨 개념인지 또한 구체적으로 어떻게 하는 건지 몰랐었다. \r\n\r\nreact deep dive를 공부해보면서 `08 좋은 리액트 코드 작성을 위한 환경 구축하기` 단원 에서 리액트 컴포넌트 테스트코드를 작성하는 부분이 있어서 이 부분에서 공부하면서 배운 리액트 컴포넌트의 기초적인 테스트 코드를 작성하는 방법을 정리해보고자 한다. \r\n\r\n## 리액트 컴포넌트 테스트 \r\n\r\n기본적으로 리액트에서 컴포넌트 테스트는 다음과 같은 순서로 진행된다.\r\n\r\n\t1. 컴포넌트를 렌더링한다.\r\n\t2. 컴포넌트에서 특정 액션을 수행한다.\r\n\t3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과와 실제 결과와 비교한다.\r\n\r\n**App.tsx**\r\n```js\r\nimport React from 'react';\r\nimport logo from './logo.svg';\r\nimport './App.css';\r\nimport StaticComponent from './components/StaticComponent';\r\n\r\nfunction App() {\r\n  return (\r\n    \u003cdiv className=\"App\"\u003e\r\n      \u003cheader className=\"App-header\"\u003e\r\n        \u003cimg src={logo} className=\"App-logo\" alt=\"logo\" /\u003e\r\n        \u003cp\u003e\r\n          Edit \u003ccode\u003esrc/App.tsx\u003c/code\u003e and save to reload.\r\n        \u003c/p\u003e\r\n        \u003ca\r\n          className=\"App-link\"\r\n          href=\"https://reactjs.org\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        \u003e\r\n          Learn React\r\n        \u003c/a\u003e\r\n      \u003c/header\u003e\r\n      \u003cStaticComponent /\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n**테스트 코드**\r\n```js\r\nimport React from 'react';\r\nimport { render, screen } from '@testing-library/react';\r\nimport App from './App';\r\n\r\ntest('renders learn react link', () =\u003e {\r\n  render(\u003cApp /\u003e);\r\n  const linkElement = screen.getByText(/learn react/i);\r\n  expect(linkElement).toBeInTheDocument();\r\n});\r\n\r\n```\r\nApp.test.tsx가 App.tsx에서 테스트하는 내용은 다음과 같이 요약할 수 있다.\r\n1. App 렌더링 \r\n2. App에서 'leartn react' 라는 문자열 가진 DOM 요소 찾기 \r\n3. expect(linkElement).toBeInTheDocument() 라는 어설션을 활용해 2번에서 찾은 요소가 document 내부에 있는지 확인하기\r\n\t\r\n위와 같이 일반적인 리액트 컴포넌트 테스트 시나리오는 특정한 무언가를 지닌 HTML 요소가 있는지 여부이다. \r\n이를 확인하는 방법은 3가지인데,\r\n\r\n- getBy... : 인수에 조건에 맞는 요소를 반환한다. 복수 개를 찾으려면 getAllBy.. 를 사용해야 한다.  \r\n- findBy... : getBy와 유사하지만 Promise를 반환, 즉 비동기로 찾는 것을 의미하며 기본적으로 1s의 타임아웃을 가지고 있다.  복수 개는 findAllBy를 사용한다.\r\n- queryBy... : 인수에 조건에 맞는 요소를 반환하는 대신, 요소를 찾지 못한다면 null이 반환된다. 찾지 못한경우 에 에러를 일으키지 않고 싶을 때 사용한다. 복수 개는 queryAllBy를 사용한다.\r\n\r\n\r\n자 그럼 본격적으로 리액트 컴포넌트들의 테스트 코드를 작성해보자.\r\n\r\n\r\n\r\n## 정적 컴포넌트\r\n\r\n`정적 컴포넌트`란 별도의 상태가 존재하지 않아 항상 같은 결과를 반환하는 컴포넌트이다.\r\n\r\n**정적 컴포넌트**\r\n```js\r\nimport { memo } from 'react'\r\n\r\nconst AnchorTagComponent = memo(function AnchorTagComponent({\r\n  name,\r\n  href,\r\n  targetBlank,\r\n}: {\r\n  name: string\r\n  href: string\r\n  targetBlank?: boolean\r\n}) {\r\n  return (\r\n    \u003ca\r\n      href={href}\r\n      target={targetBlank ? '_blank' : undefined}\r\n      rel=\"noopener noreferrer\"\r\n    \u003e\r\n      {name}\r\n    \u003c/a\u003e\r\n  )\r\n})\r\n\r\nexport default function StaticComponent() {\r\n  return (\r\n    \u003c\u003e\r\n      \u003ch1\u003eStatic Component\u003c/h1\u003e\r\n      \u003cdiv\u003e유용한 링크\u003c/div\u003e\r\n\r\n      \u003cul data-testid=\"ul\" style={{ listStyleType: 'square' }}\u003e\r\n        \u003cli\u003e\r\n          \u003cAnchorTagComponent\r\n            targetBlank\r\n            name=\"리액트\"\r\n            href=\"https://reactjs.org\"\r\n          /\u003e\r\n        \u003c/li\u003e\r\n        \u003cli\u003e\r\n          \u003cAnchorTagComponent\r\n            targetBlank\r\n            name=\"네이버\"\r\n            href=\"https://www.naver.com\"\r\n          /\u003e\r\n        \u003c/li\u003e\r\n        \u003cli\u003e\r\n          \u003cAnchorTagComponent name=\"블로그\" href=\"https://yceffort.kr\" /\u003e\r\n        \u003c/li\u003e\r\n      \u003c/ul\u003e\r\n    \u003c/\u003e\r\n  )\r\n}\r\n```\r\n\r\n이 컴포넌트에서 링크가 제대로 있는지 확인해볼 것이다.\r\n\r\n**테스트 코드**\r\n```js\r\nimport { render, screen } from '@testing-library/react'\r\n\r\nimport StaticComponent from './index'\r\n\r\nbeforeEach(() =\u003e {\r\n  render(\u003cStaticComponent /\u003e)\r\n})\r\n\r\ndescribe('링크 확인', () =\u003e {\r\n  it('링크가 3개 존재한다.', () =\u003e {\r\n    const ul = screen.getByTestId('ul')\r\n    expect(ul.children.length).toBe(3)\r\n  })\r\n\r\n  it('링크 목록의 스타일이 square다.', () =\u003e {\r\n    const ul = screen.getByTestId('ul')\r\n    expect(ul).toHaveStyle('list-style-type: square;')\r\n  })\r\n})\r\n\r\ndescribe('리액트 링크 테스트', () =\u003e {\r\n  it('리액트 링크가 존재한다.', () =\u003e {\r\n    const reactLink = screen.getByText('리액트')\r\n    expect(reactLink).toBeVisible()\r\n  })\r\n\r\n  it('리액트 링크가 올바른 주소로 존재한다.', () =\u003e {\r\n    const reactLink = screen.getByText('리액트')\r\n\r\n    expect(reactLink.tagName).toEqual('A')\r\n    expect(reactLink).toHaveAttribute('href', 'https://reactjs.org')\r\n  })\r\n})\r\n\r\ndescribe('네이버 링크 테스트', () =\u003e {\r\n  it('네이버 링크가 존재한다.', () =\u003e {\r\n    const naverLink = screen.getByText('네이버')\r\n    expect(naverLink).toBeVisible()\r\n  })\r\n\r\n  it('네이버 링크가 올바른 주소로 존재한다.', () =\u003e {\r\n    const naverLink = screen.getByText('네이버')\r\n\r\n    expect(naverLink.tagName).toEqual('A')\r\n    expect(naverLink).toHaveAttribute('href', 'https://www.naver.com')\r\n  })\r\n})\r\n\r\ndescribe('블로그 링크 테스트', () =\u003e {\r\n  it('블로그 링크가 존재한다.',()=\u003e{\r\n    const blogLink = screen.getByText('블로그')\r\n    expect(blogLink).toBeVisible()\r\n  })\r\n  it('블로그 링크가 올바른 주소로 존재한다.', ()=\u003e{\r\n    const blogLink = screen.getByText('블로그')\r\n\r\n    expect(blogLink.tagName).toEqual('A');\r\n    expect(blogLink).toHaveAttribute('href','https://yceffort.kr')\r\n  })\r\n\r\n  it('블로그는 같은 창에서 열려야 한다.', () =\u003e {\r\n    const blogLink = screen.getByText('블로그');\r\n    expect(blogLink).not.toHaveAttribute('target');\r\n  })\r\n})\r\n```\r\n각 테스트를 수행하기전에 StaticComponent를 렌더링하고 describe로 연관된 테스트를 묶어서 it으로 it 함수 내부에 수행하는 테스트파일이다.\r\n\r\n몇 가지 새로운 jest 메서드가 보인다.\r\n\r\n- beforeEach : 각 테스트들을 실행하기 전에 실행하는 함수  \r\n- describe : 비슷한 속성을 가진 테스트를 하나로 묶음 describe 안에 describe를 사용하는것도 가능  \r\n- it : test와 완전히 동일하며 축약어이다.  \r\n- testId : get등의 선택자로 선택하기 어렵거나 곤란한 요소를 선택하기 위해 사용한다.\r\n`\r\n참고로 HTML에 data-testid를 추가하면 getByTestId를 사용할 수 있다.\r\n이는 button의 개수가 많을 때와 같은 특정 시나리오에서 유용하게 사용할 수 있다.\r\n`\r\n\r\n## 동적 컴포넌트\r\n상태값이 있는 컴포넌트, 예를 들어 useState를 사용해 상태값을 관리하는 컴포넌트는 어떻게 테스트할까? 일반적으로 리액트에서는 정적인 경우보다 동적인 경우가 훨씬 많다.\r\n이 경우도 살펴보자.\r\n```js\r\nimport { useState } from 'react'\r\n\r\nexport function InputComponent() {\r\n  const [text, setText] = useState('')\r\n\r\n  function handleInputChange(event: React.ChangeEvent\u003cHTMLInputElement\u003e) {\r\n    const rawValue = event.target.value\r\n    const value = rawValue.replace(/[^A-Za-z0-9]/gi, '')\r\n    setText(value)\r\n  }\r\n\r\n  function handleButtonClick() {\r\n    alert(text)\r\n  }\r\n\r\n  return (\r\n    \u003c\u003e\r\n      \u003clabel htmlFor=\"input\"\u003e아이디를 입력하세요.\u003c/label\u003e\r\n      \u003cinput\r\n        aria-label=\"input\"\r\n        id=\"input\"\r\n        value={text}\r\n        onChange={handleInputChange}\r\n        maxLength={20}\r\n      /\u003e\r\n      \u003cbutton onClick={handleButtonClick} disabled={text.length === 0}\u003e\r\n        제출하기\r\n      \u003c/button\u003e\r\n    \u003c/\u003e\r\n  )\r\n}\r\n```\r\n사용자의 키보드 타이핑 입력을 받는 input, 이를 alert로 띄우는 button으로 구성된 간단한 컴포넌트다. \r\n\r\ninput은 최대 20자까지, 한글 입력만 가능하도록 제한되어있으며, 이는 onChange에서 정규식을 통해 작성되어 있다. 그리고 버튼은 글자가 없으면 disable되도록 처리되어있고, 클릭 시 alert 창을 띄운다.\r\n\r\n테스트 코드는 다음과 같다.\r\n```\r\nimport { fireEvent, render } from '@testing-library/react'\r\nimport userEvent from '@testing-library/user-event'\r\n\r\nimport { InputComponent } from '.'\r\n\r\ndescribe('InputComponent 테스트', () =\u003e {\r\n  const setup = () =\u003e {\r\n    const screen = render(\u003cInputComponent /\u003e)\r\n    const input = screen.getByLabelText('input') as HTMLInputElement\r\n    const button = screen.getByText(/제출하기/i) as HTMLButtonElement\r\n    return {\r\n      input,\r\n      button,\r\n      ...screen,\r\n    }\r\n  }\r\n\r\n  it('input의 초기값은 빈 문자열이다.', () =\u003e {\r\n    const { input } = setup()\r\n    expect(input.value).toEqual('')\r\n  })\r\n\r\n  it('input의 최대길이가 20자로 설정되어 있다.', () =\u003e {\r\n    const { input } = setup()\r\n    expect(input).toHaveAttribute('maxlength', '20')\r\n  })\r\n\r\n  it('영문과 숫자만 입력된다.', () =\u003e {\r\n    const { input } = setup()\r\n    const inputValue = '안녕하세요123'\r\n    userEvent.type(input, inputValue)\r\n    expect(input.value).toEqual('123')\r\n  })\r\n\r\n  it('아이디를 입력하지 않으면 버튼이 활성화 되지 않는다.', () =\u003e {\r\n    const { button } = setup()\r\n    expect(button).toBeDisabled()\r\n  })\r\n\r\n  it('아이디를 입력하면 버튼이 활성화 된다.', () =\u003e {\r\n    const { button, input } = setup()\r\n\r\n    const inputValue = 'helloworld'\r\n    userEvent.type(input, inputValue)\r\n\r\n    expect(input.value).toEqual(inputValue)\r\n    expect(button).toBeEnabled()\r\n  })\r\n\r\n  it('버튼을 클릭하면 alert가 해당 아이디로 뜬다.', () =\u003e {\r\n    const alertMock = jest\r\n      .spyOn(window, 'alert')\r\n      .mockImplementation((_: string) =\u003e undefined)\r\n\r\n    const { button, input } = setup()\r\n    const inputValue = 'helloworld'\r\n\r\n    userEvent.type(input, inputValue)\r\n    fireEvent.click(button)\r\n\r\n    expect(alertMock).toHaveBeenCalledTimes(1)\r\n    expect(alertMock).toHaveBeenCalledWith(inputValue)\r\n  })\r\n})\r\n```\r\n- setup : 내부에서 컴포넌트를 렌더링하고 테스트에 필요한 button,input을 반환한다.  \r\n- userEvent.type : 사용자가 타이핑 하는것을 흉내내는 메서드이다. userEvent.type을 사용하면 사용자가 타이핑하는 것과 동일한 작동을 만들 수 있다.\r\nuserEvent는 fireEvent의 여러 이벤트를 순차적으로 실행해 좀 더 자세하게 사용자의 작동을 흉내낸다. \r\n예를 들어 userEvent.click를 수행하면 \r\n\t- fireEvent.MouseOver  \r\n\t- fireEvent.mouseMove \r\n\t- fireEvent.mouseDown \r\n\t- fireEvent.mouseUp  \r\n\t- fireEvent.click \r\n\r\n\t을 수행한다. \r\n  \r\n  즉 userEvent는 사용자의 작동을 **여러 fireEvent를 통해 좀 더 자세하게 흉내 내는 모듈이**라고 볼 수 있는 것이다.\r\n\r\n\t대부분의 이벤트를 테스트할 때는 fireEvent로 충분하고 훨씬 빠르지만, 특별히 사용자의 이벤트를 흉내 내야 할 때만 userEvent를 사용한다.\r\n  \r\n- **jest.spyOn(window,'alert').mockImplementation()**  \r\n\t- spyOn : 특정 메서드를 오염시키지 않고 실행이 되었는지 , 어떤 인수로 실행되었는지 실행과 관련된 정보만 얻고 싶을때 사용한다. 즉 위의 코드에서는 window 객체의 메서드 alert를 구현하지 않고 해당 메서드가 실행되었는지를 관찰한다는 뜻이다.\r\n\t\r\n\t\r\n\t\tspyon으로 `한번 호출되었는지`(toBeCalledTimes(1)), `원하는 인수와 함께 호출되었는지` (toBeCalledWith(1,2))를 확인할 수 있다. \r\n\t**calc.add자체에는 영향을 미치지 않는다.**\r\n\t- mockImplementation: 해당 메서드에 대한 모킹을 도와준다. Jest환경에서는 window.alert가 존재하지 않는데, 이를 모의함수(mock)로 구현할 수 해주는 메서드이다.\r\n\r\n\t즉 jest.spyOn을 사용해 Node.js에서 존재하지 않는 window.alert를 관찰하고, mockImpletation을 사용해 window.alert가 실행되었는지의 정보를 확인할 수 있도록 처리한 것이다.\r\n\r\n## 비동기 함수 컴포넌트\r\n## 비동기 이벤트가 발생하는 컴포넌트\r\n그렇다면 비동기 이벤트 중 fetch가 실행되는 컴포넌트를 예로 들어보자\r\n\r\n이 코드는 버튼을 클릭하면 /todos/:id로 fetch 요청을 보내 데이터를 불러온다.\r\n\r\n이 fetch를 어떻게 테스트 할 수 있을까?\r\n\r\n우리는 이를 위해 `MSW`를 사용해 볼 것이다.\r\n \r\n MSW는 브라우저에서 사용할 때는 서비스 워커를 활용해 실제 네트워크 요청을 가로채는 방식으로 모킹을 구현하고, Node.js 환경에서는 https나 XMLHttpRequest의 요청을 가로채는 방식으로 작동한다.\r\n즉 node.js에서나 브라우저에서 fetch 요청을 하는 것과 동일하게 네트워크 요청을 수행하고, 이 요청을 중간에 MSW가 감지하고 미리 준비한 모킹 데이터를 제공하는 방식이다.\r\n\r\n이는 fetch의 모든 기능을 그대로 사용하고 응답에 대해서만 모킹할 수 있으므로 fetch를 모킹하는게 훨씬 수월해진다.\r\n\r\n비동기 함수 컴포넌트 테스트 코드\r\n```js\r\nimport { fireEvent, render, screen } from '@testing-library/react'\r\nimport { rest } from 'msw'\r\nimport { setupServer } from 'msw/node'\r\n\r\nimport { FetchComponent } from '.'\r\n\r\nconst MOCK_TODO_RESPONSE = {\r\n  userId: 1,\r\n  id: 1,\r\n  title: 'delectus aut autem',\r\n  completed: false,\r\n}\r\n// 서버를 만드는 역할\r\nconst server = setupServer(\r\n  rest.get('/todos/:id', (req, res, ctx) =\u003e {\r\n    const todoId = req.params.id\r\n\r\n    if (Number(todoId)) {\r\n      return res(ctx.json({ ...MOCK_TODO_RESPONSE, id: Number(todoId) }))\r\n    } else {\r\n      return res(ctx.status(404))\r\n    }\r\n  }),\r\n)\r\n// \r\nbeforeAll(() =\u003e server.listen())\r\n// 초기화했던 초기값유지위해서 이 테스트는 마지막이어서 상관없지만, 그렇지않으면 다른 곳에서도 503에러\r\n// afterEach(() =\u003e server.resetHandlers());\r\nafterAll(() =\u003e server.close())\r\n\r\nbeforeEach(() =\u003e {\r\n  render(\u003cFetchComponent /\u003e)\r\n})\r\n\r\ndescribe('FetchComponent 테스트', () =\u003e {\r\n  it('데이터를 불러오기 전에는 기본 문구가 뜬다.', async () =\u003e {\r\n    const nowLoading = screen.getByText(/불러온 데이터가 없습니다./)\r\n    expect(nowLoading).toBeInTheDocument()\r\n  })\r\n\r\n  it('버튼을 클릭하면 데이터를 불러온다.', async () =\u003e {\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const data = await screen.findByText(MOCK_TODO_RESPONSE.title)\r\n    expect(data).toBeInTheDocument()\r\n  })\r\n\r\n  //여기서만 에러떠야하므로 위에서 resetHandlers 사용\r\n  it('버튼을 클릭하고 서버요청에서 에러가 발생하면 에러문구를 노출한다.', async () =\u003e {\r\n    server.use(\r\n      rest.get('/todos/:id', (req, res, ctx) =\u003e {\r\n        return res(ctx.status(503))\r\n      }),\r\n    )\r\n\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const error = await screen.findByText(/에러가 발생했습니다/)\r\n    expect(error).toBeInTheDocument()\r\n  })\r\n})\r\n```\r\n전체 코드를 나눠서 살펴보자\r\n```js\r\n// 서버를 만드는 역할\r\nconst server = setupServer(\r\n  rest.get('/todos/:id', (req, res, ctx) =\u003e {\r\n    const todoId = req.params.id\r\n\r\n    if (Number(todoId)) {\r\n      return res(ctx.json({ ...MOCK_TODO_RESPONSE, id: Number(todoId) }))\r\n    } else {\r\n      return res(ctx.status(404))\r\n    }\r\n  }),\r\n)\r\n```\r\n- setupServer: 이름 그대로 서버를 만드는 역할이다. \r\n라우트 /todos/:id의 요청만 가로채서 todoId가 숫자인지 확인한 다음, 숫자일 때만 MOCK_TODO_RESPONSE와 id를 반환하고, 숫자가 아니라면 404를 반환하도록 코드를 구성했다. \r\n\r\n테스트 코드를 시작하기 전에는 서버를 기동하고, 종료되면 서버를 종료시킨다. \r\nafterEach에 있는 server.resetHandlers()는 만일 `서버가 실패가 발생하는 경우`를 테스트할 때 ctx.status(503)과 같은 형태로 변경하는데, 이를 리셋하지 않으면 실패하는 코드로 남아있을 것이므로 테스트 실행마다 resetHandlers를 통해 setupServer로 초기화했던 초깃값을 유지하기 위한 것이다.\r\n\r\n그 다음 describe를 시작으로 테스트하고 싶은 내용을 테스트 코드로 작성해보자.\r\n```js\r\nit('버튼을 클릭하면 데이터를 불러온다.', async () =\u003e {\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const data = await screen.findByText(MOCK_TODO_RESPONSE.title)\r\n    expect(data).toBeInTheDocument()\r\n  })\r\n```\r\n버튼을 클릭해 fetch가 발생하는 시나리오를 테스트한다. 버튼을 클릭하는 것 까지는 동일하지만 이후 fetch 응답이 온 뒤에서야 비로소 찾고자 하는 값을 렌더링할 것이다.\r\n\r\n요소가 렌더링될 때까지 일정 시간 동안 기다리는 `find 메서드`를 사용해 요소를 검색한다.\r\n\r\n```js\r\n//여기서만 에러떠야하므로 위에서 resetHandlers 사용\r\n  it('버튼을 클릭하고 서버요청에서 에러가 발생하면 에러문구를 노출한다.', async () =\u003e {\r\n    server.use(\r\n      rest.get('/todos/:id', (req, res, ctx) =\u003e {\r\n        return res(ctx.status(503))\r\n      }),\r\n    )\r\n\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const error = await screen.findByText(/에러가 발생했습니다/)\r\n    expect(error).toBeInTheDocument()\r\n  })\r\n```\r\n앞서 setupServer는 정상적인 응답만 모킹했기 때문에 에러가 발생하는 경우를 테스트하기 힘들다.\r\n\r\n서버 응답이 실패하는 경우를 테스트하기 위해서는 `server.use`를 사용해 기존 `setupServer`의 내용을 새롭게 덮어쓴다. 모든 경우에 503이 오도록 작성했고, 서버 설정이 끝난 후에는 findBy를 이용해 에러 문구가 정상적으로 노출됐는지 확인한다.\r\n\r\nserver.use를 활용해 서버 기본 작동을 덮어쓰는 작업은 위의 코드에서만 유효해야하고, 다른 코드에서는 원래대로 다시 서버 작동이 되어야하므로 위에서 afterEach에서 resetHandlers를 실행하는 것이다. \r\n\r\n비동기 컴포넌트의 테스트에서 중요한 것은 **MSW를 사용한 fetch 응답 모킹**과 **findBy를 활용해 비동기 요청이 끝난 뒤에 제대로 된 렌더링이 일어났는지 기다린 후에 확인하는 것**이다.\r\n## 마치며\r\n지금까지 리액트에서 사용될 수 있는 3가지 종류의 컴포넌트 `정적 컴포넌트`, `동적 컴포넌트`, `비동기 이벤트가 발생하는 컴포넌트`의 간단한 테스트 코드를 살펴보았다.\r\n\r\n책에는 이외에도 추가로 `사용자 정의 훅을 테스트하기`가 있는데, 이 부분은 조만간 테스트가 익숙해진 이후 실제로 프로젝트에서 사용해본 사용자 정의 훅을 테스트하는  글을 포스팅해볼 예정이다.\r\n\r\n테스트에 관한 글은 계속 올릴 것 이니 많관부.\r\n\r\n\r\n"},{"slug":"posts/React/React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험","title":"React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험","date":"2024-11-11T17:00:24.000Z","image":"index.png","summary":"React 개발자 도구(React dev tools)의 기능들과 이를 활용해본 경험을 공유해보겠다.","tags":["react","next.js","렌더링","트러블슈팅","deepdive","dev tools"],"content":"\r\n# React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험\r\n\r\n## 들어가며\r\n\r\nReact Deep dive를 스터디에서 공부하며 리액트 앱을 디버깅하고 검사할 때 보다 효율적으로 할 수 있는 도구인, **React dev tools**(React 개발자 도구)라는 것을 처음 접하게되었다.\r\n이번 포스팅에서는 React 개발자 도구의 각종 기능에 대해 설명한 후, 이것을 통해 본인의 블로그의 페이지에서 본래 모르고 있었던 지속적으로 발생하고 있던 불필요한 렌더링을 없앤 경험도 공유하고자 한다.\r\n\r\n## React Dev tools란?\r\nReact 애플리케이션을 디버깅하고 최적화하는 데 도움을 주는 브라우저 확장 도구이다. 브라우저의 확장 프로그램으로써 설치하면 사용할 수 있다.  \r\n\r\n참고로 React app의 development모드에서만 원활하게 모든 기능을 사용할 수 있으며 production 모드로 빌드되었을시에는 profiler 기능은 비활성화된다.\r\n \u003cimg src=\"2.png\" alt=\"nextjs\" width = '40' height = '40'/\u003e\r\n만일 production 빌드시에는 이런식으로\r\n이 도구를 사용할 수 있을 때는 \r\n\u003cimg src=\"1.png\" alt=\"nextjs\" width = '40' height = '40'/\u003e\r\n이런식으로 색깔이 들어오게 된다.\r\n\r\n그럼 React dev tools의 기능들인 **Components**, **Profiler** 탭을 보는 방법에 대해서 함께 알아보자\r\n\r\n## Components\r\nComponents 탭에서는 현재 리액트 애플리케이션의 컴포넌트 트리를 확인할 수 있으며, 단순히 구조 뿐만이 아니라, props와 내부 hooks 등 다양한 정보를 확인할 수 있다.\r\n### Components 탭의 기능\r\n- 컴포넌트 트리의 전체적인 구조를 확인할 수 있다.\r\n \u003cimg src=\"3.png\" alt=\"nextjs\"/\u003e\r\n- 보통 state, props의 값을 브라우저에서 확인 하려면 `console.log(...)`이런식으로 로그를 출력하여 확인하는데 컴포넌트 탭에서는 특정 컴포넌트를 그 안에 있는 state, props의 값을 확인할 수 있다.\r\n \u003cimg src=\"4.png\" alt=\"nextjs\"/\u003e\r\n- 또한 단지 state, props 뿐만 아니라 컴포넌트에서 사용된 훅을 볼 수 있는 hooks 도 있는걸 볼 수 있다.\r\n\t- state : useState\r\n\t- Reducer: useReducer\r\n\t- Context: useContext\r\n\t- Callback: useCallback\r\n\t- Ref: useRef\r\n\t- id: useId\r\n\t- LayoutEffect: useLayoutEffect\r\n\t- Effect: useEffect\r\n\t- 그외의 사용자 훅: use가 빠진채로 보여짐( ex. useCounter면 Counter로)\r\n - 또한 rendered by를 통해 해당 컴포넌트를 렌더링한 부모컴포넌트까지 확인할 수 있다.\r\n- 벌레 모양의 버튼을 클릭하면 `log this component data to the console`이라는 문자가 뜨는데 이걸 클릭하면 컴포넌트의 관한 데이터를 콘솔에 찍어볼 수 있다.\r\n \t\u003cimg src=\"5.png\" alt=\"nextjs\"/\u003e\r\n\t\t콘솔에 컴포넌트의 정보가 나타난다.\r\n \t\u003cimg src=\"6.png\" alt=\"nextjs\"/\u003e\r\n\r\nComponents탭의 대표적인 기능들만을 소개했지만, 이외에도 직접 에러를 발생시킨다거나, 컴포넌트의 state, props값을 임의로 바꿔본다든가 등의 기능 역시 사용할 수 있다.\r\n\r\n## Profiler\r\n프로파일러는 리액트가 렌더링하는 과정에서 발생하는 상황을 확인하기 위한 도구다. 즉 리액트 애플리케이션이 렌더링되는 과정에서 어떤 컴포넌트가 렌더링됐는지, 또 몇 차례나 렌더링이 일어났으며 어떤 작업에서 오래 걸렸는지와 같은 것을 확인할 수 있다.\r\n\r\n### 프로파일링 시작하기\r\n처음 프로파일러 탭을 열고, \r\n첫번째 버튼 \"🔵\" 버튼을 누르면 기록이 진행된다. 기록을 시작하면 렌더링 관련 정보들이 자동으로 수집되며, 🔴 버튼을 누르면 수집이 중단되고 결과가 나타난다.\r\n\r\n두번째 버튼을 누르면 새로고침 후 동시에 프로파일링이 시작된다 마찬가지로 첫번째 버튼이 🔴로 바뀌며, 이를 누르면 프로파일링이 중단되고, 결과가 나타난다. \r\n\r\n### Flame Chart\r\n \u003cimg src=\"7.png\" alt=\"nextjs\"/\u003e\r\nFlame Chart는 특정 커밋에 대한 애플리케이션 상태를 보여준다. \r\n차트의 각 막대는 컴포넌트들을 뜻하며 너비가 넓을 수록 해당 컴포넌트를 렌더링 하는데 오래 걸렸다는 것을 의미한다.\r\n\r\n각 컴포넌트에 마우스를 가져다 대면 해당 컴포넌트의 렌더링과 관련된 정보를 확인할 수 있다. \r\n\r\n또한 오른쪽위의 화살표 혹은 막대 그래프를 누르면 각 렌더 커밋별로 리액트에서 발생한 렌더링 정보와 발생한 횟수를 확인할 수 있어 의도한 횟수만큼 렌더링이 발생했는지도 알 수 있다.\r\n\r\n### Ranked\r\n해당 커밋에서 렌더링하는데 오랜시간이 걸린 컴포넌트를 순서대로 나열한 그래프이다.\r\n \u003cimg src=\"8.png\" alt=\"nextjs\"/\u003e\r\nFlamegraph와의 차이점은 모든 컴포넌트가 아닌 단순히 렌더링이 발생한 컴포넌트만 보여준다는 것이다.\r\n\r\n### TimeLine\r\n \u003cimg src=\"9.png\" alt=\"nextjs\"/\u003e\r\n리액트 18이상의 환경에서만 확인할 수 있으며, 시간의 흐름에 따라 리액트가 작동하는 내용을 추적하는데 유용하다. 시간 단위로 프로파일링 기간동안 무슨 일이 있었는지 무엇이 렌더링됐고, 어느 시점에 렌더링됐는지 등에 대해 자세히 확인할 수 있다.\r\n\r\n## 이를 직접  활용하여 불필요한 렌더링 줄여본 경험\r\n### 문제 상황\r\n내 블로그 페이지에는 글을 검색할 수 있는 SearchPage가 있다.\r\nprofiler 탭에서 프로파일링을 시작하고 검색어 입력창에 키워드를 입력하고, 프로파일링을 끝내 보았는데, 문제가 발견되었다.\r\n \u003cimg src=\"10.png\" alt=\"nextjs\"/\u003e\r\n \u003cimg src=\"11.png\" alt=\"nextjs\"/\u003e\r\n검색어를 입력만 했는데 검색어에 따른 포스트들을 보여주는 `PostItem`을 제외하고 이와 관련없는 NavBar, Footer 등 페이지의 모든 요소가 함께 렌더링이 되고 있었다. Ranked로 보니까 시간 역시 제법 차지 하고 있었다.\r\n\r\n또한 검색페이지 뿐만이 아니더라도 카테고리 선택 페이지에서도 마찬가지로 카테고리만 선택했는데도 이와 같은 현상으로 불필요하게 렌더링이 발생하고 있었다.\r\n\r\n... 왜 이런지 Components 탭으로 Header와 Footer와 같은 컴포넌트를 포함하는 컴포넌트인 **Layout 컴포넌트**의 정보를 보니 다음과 같았다.\r\n\r\n그 전에 참고: Layout 컴포넌트 코드 (모달창, 헤더, 푸터등을 관리한다.)\r\n```js\r\nexport default function Layout({ children }: React.PropsWithChildren) {\r\n  const [sidebar,setSideBar] = useState(false);\r\n\t// 사이드바에 관한 useEffect 코드들 (생략)\r\n\treturn (\r\n\t\t\t\u003cProviders\u003e\r\n\t\t\t\t\u003cmain\r\n\t\t\t\t\tclassName={cls(\r\n\t\t\t\t\t\tnotoSansKr.className,\r\n\t\t\t\t\t\topensans.variable,\r\n\t\t\t\t\t\tkanit.variable,\r\n\t\t\t\t\t\t'w-full relative flex flex-col items-center dark:bg-dark-primary dark:text-dark-primary transition-[background]',\r\n\t\t\t\t\t)}\r\n\t\t\t\t\u003e\r\n\t\t\t\t\t\u003cNavbar setSideBar = {setSideBar}/\u003e\r\n\t\t\t\t\t\u003cdiv className=\"w-full flex flex-col items-center\"\u003e{children}\u003c/div\u003e\r\n\t\t\t\t\t{sidebar \u0026\u0026 (\u003cSideBar setSideBar={setSideBar}/\u003e)}\r\n\t\t\t\t\t\u003cFooter /\u003e\r\n\t\t\t\t\u003c/main\u003e\r\n\t\t\t\u003c/Providers\u003e\r\n\t\t);\r\n}\r\n\r\n```\r\n**Layout 컴포넌트 정보**\r\n  \u003cimg src=\"12.png\" alt=\"nextjs\"/\u003e\r\nrendered by PostSearchPage... 참고로 **PostSearchPage의 컴포넌트 정보**는 다음과 같다.\r\n  \u003cimg src=\"13.png\" alt=\"nextjs\"/\u003e\r\n1번째 State인 검색결과,  2번째 State인 검색 키워드 까지 여기서 관리되고 있었기에 당연히 검색을 할 때마다 PostSearchPage이 렌더링되고 이에 따라 **자식 컴포넌트인 Layout역시 같이 렌더링**이 되는 것 이었다.\r\n\r\nPostSearchPage의 코드를 보면,\r\n```js\r\nexport  default  function  PostSearchPage(props: {posts:Post[]}) {\r\n\tconst [posts,setPosts] =  useState\u003cPost[]\u003e(props.posts);\r\n\tconst [keyword,setKeyword] =  useState\u003cstring\u003e('');\r\n\tuseEffect(()=\u003e{\r\n\t\tconst  filteredPosts:Post[] =  searchPosts(props.posts,keyword);\r\n\t\tsetPosts(filteredPosts);\r\n\t},[keyword, props.posts]);\r\n\treturn (\r\n\t\u003cLayout\u003e\r\n\t\t\u003cdiv  className='w-full mt-8 md:w-4/5 px-8'\u003e\r\n\t\t\t\u003cSearchInput  keyword={keyword}  setKeyword  =  {setKeyword}/\u003e\r\n\t\t\u003c/div\u003e\r\n\t\t{/* 검색결과를 보여주는 레이아웃 */}\r\n\t\t\u003cPostLayout  posts={posts}  currentCategory={keyword}  theme='search'/\u003e\r\n\t\u003c/Layout\u003e\r\n\t);\r\n}\r\n```\r\nLayout이 자식으로 있는걸 볼 수 있다.\r\n\r\n### 해결 방법\r\n\r\n이에 대한 해결 방법으로 물론, `Layout`을  메모이제이션을 통해서 변경이 발생할 때만 렌더링 되도록 최적화 할 수도 있지만, `Layout` 컴포넌트가 모든 페이지에서 공통으로 사용되고, `Layout` 자체에서 각 페이지에 의존하는 상태가 없는 점을 고려하여 `_app.tsx`에서 이를 최상위 레이아웃으로 설정하는 것이 더 적절해 보였다.\r\n\r\n\u003e Next.js의 page router에서 `_app.tsx` 파일은 애플리케이션 전체의 최상위 컴포넌트를 정의하는 역할을 한다.\r\n\r\n_app.tsx\r\n```js\r\nexport  default  function  App({ Component, pageProps }:  AppProps) {\r\n\treturn (\r\n\t\t\u003cThemeProvider  attribute='class'  \u003e\r\n\t\t\t\u003cLayout\u003e\r\n\t\t\t\t\u003cComponent  {...pageProps}  /\u003e\r\n\t\t\t\u003c/Layout\u003e\r\n\t\t\u003c/ThemeProvider\u003e\r\n\t);\r\n}\r\n```\r\n변경된 PostSearchPage의 return문\r\n```js\r\nreturn (\r\n\u003c\u003e\r\n\t\u003cdiv  className='w-full mt-8 md:w-4/5 px-8'\u003e\r\n\t\t\u003cSearchInput  keyword={keyword}  setKeyword  =  {setKeyword}/\u003e\r\n\t\u003c/div\u003e\r\n\t{/* 검색결과를 보여주는 레이아웃 */}\r\n\t\u003cPostLayout  posts={posts}  currentCategory={keyword}  theme='search'/\u003e\r\n\u003c/\u003e\r\n);\r\n```\r\n\r\n이와같이 변경하고 다시 프로파일링을 해보니\r\n \u003cimg src=\"14.png\" alt=\"nextjs\"/\u003e\r\nLayout이 더이상 렌더링이 되지않고, 당연히 그전에 불필요하게 렌더링 되었던 Navbar와 Footer도 렌더링이 되지않는다! \r\n\r\n## 마치며\r\n지금까지 React Devtools의 기능에 대해 알아보고, 필자가 이를 이용해서 본인의 블로그에서 발생되는 불필요한 렌더링을 없앤 경험까지 소개해보았다.\r\n\r\n후후.. 지나가는 형님들은 이걸 보며 '뭐야 이 바보는 당연한거 아닌가' 라고 생각할 수도 있겠지만 지금까지 '구현만 되어라' 만 생각했던 구현충인 내가 나름 처음으로 한 최적화? 경험이기에 조금 뿌듯했다. \r\n\r\n그리고 React Devtools를 사용하며 기능 자체는 좋았는데, 뭐가 문제인진 모르겠는데 자꾸 중간에 멈추고 먹통이 되어서 짜증났다. 해결되기 전까지는 chrome 개발자 도구 사용하련다. "},{"slug":"posts/React/서버사이드 렌더링에 대해 알아보자","title":"서버사이드 렌더링에 대해 알아보자(Feat: next.js, SSG)","date":"2024-11-03T22:00:24.000Z","image":"index.png","summary":"클라이언트 사이드 렌더링(CSR)과 서버 사이드 렌더링(SSR)에 대해서 그리고 SSR을 활용한 next.js 예제와 SSG의 개념과 예제까지 알아보자.","tags":["react","next.js","deepdive","SSR","SSG","렌더링"],"content":"\r\n프론트엔드를 공부하노라면 **SPA**(Single Page Application)와  **CSR**(Client Side Rendering)과 **SSR(Server Side Rendering)**에 대해 한번 씩 이라도 들어보았을 것 이다.\r\n\r\n하지만 개념이 확실히 안잡힐 때가 있고, 뭐를 써야 더 좋은지도 모를 때도 많다.\r\n\r\n이번 포스팅에서는 SPA,CSR에 대해 간단히 알아본 후, **SSR**에 대해서 보다 더 자세히 개념과  이것이 쓰이는 Next.js 코드 예제에 대해서도 살펴볼 것이다. \r\n\r\n그리고 더 나아가 정적 데이터를 미리 로드하는**SSG**(Static Site Generation)에 대해서도 알아볼 것이다.\r\n\r\n## 그 전에 SPA란?\r\n\r\n**싱글 페이지 애플리케이션(SPA)**은 SSR(Server-Side Rendering)과 다른 렌더링 방식인 **CSR(Client-Side Rendering)**을 주로 사용하여 서버가 아닌 브라우저에서 페이지를 렌더링하고 전환한다.\r\n\r\nSPA는 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 **브라우저의 JavaScript에 의존하는 방식**인 CSR을 사용하여 구현된다. \r\n\r\nSPA에서는 주로 CSR을 사용하여 처음 페이지를 로드할 때 필요한 데이터를 한 번에 받아오고, 이후에는 서버에서 HTML을 새로 내려받지 않고 **하나의 페이지에서 모든 작업을 처리하기 때문에** **싱글 페이지 애플리케이션(SPA)**이라고 불리는 것이다.\r\n```html\r\n\u003cbody\u003e\u003cnoscript\u003eYou need to enable JavaScript to run this app.\u003c/noscript\u003e\u003cdiv id=\"root\"\u003e\u003c/div\u003e\u003c/body\u003e\u003c/html\u003e\r\n```\r\n위의 SPA를 사용하는 HTML소스를 보면  HTML 코드의 `body` 내부가 비어 있다. \r\n\r\n이는 사이트 렌더링에 필요한 body 내부의 내용을 모두 **자바스크립트 코드**로 삽입한 후에 렌더링하기 때문이다. .\r\n\r\nCSR을 사용하는 SPA는 한번 로딩된 이후에는 페이지 전환 속도가 빠르고 사용자와의 상호작용이 부드럽다는 장점이 있지만, 최초의 로딩해야 할 자바스크립트 리소스가 커진다는 것 그리고 그로 인해 초기 로딩 속도가 길어진다는 단점이 있다.\r\n\r\n## SSR\r\n싱글 페이지 애플리케이션이 자바스크립트를 활용해 하나의 페이지에서만 렌더링을 수행한다면 서버 사이드 렌더링은 **최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식**이다.\r\n\r\n즉 앞서 살펴보았던 CSR과 SSR의 차이는 웹페이지 렌더링의 책임을 어디에 두느냐인데,  CSR을 사용하는 SPA는 사용자에게 제공되는 자바스크립트 번들에서 렌더링을 담당하지만, SSR을 채택하면 렌더링에 필요한 작업을 모두 서버에서 수행한다. \r\n\r\n클라이언트 렌더링은 사용자 기기의 성능에 영향을 받지만, 서버 사이드 렌더링은 서버에서 제공하기 때문에 안정적인 렌더링이 가능하다.\r\n\r\n## SSR의 장단점\r\n### 장점\r\n- 최초 페이지 진입이 비교적 빠르다.\r\n\t\r\n\t최초 페이지 진입 시 페이지에 유의미한 정보가 그려지는 시간인 FCP(First Contentful Paint)가 SPA에 비해 더 빨라질 수 있다. 다만, 서버가 사용자에게 렌더링을 제공할 수 있는 충분한 리소스가 확보되어 있다라는 가정하에 비교한 것이다.\r\n\t\r\n- 검색 엔진과 SNS 공유 등 메타 데이터 제공이 쉽다.\r\n\t\r\n\t검색 엔진 로봇이 페이지의 정보를 가져올 때 HTML을 다운로드 하는데, 단, **이 때 자바스크립트 코드는 실행하지 않는다.** \r\n\r\n\t다운로드한 HTML 페이지 내부의 오픈 그래프(Open Graph)나 메타(meta) 태그 정보를 \t기반으로 페이지의 검색 정보를 가져오고, 이를 바탕으로 검색 엔진에 저장한다.\r\n\r\n\t서버사이드 렌더링을 사용하면 최초의 렌더링 작업이 서버에서 일어난다. 즉 검색 엔진에서 제공할 정보를 서버에서 가공하여 HTML 응답으로 제공할 수 있으므로 SEO에 대응하기가 용이하다.\r\n\t\r\n\tSSR을 사용하는 next js에서는 generateMetaData라는 함수를 사용 (14버전 app router기준) 하여 데이터를 미리 페칭하여 동적으로 이와 같이 비교적 쉽게 메타데이터의 내용을 설정할 수도 있다. \r\n\t```js\r\n\t// params는 groupId라고 설정된 페이지의 동적 파라미터를 받아오는 것\r\n\texport  async  function  generateMetadata({params}: {params: {groupId:  string}}) {\r\n\t// 이 params를 통해서 서버에 미리 데이터를 요청한다.\r\n\tconst  response  =  await  fetchGroupData({queryKey: ['groupDetail',Number(params.groupId)]});\r\n\t// 요청한 데이터를 이런식으로 return 하여 head 태그의 title과 description에 넣을 수 있다.\r\n\t\treturn {\r\n\t\t\ttitle:  `${response.name}`,\r\n\t\t\tdescription:  `${response.description}`,\r\n\t\t}\r\n\t}\r\n\t```\r\n\r\n- 누적 레이아웃 이동이 적다.\r\n\t누적 레이아웃 이동은 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥 거리는 것과 같은 부정적인 사용자 경험을 말하는 것이다. \r\n\r\n\tapi요청이 다 완료된 이후에 완성된 페이지를 제공하는 서버 사이드 렌더링은 이러한 문제에서 비교적 자유롭다.\r\n\r\n- 사용자의 디바이스 성능에 비교적 자유롭다.\r\n\t- 서버와 함께 데이터를 로드하는 부담을 나누므로, 보다 사용자 디바이스 성능에 자유롭다.\r\n\r\n### 단점\r\n- 소스코드를 작성할 때 항상 서버를 고려해야 한다.\r\n\r\n\twindow 또는 sessionStorage와 같은 브라우저 전역 객체에 접근하는 코드는 서버에서 실행될 수 없어 이를 고려 해야 하고, 외부 라이브러리 역시 서버에 대한 고려를 해야만한다.\r\n- 적절한 서버가 구축되어있어야 한다.\r\n\r\n\t서버 사이드 렌더링은 말 그대로 사용자의 요청을 받아 렌더링을 수행할 서버가 필요하므로, 사용자의 요청에 따라 적절히 대응하는 것, 예기치 못한 장애상황에 대응하는 전략도 필요하다\r\n- 서비스 지연 문제\r\n\t\r\n\tSPA에서는 최초에 어떤 화면이라도 보여준 상태에서 느린 작업이 수행되기 때문에 '로딩 중'과 같은 것으로 안내하면 되지만, SSR에서는 특히 이 지연 작업이 최초 렌더링에 발생한다면 사용자에게 그 어떤 정보를 제공할 수 없기에, 더 안좋은 사용자 경험을 제공할 수 있다.\r\n\r\n## Next js에서 사용되는 SSR\r\n\r\nReact DeepDive는 Next.js 13을 기준으로 책이 쓰여졌기에 page router의 **getServerSideProps**를 사용하는 것을 next.js의 서버 사이드 렌더링의 예제로 사용하고 있다.\r\n\r\n 해당 함수가 있다면 무조건 페이지 진입 전에 이 함수를 실행한다.\r\n\r\n이 함수는 응답값에 따라 페이지의 컴포넌트에 props를 반환할 수도, 혹은 다른 페이지로 리다이렉트 시킬 수 있다.\r\n```js\r\nimport type {GetServerSideProps} from 'next';\r\n\r\nexport default function Post({post}: {post:Post}) {\r\n\t// 렌더링\r\n}\r\n\r\nexport const getServerSideProps: GetServerSideProps = async (context) =\u003e {\r\n\t// /post/[id]와 같은 경로에 있는 id 값에 접근할 수 있다. (여기서 id는 동적 파라미터)\r\n\tconst {\r\n\tquery: {id: ''},\r\n\t} = context\r\n\tconst post = await fetchPost(id.toString());\r\n\treturn {\r\n\t\tprops: {post},\r\n\t}\r\n}\r\n```\r\n\r\nconstext.query.id를 사용하면  /post/[id] 같은 경로에 있는 id 값에 접근할 수 있다. \r\n(ex ) `www.aaa.com/post/12` 면 `12`추출 가능)\r\n\r\n위의 코드는 페이지의 경로의 id에 접근하여 그 값을 파라미터로 받는 데이터 요청 함수(fetchPost)를 통해 데이터를 받고 받은 데이터를 props에 return 하고 있다.\r\n\r\n이렇게 getServerSideProps로 미리 props를 제공하면 페이지의 Post 컴포넌트에 해당 값을 제공하여 이 반환 값을 기반으로 렌더링 한다.\r\n\r\n그렇다면 14버전의 Next.js App router에서는 이를 어떻게 구현할지도 살펴보자.\r\n\r\n```js\r\n// app/post/[id]/page.js\r\n\r\nimport { fetchPost } from '@/lib/api'; // fetchPost 함수는 외부 API 호출 함수라고 가정\r\n\r\nexport default async function Post({ params }) {\r\n  const { id } = params;\r\n  const post = await fetchPost(id); // 데이터를 서버 측에서 가져옴\r\n\r\n  return (\r\n    \u003c\u003e\r\n      \u003cPostInfo title = {post.title} content = {post.content}/\u003e\r\n    \u003c/\u003e\r\n  );\r\n}\r\n```\r\n\r\n14버전 next js은 getServerSideProps와 같은 함수를 쓰는 대신, 컴포넌트를 **클라이언트 컴포넌트**와 **서버 컴포넌트**로 나눈다. \r\n\r\n위의 컴포넌트 Post는 서버 컴포넌트이다. 14버전의 next.js에서는 최상단에 따로 명령어를 쓰지 않으면 컴포넌트를 서버 컴포넌트로 인식한다. \r\n\r\nPost 컴포넌트에서는 페이지 파라미터 값을 통해 데이터를 서버 단에서 가져오고 있다.\r\n우리는 이 데이터를 클라이언트 컴포넌트인 PostInfo에 props로 넘겨줄 것 이다.\r\n\r\n클라이언트 컴포넌트를 사용하고 싶다면 'use client'를 최상단에 쓰면 된다. \r\n```js\r\n'use client'\r\n\r\nexport default async function PostInfo({title, content}) {\r\n\treturn (\r\n\t\t\u003cdiv\u003e \r\n\t\t\t\u003ch1\u003e{title}\u003c/h1\u003e \r\n\t\t\t\u003cp\u003e{content}\u003c/p\u003e \r\n\t\t\u003c/div\u003e\r\n\t);\r\n}\r\n```\r\nPostInfo는 맨 위에 'use client'를 선언했으므로, **클라이언트 컴포넌트** 이다. 서버 컴포넌트인 Post에서 미리 로드하여 넘겨준 데이터를 props로 받아 화면에 나타내는 역할을 한다.\r\n\r\n이와 같이 Next.js 에서는 여러 API를 사용해서 복잡하게 SSR을 복잡하게 구현해야 하는 react에 비해서 비교적 간단하게 SSR을 구현할 수 있다.\r\n\r\n## + SSG\r\n\r\nSSG(Static Site Generation)는 Next.js에서 페이지를 빌드할 때 미리 HTML 파일로 생성하여 저장해 두고, 사용자가 해당 페이지에 접근할 때 서버 요청 없이 정적 파일을 제공하는 방식이다. \r\n\r\n이는 특히 자주 변경되지 않는 콘텐츠를 가진 블로그와 같은 페이지에서 성능과 SEO 최적화에 유리한 방법이다.\r\n\r\n내 블로그 역시 이와 같은 방식을 사용하고 있는데, Next.js의 page router를 사용하고 있어서 `getStaticProps`와 `getStaticPath`로 SSG를 구현하고 있다.\r\n\r\n- getStaticPaths: 페이지가 접근 가능한 주소를 미리 정의하는 함수이다. 예를 들어, /pages/post/[id]라는 경로가 있고\r\n\t```js\r\n\texport default getStaticPaths = async () =\u003e {\r\n\t\treturn {\r\n\t\t\tpaths: [{params: {id: '1'}}, {params: {id:'2'}}],\r\n\t\t\tfallback: false,\r\n\t\t}\r\n\t}\r\n\t```\r\n\t이와 같이 함수가 정의 되어있다면 /post/1과 /post/2 만 접근이 가능하며, 그외의 /posts/3 등은 404를 반환한다. (단, fallback이 true라면 빌드가 되기전까지 fallback 컴포넌트를 보여주고, 그 이후에는 해당 페이지를 보여준다.) \r\n\t\r\n- getStaticProps: 앞에서 정의한 페이지를 기준으로 해당 페이지로 요청이 왔을 때 제공할 props를 반환하는 함수이다. 위에처럼 id가 1과 2로만 제한되므로, fetchPost(1), fetchPost(2)을 기준으로 함수의 응답값을 props의 {post}로 반환한다.\r\n\t```js\r\n\texport const getStaticProps = async ({params}) =\u003e {\r\n\t\tconst {id} = params;\r\n\t\tconst post = await fetchPost(id);\r\n\t\t\r\n\t\treturn {\r\n\t\t\tprops: {post}\r\n\t\t}\r\n\t}\r\n\t```\r\n\r\n### 내 블로그에서 사용한 코드\r\n\r\n\r\n```js\r\nexport  function  getStaticPaths() {\r\n\t// 파일들을 모두 받아오고, slug를 추출한다.\r\n\tconst  slugs  =  getAllPosts().map((file:Post) =\u003e  file.slug);\r\n\t// 이 slug들을 경로로 미리 지정한다.\r\n\treturn {\r\n\t\tpaths:  slugs.map((slug:  string) =\u003e {\r\n\t\t\r\n\t\t\tconst  detail  =  slug.split('/');\r\n\t\t\t// params에 각각의 경로는 배열로 넘겨줘야 한다. (ex. /posts/detail이면 ['post', 'detail'] 이런 식 으로\r\n\t\t\treturn { params: { detail } };\r\n\t\t}),\r\n\t\tfallback:  false,\r\n\t};\r\n}\r\n```\r\n나의 블로그에서는 getStaticPaths에서는 모든 포스트들의 slug\r\n(slug는 /posts/category/파일명 방식으로 되어있는 파일의 경로로 보면 된다.)를 params로 넘겨주어 경로를 미리 지정했다.\r\n\r\n```js\r\nexport  const  getStaticProps  :GetStaticProps  = ({params}) =\u003e {\r\n\r\n\tconst {detail} =  params  as {detail:string[]};\r\n\t// 배열을 다시 문자열로 바꾸고, 여기에 .mdx를 붙인다.\r\n\tconst  detailPath  =  detail.join('/')+'.mdx';\r\n\tconst  postData  =  getPostData(`${detailPath}`);\r\n\r\n\treturn {\r\n\t\tprops: {\r\n\t\t\tpost:  JSON.parse(JSON.stringify(postData)),\r\n\t\t},\r\n\t};\r\n}\r\n```\r\n이후 받아온 params를 사용하여 해당하는 mdx파일을 미리 받아온다.  이를 props로 넘겨주면 페이지에서 이 데이터를 사용할 수 있다.\r\n```js\r\nexport  function  PostDetailPage(props:PostDetailProps) {\r\n\treturn (\r\n\t\u003c\u003e\r\n\t\t\u003cHead\u003e\r\n\t\t\t\u003ctitle\u003e{props.post.title}\u003c/title\u003e\r\n\t\t\t\u003cmeta  name=\"description\"  content={`${props.post.summary}`}  /\u003e\r\n\t\t\u003c/Head\u003e\r\n\t\t\u003cPostDetailLayout  post={props.post} /\u003e\r\n\t\u003c/\u003e\r\n\t)\r\n}\r\n```\r\nprops로 미리 빌드하여 생성한 데이터를 받아와서 사용하는 모습이다.\r\n(또한 Head태그를 사용하여(page router 기준) 메타데이터 역시 받아온 데이터 정보로 설정하여 SEO에 유리하게 했다.)\r\n\r\n이 두함수를 적절히 설정하고 페이지를 npm run build를 사용했을 때 모습을 보자.\r\n\u003cimg src=\"nextjs.png\" alt=\"nextjs\"/\u003e\r\n\r\n앞서 살펴본 상세 페이지인 [...detail]외와 /posts/[caregory], /posts/tag/[tag] 까지 각 페이지 별로 원하는 path와 데이터를 제공했더니 가능한 모든 조합을 빌드 시점에 불러와 페이지로 렌더링했다.\r\n(그래서 뒤지게 배포가 오래 걸린다)\r\n이렇게 페이지를 모조리 빌드해두고 배포하면 사용자는 이미 완성되어 있는 페이지를 받기만 하면 되므로 굉장히 빠르게 해당 페이지를 확인할 수 있다.\r\n\r\n## 마치며\r\n페이지의 다양한 렌더링 방식인 CSR, SSR에 대해서 그리고 더 나아가 SSG에 대해서도 살펴보았다. 뭐가 확실히 더 좋다라기 보다는 각 방식을 확실히 이해하고 상황에 따라 적절히 이를 활용하는 것이 중요할 듯 하다.\r\n"},{"slug":"posts/Algorithm/[PCCP 기출문제]퍼즐게임 챌린지","title":"[PCCP 기출문제] 퍼즐게임 챌린지","date":"2024-10-31T12:05:24.000Z","image":"index.jpg","summary":"프로그래머스 [PCCP 기출문제] level 2 퍼즐게임 챌린지 문제 풀이 입니다.","tags":["Algorithm","프로그래머스","PCCP","lv2","이분탐색"],"content":"# [PCCP 기출문제] 퍼즐게임 챌린지\r\n\r\n## 문제 요약\r\nhttps://school.programmers.co.kr/learn/courses/30/lessons/340212\r\n\r\n숙련도에 따라 퍼즐을 풀 때, \r\n- 각 퍼즐에서 난이도가 숙련도 보다 높다면 **난이도 - 숙련도 만큼 퍼즐이 틀리고, 틀린횟수 * (이전시간 + 현재시간)만큼의 시간이 걸린다.**\r\n- 각 퍼즐에서 난이도가 숙련도 보다 낮거나 같다면 **현재시간만** 투자하면 된다.\r\n\r\n이렇게 모든 퍼즐을 푼 시간의 합이 주어진 limit를 넘지 않도록 하는 숙련도(level)의 최솟값을 구하여야한다. \r\n\r\n(자세한 문제의 내용은 링크를 참고바랍니다.)\r\n\r\n## 문제 접근\r\n레벨의 최솟값을 구하여야 하기에, 처음에는 diffs 난이도 배열에서 최댓값부터 시작하여 1씩 줄어들도록 푸는 브루트포스를 생각했다.\r\n\r\n하지만, 제한사항이 1\u003c=diffs[i]\u003c=100000로 범위가 상당히 크고, diffs의 길이도 1 ≤ diffs의 길이 = times의 길이 = n ≤ 300,000로 제한사항이 주어졌기에\r\n\r\n브루트포스 기법은 무조건 시간초과가 날 것이므로 아닌 다른 방식을 생각해내야한다. \r\n\r\n결국 level의 값을 효율적이고 시간이 적게 들 수 있게 탐색해내야 하므로,  O(nlogn)의 시간 복잡도를 가지는 **이분탐색으로 level의 최솟값을 구하면 된다.**\r\n\r\n## 풀이\r\n최대 난이도 이상의 값을 탐색하는 것은 의미가 없으므로, \r\n난이도의 최댓값을 구하여,  max_diff로 놓은다음 이를 초기에 r로 설정한다.\r\nl은 난이도의 최솟값인 1로 두고,\r\n\r\n1~max_diff 범위 안에서 레벨의 이분탐색을 진행한다.\r\n\r\n현재 레벨을 변수 `level`로 둘 때,\r\n\r\n각  `level`에서 나올 수 있는 경우는 퍼즐을 푸는 시간의 합이 `limit`보다 **높을 때**와 **낮거나 같을 때**로 나눌 수 있다.\r\n- 시간의 합이 `limit`보다 높을 때: 현재 레벨이 낮기에 그런 것 이므로, 더 높은 레벨을 탐색하기 위해 \r\n`l = level+1` 로 둔다.\r\n\r\n- 시간의 합이 `limit` 보다 낮거나 같을 때: 현재 레벨이 충분히 높기에, 우리는 레벨의 최솟값을 찾아내야 하므로, \r\n`r = level-1`로 두고,  현재 레벨이 답이 될 수도 있기에 `answer = level` 도 추가해야 한다.\r\n\r\n이를 전체 코드로 구현하면 다음과 같다.\r\n\r\n## 전체 코드\r\n```js\r\n  def solution(diffs, times, limit):\r\n    max_diff = max(diffs)\r\n    l = 1\r\n    r = max_diff;\r\n    answer = max_diff;\r\n    while l\u003cr:\r\n        level = (l+r)//2;\r\n        time = times[0]\r\n        for i in range(1,len(diffs)):\r\n            w_count = diffs[i]-level;\r\n            if w_count \u003e 0:\r\n                time += w_count*(times[i-1] + times[i]) + times[i];\r\n            else:\r\n                time += times[i];\r\n        if time\u003elimit:\r\n            l = level+1;\r\n        else:\r\n            r = level;\r\n            answer = level;\r\n    return answer;\r\n  ```\r\n\r\n## 느낀 점\r\n한 동안 알고리즘 문제를 안풀었더니 뇌가 굳은게 아닌가 싶다. 그리고 문제 설명 자체가 길고 복잡하면 살짝 길을 잃는 습관이 있는데, 이번 문제에서도 이해해보면 그렇게 어렵지 않은 것 같음에도 불구하고 그런 습관이 나타난 것 같다. \r\n\r\n전에 백준에서 풀었던 이분탐색문제랑 거의 흡사했음에도 이분탐색을 빨리 떠올리지 못한게 아쉽다."},{"slug":"posts/React/React useState 훅과 클로저","title":"React useState 훅과 클로저","date":"2024-10-26T18:00:24.000Z","image":"index.png","summary":"클로저를 이용한 React useState 훅의 작동 원리를 이해해보자","tags":["react","JavaScript","deepdive","useState","hook","클로저"],"content":"# React useState 훅과 클로저\r\n\r\n클로저에 대해 개념은 알고 있었지만, 사실 면접 질문때나 쓰이는 것이고, 실제로 어떻게 쓰이는지에 대해서는 와닿지 못한 부분도 있었다. 그러던 도중 react deep dive를 공부하며, react 개발자가 아마도 가장 많이 사용하는 **useState**에 클로저가 쓰인다는 사실을 알았다! \r\n어떻게 쓰이는 지 함께 살펴보자.\r\n\r\n\r\n\r\n## 상태값을 어떻게 관리할까\r\n보통 useState의 기본 사용법은 다음과 같을 것이다\r\n```js\r\nimport { useState } from 'react'\r\n\r\nconst [state, setState] = useState\r\n```\r\n인수로 state의 초깃값을 넘겨주고, 만일 아무것도 안넘겨주면 초깃값은 undefined일 것이다.\r\n훅의 반환 값은 배열이고, 배열의 첫 번째 원소는 state 값 자체이며, 두 번째 원소는 setState 함수를 통해 해당 state 값을 변경할 수 있다.\r\n\r\n\r\n**리액트에서 렌더링은 함수 컴포넌트의 return을 실행한 다음, 실행 결과를 이전의 리액트 트리와 비교해 리렌더링이 필요한 부분만 업데이트해 이뤄진다.**\r\n그렇기 때문에 렌더링 방식이랑 메커니즘이 다른 **변수**를 통해서 상태값을 관리하는 것은 적절하지 못하다. (이전 글 react virtualDOM 참고)\r\n\r\n그렇다면 다음 코드를 살펴보자.\r\n\r\n```js\r\nimport React from 'react'\r\n\r\nconst Component = () =\u003e {\r\n  const [,triggerRender] = useState()\r\n  let state = 'hello'\r\n\r\n  function handleButtonClick() {\r\n    state = 'hi'\r\n    triggerRender()\r\n  }\r\n  return (\r\n    \u003c\u003e\r\n      \u003ch1\u003e{state}\u003c/h1\u003e\r\n      \u003cbutton onClick={handleButtonClick}\u003ehi\u003c/button\u003e\r\n    \u003c/\u003e\r\n  )\r\n}\r\n```\r\nuseState 반환값의 두 번째 원소를 실행해 리액트에 렌더링이 일어나게끔 변경했다. \r\n그럼에도 여전히 버튼 클릭시 state의 변경된 값이 렌더링되고 있지 않다. \r\n\r\n그 이유는 리액트의 렌더링은 **함수 컴포넌트에서 반환한 결과물인 return의 값을 비교해 실행되기 때문이다.** \r\n\r\n즉, 매번 렌더링이 발생할 때마다 함수는 새롭게 실행이 되고, 실행한 함수에서 state는 매번 hello로 초기화 되므로 아무리 state를 변경해도 hello로 초기화 되는 것이다. \r\n\r\n근데 렌더링이 될 때마다 초기화되는 변수(값)와는 달리, useState의 결과값은 어떻게 그 값을 유지할까?\r\n\r\n\r\n\r\n그럼 우리가 알고있는 useState는 대체 어떻게 구현이 되있는 것일지 한번 최대한 비슷하게 구현한 코드를 살펴보자.\r\n\r\n**먼저 useState의 결과 값이 유지되도록, state를 함수로 하여 state 값을 호출할 때마다 현재 state를 반환하게 해보자.**\r\n```js\r\nfunction useState(initialValue) {\r\n\tlet initialState = initialValue;\r\n\t\r\n\tfunction state() {\r\n\t\treturn initialState\r\n\t}\r\n\tfunction setState(newValue) {\r\n\t\tinitialState = newValue\r\n\t}\r\n\treturn [state, setState];\r\n}\r\nconst [value, setState] = useState(0);\r\nsetValue(1);\r\nconsole.log(value()); // 1\r\n```\r\n위의 코드도 나쁘진 않지만, 우리에게 익숙한 useState훅은 state를 함수가 아닌 상수처럼 사용하고 있다.\r\n어떻게 그게 가능한 걸까?\r\n\r\n## 클로저를 이용해 상태를 관리하는 useState\r\n이를 위해서 리액트는 **클로저**를 이용한 것이다. \r\nuseState는 클로저를 통해 useState 내부의 선언된 함수(setState)가 함수의 실행이 종료된 이후(useState가 호출된 이후)에도 지역변수인 state를 계속 참조할 수 있다.\r\n\r\nuseState 작동 방식을 대략적으로 흉내 낸 코드는 다음과 같다.\r\n\r\n```js\r\nconst MyReact = (function() {\r\n\tconst global = {}\r\n    let index = 0\r\n    \r\n    function useState(initialState){\r\n    \tif(!global.states) {\r\n    \t// 애플리케이션 전체의 states 배열 초기화, 최초 접근이면 빈 배열로\r\n        \tglobal.states = []\r\n        }\r\n        // states 정보를 조회해서, 현재 상태값이 있는지 확인\r\n        // 없다면 초깃값으로 설정\r\n        const currentState =  global.states[index] || initialState\r\n        // 위에서 조회한 값으로 states의 값 업데이트\r\n        global.states[index] = currentState\r\n        \r\n        // 즉시실행함수로 setter 만듬\r\n        const setState = (function() {\r\n        \t// 클로저로 index를 가둬두어서 동일한 index에 접근이 가능\r\n        \tlet currentIndex = index\r\n            return function(value){\r\n            \tglobal.states[currentIndex] = value\r\n                //컴포넌트 렌더링이 들어가는 부분이다.(실제 코드는 생략)\r\n            }\r\n    })()\r\n    // useState를 쓸 때마다 index를 하나씩 추가하는데, 이는 하나의 state마다\r\n    // index가 할당되어있어, 그 index가 배열의 값(global.states)를 가리키고,\r\n    // 필요할 때마다 그 값을 가져오게 하는 것이다.\r\n    index = index + 1\r\n        \r\n    return [currentState,setState]\r\n}\r\n\r\nfunction Component() {\r\n\tconst [value, setValue] = useState(0);\r\n}\r\n})();\r\n```\r\n\r\n실제 리액트 코드에서는 useReducer를 이용해 구현되어 있어 약간의 차이가 있다.\r\n\r\n아무튼 여기서 함수의 실행이 끝났음에도 함수가 선언된 환경을 기억할 수 있는 방법이 바로 클로저인 것이다. 만약 클로저가 없다면, `setState`는 항상 `index`의 현재 값에 의존하게 된다. 즉, 컴포넌트가 여러 상태를 갖고 있을 때 마지막 `index`만 참조하므로, `setState`가 올바른 위치를 참조하지 않게 되는 것이다.\r\n\r\n매번 실행되는 함수 컴포넌트 환경에서 state의 값을 유지하고 사용하기 위해 리액트는 클로저를 활용하고 있다.\r\n\r\n`\r\n훅에 대한 구현체를 github에서 타고 올라가다보면 __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED 라는 문구를 만나게된다(무섭다 ㅋㅋ)\r\n위의 코드는 Preact의 구현을 기준으로 하고 있다. Preact는 react의 경량화 버전으로,\r\n대부분의 리액트 API를 지원하고 있다. \r\n`\r\n## 결론\r\nReact의 `useState`는 클로저를 통해 상태값을 안정적으로 유지하며, 함수 컴포넌트가 여러 번 호출되더라도 **각 상태값이 고유한 위치에 저장**될 수 있게 한다. `useState`가 반환하는 `setState` 함수는 생성 당시의 상태 위치(`index`)를 클로저로 캡처하여, 해당 상태값만 정확히 업데이트하도록 구현되어 있다.\r\n\r\n정리하자면, 클로저는 `setState`가 함수가 선언된 당시의 환경을 유지하게 해주기 때문에 **컴포넌트가 매번 재실행될 때마다 상태가 초기화되는 것을 방지**하고, 상태가 올바르게 유지될 수 있게 해준다.\r\n\r\n**참고**\r\n\r\n[서적] 모던 리액트 Deep Dive\r\n"},{"slug":"posts/Javascript/클로저에 대하여","title":"클로저에 대하여","date":"2024-10-25T20:00:24.000Z","image":"index.png","summary":"자바스크립트의 어렵지만 중요한 클로저의 개념과 활용 이해해보자","tags":["JavaScript","deepdive","클로저","생명주기"],"content":"# 클로저에 대하여\r\n\r\n면접 질문 중 단골이고, 자바스크립트에 관심이 있다면 한번쯤 들어봤을 개념인 **클로저**.\r\n\r\n사실 많이 난해한 개념이기도 하고, 필자 역시 전에 한번 공부를 해보았지만 아직 확실히 와닿지는 않는 개념이다. \r\n\r\n그래서 이번 기회에 제대로 정리하고 넘어가고자 한다. 함께 이 개념이 대체 뭔지 살펴보자.\r\n\r\n## 클로저의 정의\r\n\u003e 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.\r\n\r\n'이게 뭔소리지?' 싶은가?  나도 그러하다. 위의 정의에서 이해하여야 할 핵심 키워드는 **함수가 선언된 렉시컬 환경**이다.\r\n\r\n ```js\r\n const x = 1;\r\n function outerFunc( ) {\r\n\t const x = 10;\r\n\t function innerFunc( ) {\r\n\t\t console.log(x); // 10\r\n\t}\r\n\tinnerFunc( );\r\n}\r\nouterFunc( );\r\n```\r\n`outerFunc` 내부에서 중첩 함수 `innerFunc`가 정의되고 호출되었다. \r\n\r\n따라서 중첩 함수 `innerFunc` 내부에서 자신을 포함하고 있는 `outerFunc`의 x 변수에 접근할 수 있다. **만약 innerFunc 함수가 outerFunc의 내부에서 정의되지 않았다면, 즉 외부에서 별도로 정의 되었다면** innerFunc를 outerFunc 내부에서 호출해도 outerFunc 함수의 변수에 접근이 불가능하다.\r\n\r\n ```js\r\n const x = 1;\r\n function outerFunc( ) {\r\n\t const x = 10;\r\n\t// 안에서 호출되었지만 접근 불가능\r\n\t innerFunc( );\r\n}\r\nfunction innerFunc( ) {\r\n\t// 상위 스코프인 전역에서 선언된 1\r\n\tconsole.log(x); // 1\r\n}\r\nouterFunc( );\r\n```\r\n\r\n위와 같은 현상은 자바스크립트가 **렉시컬 스코프**를 따르기에 발생한다.\r\n\r\n## 렉시컬 스코프\r\n자바스크립트 엔진은 함수를 **어디서 호출했느냐**가 아니라 함수를 **어디서 정의했는지**에 따라 **상위 스코프를 결정** 한다. \r\n\r\n이를 **렉시컬 스코프**라고 한다.\r\n\r\n위의 예제코드를 다시한번 본다면, outerFunc와 innerFunc는 모두 전역에서 정의 되었고, 함수의 상위 스코프는 함수를 어디서 정의했는지에 따라 결정되므로 **두 함수의 상위 스코프는 모두 전역이다.**\r\n\r\n함수의 상위 스코프는 결국, **함수의 정의된 위치에 따라 정적으로 결정**되고, 함수의 호출된 위치는 어떠한 영향도 주지 못한다.\r\n\r\n\u003e렉시컬환경:  **변수를 저장하고 외부 스코프와 연결을 유지하는 객체**라고 생각하면된다. 자바스크립트에서는 함수가 생성될 때마다 렉시컬 환경이 만들어지며, 함수 내부의 변수뿐 아니라 함수가 선언된 위치에 있는 외부 변수도 기억하게된다.\r\n\u003e\r\n\u003e 코드가 위치한 곳에 따라 **변수와 함수를 어디서 찾아볼지 알려주는 일종의 \"지도\"**라고 생각할 수도 있다\r\n\r\n\r\n렉시컬 환경은 자신의 **외부 렉시컬 환경에 대한 참조**를 통해 상위 렉시컬 환경과 연결이된다.\r\n\r\n따라서 함수의 상위 스코프를 결정한다는 것은, 현재 함수의 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정한다는 것을 의미한다.\r\n\r\n렉시컬 스코프를 다시한번 정의해보자면, 렉시컬 환경의 \"외부 렉시컬 환경에 대한 참조\"에 저장한 참조값, 즉 상위 스코프에 대한 참조는 **함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)**에 의해 결정되는 것이라고 할 수 있다. \r\n\r\n\r\n\r\n**함수는 자신의 내부슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.** \r\n이곳을 참조해서 자신이 호출되었을 때 생성될 함수 렉시컬환경의 \"외부 렉시컬 환경에 대한 참조\"에 저장될 참조값을 보고, 자신이 존재하는 한, 이 [[Environment]] 슬롯에 저장한 렉시컬 환경의 참조, 즉 **상위 스코프**를 기억한다.\r\n\r\n## 클로저와 렉시컬환경\r\n그렇다면 다음의 코드를 살펴보자\r\n```js\r\nconst x = 1 ;\r\nfunction outer() {\r\n\tconst x = 10;\r\n\tconst inner = function ( ) {console.log(x)}\r\n\t//inner함수 반환\r\n\treturn inner;\r\n}\r\n// outer함수를 호출하면 중첩 함수 inner를 반환한다.\r\n// 그리고 outer 함수의 실행 컨텍스트는 제거된다.\r\nconst innerFunc = outer( );\r\ninnerFunc( )// 10\r\n```\r\nouter함수를 호출하면 outer함수는 중첩함수 inner를 반환하고 생명주기를 마감한다. \r\n\r\n즉 outer함수의 실행이 종료되었으므로, 실행컨텍스트가 제거된다. (실행컨텍스트 스택에서 pop된다.)\r\n\r\n이때 outer 함수의 지역변수x 역시 생명주기를 마감했으므로, 실행 컨텍스트가 제거되어 유효하지 않아 보인다.\r\n\r\n그러나 위의 실행 결과는 outer 지역 변수x 의 값인 10을 반환한다. 이미 생명 주기가 종료되어 outer 함수의 지역변수 x가 실행 컨텍스트 스택에서 제거되었는데도 다시 부활이라도 한 것 마냥 말이다. \r\n\r\n이처럼 **외부 함수보다 중첩함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명주기가 종료한 외부함수의 변수를 참조**할 수 있다. \r\n\r\n이러한 **중첩 함수를 클로저**라고 부른다.\r\n\r\n다시 정의로 돌아가보자.\r\n\u003e 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.\r\n\r\n위 정의를 예제에 대입해보자면 `함수`는 반환된 `중첩함수(inner)`를 의미하고 `그 함수가 선언될 때의 렉시컬 환경(Lexical environment)`란 그 `중첩 함수(inner)가 정의됐을 때의 스코프`를 의미하는 것이다.\r\n\r\n즉, **클로저는 반환된 중첩 함수가 자신이 선언됐을 때의 렉시컬 환경 즉, 스코프를 기억하여 자신이 선언됐을 때의 렉시컬 환경 밖에서 호출되어도 그 렉시컬 환경(스코프)에 접근할 수 있는 함수**를 말한다. \r\n\r\n조금 더 간단히 말하면 **클로저는 자신이 생성될 때의 상위 스코프(렉시컬 환경)을 기억하는 함수이다**\r\n\r\n\u003cimg src = \"그림1.jpg\" width=\"800\" height=\"500\" /\u003e\r\n\r\n\r\ninner 함수의 [[Environment]] 슬롯이 outer 함수의 렉시컬 환경을 참조하고, inner가 전역 변수 innerFunc에 저장되어 계속 사용되고 있으므로, 이와 연결된 모든 요소는 가비지 컬렉터에 의해 제거되지 않습니다.\r\n\r\n\r\n\u003e **가비지 컬렉터(Garbage Collector)는 프로그램이 더 이상 사용하지 않는 메모리를 자동으로 해제해 주는 자바스크립트 엔진의 기능**이다.\r\n\u003e \r\n\u003e 가비지 컬렉터는 특정 메모리 공간이 더 이상 참조되지 않을 때 그 공간을 \"가비지\"로 판단하여 메모리를 해제한다.  반대로, **누군가가 참조하고 있는 메모리 공간은 함부로 해제하지 않는다**.\r\n\r\n클로저는 자바스크립트의 강력한 기능으로, 필요하다면 적극 활용해야 한다. 클로저가 유용하게 사용되는 상황을 살펴보자.\r\n\r\n## 클로저의 활용\r\n\r\n### 상태를 안전하게 변경하고 유지할 때\r\n\r\n클로저는 **상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고, 특정 함수에게만 상태 변경을 허용하여, 상태를 안전하게 변경하고 유지할 수 있도록 사용한다.**\r\n```js\r\nconst counter = (function ( ) {\r\n// 은닉된 상태 (외부에서 접근 불가)\r\nlet num = 0;\r\n// 클로저인 메서드를 갖는 객체를 반환한다.\r\n// 객체 리터럴은 스코프를 만들지 않는다.\r\n// 따라서 아래 메서드들의 상위 스코프는 즉시 실행 함수의 렉시컬 환경이다.\r\nreturn {\r\n\tincrease() {\r\n\t\treturn ++num;\r\n\t}\r\n\tdecrease() {\r\n\t\treturn num\u003e0? --num: 0;\r\n\t}\r\n}());\r\n\r\nconsole.log(counter.increase()); // 1\r\nconsole.log(counter.decrease()); // 2\r\n\r\nconsole.log(counter.decrease()); // 1\r\nconsole.log(counter.decrease()); // 0\r\n```\r\n즉시 실행 함수는 호출된 이후 소멸되지만, 즉시 실행 함수가 반환한 클로저(increase, decrease)는  **자신의 상위 스코프인 즉시 실행함수의  렉시컬 환경을 기억하고 있다**. \r\n\r\n이 코드에서 \r\n- 카운터 상태(num 변수의 값)은 increase, decrease 함수가 호출되기 전까지 변경되지않고 유지되며 **외부에서 접근할 수 없다**.\r\n- 카운터 상태는 오직 **increase, decrease로 정의된 함수로만 변경이 가능**하다.\r\n\r\n\r\n\r\n이처럼 클로저는 **상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용**된다.\r\n\r\n### 전역변수의 사용을 억제할 때\r\n\r\n클로저는 전역 변수 사용을 억제하고 대신 **함수 내부의 변수로 상태를 관리**할 수 있도록 도와준다. 이렇게 하면 전역 변수를 사용하지 않고도 데이터가 안전하게 유지되며, 다른 코드와 충돌하지 않는 이점을 얻을 수 있다.\r\n\r\n```js\r\nlet counter = 0; // 전역 변수\r\n\r\nfunction incrementCounter() {\r\n    counter += 1;\r\n    return counter;\r\n}\r\n\r\nconsole.log(incrementCounter()); // 1\r\nconsole.log(incrementCounter()); // 2\r\nconsole.log(counter); // 전역 변수에 접근 가능 (위험)\r\n```\r\n위 코드에서는 `counter`가 전역에 선언되어 있기 때문에 어디서든 접근 가능하여,  이러면 다른 코드에서 `counter`를 실수로 변경할 위험이 있다.\r\n```js\r\nfunction createCounter() {\r\n    let counter = 0; // 함수 내부 변수로 관리\r\n\r\n    return function() {\r\n        counter += 1;\r\n        return counter;\r\n    };\r\n}\r\n\r\nconst incrementCounter = createCounter();\r\n\r\nconsole.log(incrementCounter()); // 1\r\nconsole.log(incrementCounter()); // 2\r\nconsole.log(typeof counter); // 'undefined' - 전역에서 접근 불가\r\n```\r\n\r\n이 코드에서는 `counter` 변수가 **`createCounter` 함수 내부에만 존재**하므로 외부에서 직접 접근하거나 수정할 수 없다. \r\n\r\n대신, `incrementCounter` 함수는 **클로저를 통해 `counter`를 기억**하고 있으므로 호출할 때마다 `counter`를 안전하게 증가시킬 수 있다.\r\n\r\n이처럼, 클로저를 사용하면 함수 내 지역 변수를 통해 상태를 관리하게 되어 **전역 변수를 사용하지 않아도 안전하게 데이터 상태를 유지**할 수 있다.\r\n\r\n### React의 useState\r\n\r\n이런 이점을 활용하여 react의 useState에도 클로저가 활용된다.\r\n\r\n`useState`를 사용하면 컴포넌트 내에서 **상태를 관리**하게 되는데, 이 상태가 **컴포넌트가 렌더링될 때마다 유지**되도록, 또한 `setState` 함수로만 상태가 변경되도록 하는 데에 클로저가 활용되는 것이다.\r\n\r\n이와 관련하여서는 다음 포스팅에서 자세하게 다룰 예정이다.\r\n\r\n\r\n## 결론\r\n\r\n지금까지 자바스크립트의 어렵지만 주요한 개념인 클로저에 대해 살펴보았다.\r\n\r\n**클로저**는 **함수와 그 함수가 선언된 렉시컬 환경의 조합으로, 자바스크립트에서 함수는 자신이 정의된 위치에 따라 상위 스코프를 결정하는 렉시컬 스코프**를 따르므로, \r\n중첩 함수가 외부 함수의 스코프를 참조하여 외부함수가 생명주기가 끝났음에도 그 함수의 변수를 참조할 수 있는 함수를 의미한다."},{"slug":"posts/React/[React DeepDive] React의 가상 DOM","title":"[React DeepDive] React의 가상 DOM","date":"2024-09-25T12:00:24.000Z","image":"React.svg","summary":"리액트 딥다이브 책 내용 중 '가상 DOM과 파이버'의 정리 내용입니다.","tags":["react","deepdive","Virtual DOM"],"content":"# [React DeepDive] React의 가상 DOM\r\n\r\n\r\n리액트의 특징 중 하나는 실제 DOM이 아닌 가상 DOM을 운영한다는 것이다. 이번 글에서는 React DeepDive에서 다루는 **가상 DOM이 무엇인지**, **그리고 실제 DOM에 대해 어떤 이점이 있는지 살펴보고**, 가상 DOM을 다룰 때 **주의할 점**에 대해서도 다루려고 한다.\r\n\r\n## DOM과 브라우저 렌더링 과정\r\n\u003e **DOM**: 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.\r\n\r\n브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정은 다음과 같다.\r\n\r\n\u003cimg src=\"트리를 그리는과정.png\" alt=\"트리를 그리는 과정\" width=\"800\" height=\"600\"/\u003e\r\n\r\n\r\n1. 브라우저가 사용자 요청한 주소에서 HTML파일을 다운로드한다.\r\n\r\n2. 브라우저의 렌더링 엔진이 HTML을 파싱해 DOM노드로 구성된 트리 즉, `DOM`을 만든다.\r\n3. 2번 과정에서 CSS파일을 만나면 해당 CSS 파일도 다운로드한다.\r\n4. 브라우저의 렌더링 엔진이 이 CSS역시 파싱해 CSS 노드로 구성된 트리 즉, `CSSOM`을 만든다\r\n5. 브라우저는 DOM 노드를 순회하는데 모든 노드가 아닌, **사용자 눈에 보이는 노드만**(display:none과 같은 노드는 방문 x) 방문한다.\r\n6. 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. \r\n\u003e\t-  `레이아웃`: 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정이며, 이 과정을 거치면 **페인팅 과정도 거치게 된다.**\r\n\u003e-  `페인팅`: 레이아웃 단계를 거친 노드의 색과 같은 **실제 유효한 모습을 그리는 과정**\r\n\r\n## 가상 DOM의 탄생 배경\r\n\r\n### 웹페이지를 추가로 렌더링 하는데 드는 비용\r\n앞에서 살펴본 브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다. \r\n\r\n또한 정보를 보여주는데 그치지 않고 사용자의 인터렉션을 통해 다양한 정보를 노출해야 하기에, 렌더링이 완료된 이후에도 **사용자의 인터렉션으로 웹페이지가 변경되는 상황** 또한 고려해야 한다.\r\n\r\n이 과정에서 예를 들어,\r\n- 특정 요소의 색상이 변경되는 경우: 페인팅만이 일어나서 빠른처리가 가능하다.\r\n\r\n- **특정 요소의 노출 여부나 사이즈가 변경되는 경우**: 레이아웃이 일어나고, 레이아웃은 **필연적으로 리페인팅을 발생**하기 때문에 더 많은 비용이 든다.\r\n\r\n- DOM 변경이 일어나는 요소가 **자식 요소를 많이 가지고 있는 경우**: 하위 자식 요소 역시 변경되야 해서 더 많은 비용 지불\r\n\r\n이러한 추가 렌더링 작업은 하나의 페이지에서 모든 작업이 일어나는 `싱글 페이지 애플리케이션(SPA)`에서 더 많아진다. \r\n\r\n페이지가 변경될 때 처음부터 HTML을 새로 받아서 다시금 렌더링 과정을 시작하는 일반적인 웹페이지와는 다르게, 하나의 페이지에서 계속해서 요소의 위치를 재계산하게 된다.\r\n\r\n그러므로 라우팅이 변경되는 경우 고정된 헤더와 같은 요소들을 제외하고 대부분의 요소를 삭제, 삽입 및 요소의 위치를 다시 계산해야 하므로, DOM을 관리하는 과정에서 부담하는 비용이 커진다.\r\n\r\n### 가상 DOM의 탄생\r\n사용자의 인터렉션에 따라 DOM의 모든 변경 사항을 추적하는 것은 개발자에게는 너무나 수고스러운 일이다.  그렇기에 모든 DOM의 변경보다 **결과적으로 만들어지는 DOM 결과물 하나만 아는 것**이 개발자의 입장에서 더 유용할 것이다.\r\n\r\n이것을 해결하기 위해 탄생한 것이 바로 `가상 DOM`이다.  \r\n가상 DOM은 실제 브라우저가 아닌 리액트가 관리하는 가상의 DOM을 의미한다.\r\n\r\n가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 **메모리에 저장**하고, 리액트가 실제 변경에 대한 준비가 완료되었을 때, 실제 브라우저의 DOM에 반영한다.\r\n\r\n이렇게 DOM 계산을 메모리에서 계산하는 과정을 한 번 거치게 된다면 실제로는 여러 번 발생했을 렌더링 과정을 최소화하여 부담을 덜 수 있다.\r\n\r\n\u003e 가상 DOM은 **일반적인 브라우저보다 무조건 항상 빠르지는 않다**. \r\n\u003e\r\n\u003e 무조건 빠른 것이 아닌, 대부분의 상황에서 웬만한 애플리케이션을 만들 정도로 충분히 빠르다고 보는 것이 옳다.\r\n\r\n## 가상 DOM을 위한 아키텍처, 리액트 파이버\r\n가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 `리액트 파이버`이다.\r\n\r\n`리액트 파이버`는 리액트에서 관리하는 평범한 자바스크립트 객체이다. \r\n`파이버`는 `파이버 재조정자(fiber reconciler)`가 관리하는데, 가상 DOM과 실제 DOM을 비교하여 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.\r\n\r\n\u003e 재조정(reconcilation): 리액트에서 어떤 부분을 새로 렌더링 해야하는지 가상 DOM과 실제 DOM을 비교하는 과정 \r\n\r\n파이버는 애니메이션,레이아웃,사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하며, 다음과 같은 일을 할 수 있다.\r\n-  작업을 작은 단위로 쪼개고  **우선순위를  매긴다.**\r\n\r\n-  이 작업들은 일시 정지 및 다시 시작이 가능하다.\r\n\r\n- 이전 작업을 재사용 하거나 필요 없는 경우에는 폐기할 수 있다.\r\n\r\n이러한 모든 과정은 **비동기로 일어난다**. 과거에는 이러한 조정 알고리즘이 동기적인 스택 알고리즘으로 이뤄져 있었고, 동기적으로 작업이 이뤄졌기에 자바스크립트의 싱글 스레드의 특징 상 수행 중인 작업은 중단될 수 없었다. \r\n이러한 문제 때문에 리액트 팀은 스택 조정자 대신 파이버라는 개념을 탄생시킨다.\r\n\r\n### 파이버는 어떻게 구현되어 있을까?\r\n`파이버`는 일단 하나의 작업 단위로 구성되어 있다. 리액트는 작업 단위를 하나씩 처리하고, **finishWork( )** 라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다. \r\n이러한 단계는 두 단계로 나뉘는데,\r\n- `렌더 단계`: 사용자에게 노출되지 않는 모든 **비동기** 작업을 수행하고, **우선 순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.**\r\n- `커밋 단계`: DOM에 실제 변경 사항을 반영하기 위한 작업, commitWork( )가 실행되는데, **동기식**으로 일어나고 중단될 수 없다.\r\n\r\n파이버는 실제 리액트 코드에서 이렇게 구현되어 있다.\r\n```js\r\nfunction FiberNode(tag, pendingProps, key, mode) {\r\n  // Instance\r\n  this.tag = tag;\r\n  this.key = key;\r\n  this.elementType = null;\r\n  this.type = null;\r\n  this.stateNode = null;\r\n\r\n  // Fiber\r\n  this.return = null;\r\n  this.child = null;\r\n  this.sibling = null;\r\n  this.index = 0;\r\n\r\n  this.ref = null;\r\n\r\n  this.pendingProps = pendingProps;\r\n  this.memoizedProps = null;\r\n  this.updateQueue = null;\r\n  this.memoizedState = null;\r\n  this.dependencies = null;\r\n\r\n  this.mode = mode;\r\n\r\n  // Effects\r\n  this.effectTag = NoEffect;\r\n  this.nextEffect = null;\r\n\r\n  this.firstEffect = null;\r\n  this.lastEffect = null;\r\n\r\n  this.expirationTime = NoWork;\r\n  this.childExpirationTime = NoWork;\r\n\r\n  this.alternate = null;\r\n}\r\n```\r\n위와 같이 파이버는 단순한 자바스크립트 객체로 구성되어 있다. \r\n파이버와 리액트 요소의 한가지 중요한 차이점은 `리액트 요소`는 렌더링이 발생할 때 마다 새롭게 생성되지만, `파이버`는 컴포넌트가 최초로 마운트 되는 시점에 생성되어 **가급적이면 재사용된다**는 것이다.\r\n\r\n```js\r\nfunction createFiber(tag, pendingProps, key, mode) {\r\n  return new FiberNode(tag, pendingProps, key, mode);\r\n}\r\n```\r\n```js\r\nfunction createFiberFromElement(element, mode, expirationTime) {\r\n  let owner = null;\r\n  const type = element.type;\r\n  const key = element.key;\r\n  const pendingProps = element.props;\r\n  const fiber = createFiberFromTypeAndProps(\r\n    type,\r\n    key,\r\n    pendingProps,\r\n    owner,\r\n    mode,\r\n    expirationTime,\r\n  );\r\n\r\n  return fiber;\r\n}\r\n```\r\n이제 여기서 선언된 주요 속성을 살펴보면서 어떤 내용을 담고 있는지 살펴보자.\r\n\r\n-   `tag`  : 파이버는 하나의 element에 하나의 파이버가 생성되어 1:1 관계를 가진다. 여기서 **1:1로 매칭된 정보를 가지고 있는 것**이 tag필드이다. 연결되는 것은 컴포넌트, DOM노드 등이 될 수 있는데, 될 수 있는 것들은 다음과 같다.\r\n-  `stateNode`: 이 속성은 파이버 자체에 대한 참조 정보를 가지고 있다.\r\n-  `child`,  `sibling`,  `return`  : 파이버 간의 관계 개념을 나타내는 속성이다. 파이버는 트리 형식을 구성하는데 이 트리 형식을 구성하는데 필요한 정보가 이 속성 내부에 적용된다. 한 가지 리액트 컴포넌트 트리와 다른 점은 children이 없다는 것 즉 **단 하나**의 `child`만이 존재한다는 것이다.\r\n\r\n\t여러 개의 자식이 존재할 경우 항상 **첫 번째 자식의 참조**로 구성되며, 나머지는 자식들은 동등한 `sibling`으로 구성, `return`은 부모 파이버를 의미한다.\r\n\r\n-  `index` : 여러 형제들 사이에서 자신의 위치를 나타낸다.\r\n- `pedingProps`  : 아직 처리하지 못한 props\r\n-   `memoizedProps`  : pendingProps를 기준으로 렌더링이 완료된 이후에 pendingProps를 memoizedProps에 저장하여 관리한다.\r\n-  `updateQueue`  : 상태 업데이트, 콜백 함수, DOM 업데이트 등 작업을 담아두는 Queue.\r\n- `memoizedState`  : 함수 컴포넌트의 훅 목록이 저장된다.\r\n-  `alternate`: 뒤이어 설명할 리액트 파이버 트리와 이어질 개념. 리액트의 트리는 두 개인데, alternate는 반대 트리의 파이버를 가리킨다.\r\n\r\n이렇게 생성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다. \r\n이러한 작업들은 작은 단위로 나눠서 처리할 수도, 애니메이션과 같이 우선순위가 높은 작업은 빨리 처리하거나, 낮은 작업을 연기시키는 등 좀 더 유연하게 처리된다.\r\n\r\n\r\n리액트 개발 팀은 사실 리액트는 가상 DOM이 아닌 Value UI, 즉 값을 가지고 있는 UI를 관리하는 라이브러리라는 내용을 피력한 바가 있다. \r\n\r\n즉, 리액트의 핵심원칙은 **UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것**이다. \r\n변수에 이러한 UI관련 값을 보관하고, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고, 표현하는 것이 바로 리액트다.\r\n\r\n### 파이버 트리\r\n파이버 트리는 하나는 **현재 모습을 담은** 파이버 트리, 다른 하나는 작업 중인 상태를 나타내는 **workInProgress** 트리다. 작업이 끝나면, 리액트는 **단순히 포인터만 변경**해 workInProgress 트리를 **현재 트리**로 바꿔버린다. 이러한 기술을 **더블 버퍼링**이라고 한다.\r\n\u003cimg src=\"파이버 트리.png\" alt=\"트리를 그리는 과정\" width=\"800\" height=\"600\"/\u003e\r\n\r\n리액트에서는 미처 다 그리지 못한 모습을 노출시키지 않기 위해 (불완전한 트리를 보여주지 않기 위해) 더블 버퍼링 기법을 쓰는데, 이러한 더블 버퍼링을 위해 트리가 두 개 존재하며, 이 더블 버퍼링은 커밋 단계에서 수행된다.\r\n\r\n- 먼저 현재 UI 렌더링을 위해 존재 하는 **current**를 기준으로 모든 작업이 시작된다.\r\n- 업데이트가 발생하면 파이버는 리액트에서 새로 받은 데이터로 새로운 **workInProgress** 트리를 빌드하기 시작한다.\r\n- 빌드하는 작업이 끝나면 다음 렌더링에 이 트리를 사용한다.\r\n- 빌드된 workInProgress 트리가 UI에 최종적으로 렌더링되어 반영이 완료되면 **current가 이 workProgress로 변경된다**.\r\n\r\n### 파이버의 작업 순서\r\n일반적인 파이버 노드의 생성흐름은 다음과 같다.\r\n1. 리액트는 `beginWork()` 함수를 실행해 파이버 작업을 수행하고, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.\r\n2. 1번의 작업이 끝나면 `completeWork( )` 함수를 실행해 파이버 작업을 완료한다.\r\n3. 형제가 있다면 형제로 넘어간다.\r\n4. 2,3번이 끝난다면 `return`으로 돌아가 자신의 작업이 완료되었음을 알린다.\r\n\r\n이러한 작업으로 트리가 생성이 되었는데, setState 등으로 업데이트가 발생하면 어떻게 될까? 이미 앞서 만든 current트리가 존재하고, setState로 업데이트 요청을 받아 workInProgress트리를 다시 빌드하기 시작한다. \r\n\r\n최초 렌더링 시에는 모든 파이버를 새로 만들어야 했지만 이제는 파이버가 이미 존재하므로 되도록 새로 생성하지 않고, **기존 파이버에서 업데이트 된 props를 받아 파이버 내부에서 처리한다**.\r\n\r\n이처럼, 재조정 작업 때마다 새롭게 파이버 자바스크립트 객체를 만드는 것 이 아닌, 기존의 객체를 재활용하기 위해 내부 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트한다.\r\n\r\n과거에는 이 작업을 동기식으로 처리했고, 트리 업데이트 과정 및 새로운 트리를 만드는 작업은 동기식이고 중단될 수 없다. 그러나 현재는 우선순위가 높은 다른 업데이트가 오면 현재 업데이트 작업을 일시 중단하거나 새로 만들거나 폐기할 수 있으며 작업 단위를 파이버 단위로 나누어 우선순위를 할당하는 것 역시 가능하다.\r\n\r\n### 파이버와 가상 DOM\r\n리액트 컴포넌트에 대한 정보를 **1:1로 가지고 있는 것**이 파이버이며, 이 파이버는 리액트 아키텍처 내부에서 **비동기**로 이뤄진다. 이와 달리 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 이뤄져야 하기에, 메모리 상에서 이 작업을 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.\r\n\r\n\u003e 사실 가상 DOM은 오직 웹 어플리케이션에서만 통용되는 개념이고, 리액트 파이버는 리액트 네이티브와 같은 브라우저가 아닌 환경에서도 사용할 수 있기에 엄밀히 하면 파이버와 가상 DOM은 동일한 개념이 아니다. \r\n\r\n### 정리\r\n결국 가상 DOM과 리액트의 핵심은 **브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아니라 바로 값으로 UI를 표현하는 것**이다. \r\n\r\n화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고 이러한 흐름을 효율적으로 관리하기 위한 메커니즘이 바로 리액트의 핵심이다."},{"slug":"posts/Algorithm/[백준 gold 5] 빌런 호석","title":"[백준 gold 5] 빌런 호석","date":"2024-08-09T17:05:24.000Z","image":"index.png","summary":"dfs을 활용한 프로그래머스 [level 3] 징검다리 건너기 문제 풀이 입니다.","tags":["Algorithm","백준","gold","dfs"],"content":"# [gold 3] 빌런 호석\r\n\r\n## 문제 설명\r\n\r\n치르보기 빌딩은 11층부터 NN층까지 이용이 가능한 엘리베이터가 있다. 엘리베이터의 층수를 보여주는 디스플레이에는 KK  자리의 수가 보인다. 수는 00으로 시작할 수도 있다. 00부터 99까지의 각 숫자가 디스플레이에 보이는 방식은 아래와 같다. 각 숫자는 7개의 표시등 중의 일부에 불이 들어오면서 표현된다.\r\n\r\n![](1.png)\r\n\r\n예를 들어 K=4K=4인 경우에 16801680층과 501501층은 아래와 같이 보인다.\r\n\r\n![](2.png)\r\n\r\n\r\n\r\n빌런 호석은 치르보기 빌딩의 엘리베이터 디스플레이의 LED 중에서 최소 11개, 최대 PP개를 반전시킬 계획을 세우고 있다. 반전이란 켜진 부분은 끄고, 꺼진 부분은 켜는 것을 의미한다. 예를 들어 숫자 11을 22로 바꾸려면 총 5개의 LED를 반전시켜야 한다. 또한 반전 이후에 디스플레이에 올바른 수가 보여지면서 11  이상 NN  이하가 되도록 바꿔서 사람들을 헷갈리게 할 예정이다. 치르보기를 사랑하는 모임의 회원인 당신은 호석 빌런의 행동을 미리 파악해서 혼쭐을 내주고자 한다. 현재 엘리베이터가 실제로는 XX층에 멈춰있을 때, 호석이가 반전시킬 LED를 고를 수 있는 경우의 수를 계산해보자.\r\n\r\n### 입력\r\n\r\n N,K,P,XN,K,P,X  가 공백으로 구분되어 첫째 줄에 주어진다.\r\n\r\n### 출력\r\n\r\n호석 빌런이 엘리베이터 LED를 올바르게 반전시킬 수 있는 경우의 수를 계산해보자.\r\n\r\n## 접근 방법\r\n\r\n숫자에 따른 LED를 먼저 구현하기 위해, \r\n\r\n그림과 같이, 각 LED의 위치에 번호를 매겨, 배열안에 그 번호가 있으면 불이 켜져있는 것으로, 없다면 불이 꺼져 있는 것으로 표현하였다.\r\n\u003cimg src=\"3.png\" alt=\"이미지 설명\" width=\"200\" height=\"300\" /\u003e\r\n\r\n\r\n그림처럼 0을 표현하면 3번자리를 제외한 모든 번호가 켜져있으므로, `[0,1,2,4,5,6]`으로 표현 할 수 있다.\r\n\r\n각 번호를 이와 같이 바꾸어 numbers 배열에 저장하면, 이와 같다.\r\n```python\r\nnumbers  = [[0,1,2,4,5,6],[2,5],[0,2,3,4,6],[0,2,3,5,6],[1,2,3,5],[0,1,3,5,6],[0,1,3,4,5,6],[0,2,5],[0,1,2,3,4,5,6],[0,1,2,3,5,6]];\r\n```\r\n이후 만일 현재 번호와 비교할 번호의 LED를 비교하기 위해 서로의 차집합을 더해서 두 번호가 서로를 비교했을 때, 가지고 있는 혹은 없는 번호의 개수를 구한다.\r\n```python\r\ncur_count  =  len(list(cur.difference(compare))) +  len(list(compare.difference(cur)));\r\n```\r\n이와 같은 방식으로 반전시킬 LED의 개수를 구하고, dfs를 활용하여 x의 모든 자릿수를 순회하여 p보다 작거나 같게 LED를 반전하면서, n보다 번호가 작거나 같다면 result를 1 증가 시킨다.\r\n\r\n전체코드는 다음과 같다.\r\n```python\r\nimport sys;\r\ninput = sys.stdin.readline;\r\n\r\nn,k,p,x = map(int, input().split());\r\nresult = 0;\r\nnumbers = [[0,1,2,4,5,6],[2,5],[0,2,3,4,6],[0,2,3,5,6],[1,2,3,5],[0,1,3,5,6],[0,1,3,4,5,6],[0,2,5],[0,1,2,3,4,5,6],[0,1,2,3,5,6]];\r\n\r\nx = list(str(x));\r\nif len(x) != k:\r\n\t# k 보다 자릿수 x가 자릿수가 작다면 작은 만큼 앞에 0을 채워주어야 한다.\r\n    for _ in range(k-len(x)):\r\n        x.insert(0,'0');\r\n        \r\ndef dfs(index,count,st):\r\n    global result;\r\n    if count\u003ep:\r\n        return;\r\n    if index == k:\r\n        if 0\u003ccount\u003c=p and 0\u003cint(st)\u003c=n:\r\n            result += 1;\r\n        return;\r\n    cur = set(numbers[int(x[index])]);\r\n    for i in range(len(numbers)):\r\n        compare = set(numbers[i]);\r\n        cur_count = len(list(cur.difference(compare))) + len(list(compare.difference(cur)));\r\n        if count + cur_count \u003c=p:\r\n            dfs(index+1,count + cur_count,st + str(i));\r\ndfs(0,0,'');\r\nprint(result);\r\n```\r\n\r\n## 느낀 점\r\n사실 이 문제와 관련하여 다른 풀이도 많이 찾아보았고, 더욱 시간이 적게 걸리는 풀이도 많았어서 시간 초과는 나지 않았지만 다소 비효율적인 풀이였다는 생각이 들었다.\r\n\r\n또한 제한 사항중 `또한 반전 이후에 디스플레이에 올바른 수가 보여지면서 1 이상 N 이하가 되도록 바꿔서 사람들을 헷갈리게 할 예정이다.`를 못봐서 계속 `0\u003c=int(st)\u003c=n`로 조건을 설정해놓고 헤맸었다.  문제의 조건을 유심히 보는 습관을 들여야 함을 다시한번 느낀다."},{"slug":"posts/Algorithm/[프로그래머스lv3]아이템 줍기","title":"[프로그래머스 level 3] 아이템 줍기","date":"2024-07-12T16:34:24.000Z","image":"index.png","summary":"bfs를 활용한 프로그래머스 [level 3] 아이템 줍기 문제 풀이 입니다.","tags":["Algorithm","프로그래머스","lv3","bfs"],"content":"# [level 3] 아이템 줍기 (BFS/DFS)\r\n## 문제 설명\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85)\r\n\r\n다음과 같은 다각형 모양 지형에서 캐릭터가 아이템을 줍기 위해 이동하려 합니다.\r\n\r\n![1.png](1.png)\r\n\r\n지형은 각 변이 x축, y축과 평행한 직사각형이 겹쳐진 형태로 표현하며, 캐릭터는 이 다각형의 둘레(굵은 선)를 따라서 이동합니다.\r\n\r\n만약 직사각형을 겹친 후 다음과 같이 중앙에 빈 공간이 생기는 경우, 다각형의 가장 바깥쪽 테두리가 캐릭터의 이동 경로가 됩니다.\r\n\r\n![2.png](2.png)\r\n\r\n단, 서로 다른 두 직사각형의 x축 좌표 또는 y축 좌표가 같은 경우는 없습니다.\r\n\r\n![rect_3.png](3.png)\r\n\r\n즉, 위 그림처럼 서로 다른 두 직사각형이 꼭짓점에서 만나거나, 변이 겹치는 경우 등은 없습니다.\r\n\r\n다음 그림과 같이 지형이 2개 이상으로 분리된 경우도 없습니다.\r\n\r\n![rect_4.png](4.png)\r\n\r\n한 직사각형이 다른 직사각형 안에 완전히 포함되는 경우 또한 없습니다.\r\n\r\n![rect_5.png](5.png)\r\n\r\n지형을 나타내는 직사각형이 담긴 2차원 배열 rectangle, 초기 캐릭터의 위치 characterX, characterY, 아이템의 위치 itemX, itemY가 solution 함수의 매개변수로 주어질 때, 캐릭터가 아이템을 줍기 위해 이동해야 하는 가장 짧은 거리를 return 하도록 solution 함수를 완성해주세요.\r\n\r\n##### 제한사항\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EC%A0%9C%ED%95%9C%EC%82%AC%ED%95%AD)\r\n\r\n-   rectangle의 세로(행) 길이는 1 이상 4 이하입니다.\r\n-   rectangle의 원소는 각 직사각형의 [좌측 하단 x, 좌측 하단 y, 우측 상단 x, 우측 상단 y] 좌표 형태입니다.\r\n    -   직사각형을 나타내는 모든 좌표값은 1 이상 50 이하인 자연수입니다.\r\n    -   서로 다른 두 직사각형의 x축 좌표, 혹은 y축 좌표가 같은 경우는 없습니다.\r\n    -   문제에 주어진 조건에 맞는 직사각형만 입력으로 주어집니다.\r\n-   charcterX, charcterY는 1 이상 50 이하인 자연수입니다.\r\n    -   지형을 나타내는 다각형 테두리 위의 한 점이 주어집니다.\r\n-   itemX, itemY는 1 이상 50 이하인 자연수입니다.\r\n    -   지형을 나타내는 다각형 테두리 위의 한 점이 주어집니다.\r\n-   캐릭터와 아이템의 처음 위치가 같은 경우는 없습니다.\r\n\r\n----------\r\n\r\n-   전체 배점의 50%는 직사각형이 1개인 경우입니다.  \r\n    \r\n-   전체 배점의 25%는 직사각형이 2개인 경우입니다.  \r\n    \r\n-   전체 배점의 25%는 직사각형이 3개 또는 4개인 경우입니다.  \r\n    \r\n\r\n----------\r\n\r\n##### 입출력 예\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%98%88)\r\n\r\n\r\n\u003ctable class=\"table\"\u003e\r\n        \u003cthead\u003e\u003ctr\u003e\r\n\u003cth\u003erectangle\u003c/th\u003e\r\n\u003cth\u003echaracterX\u003c/th\u003e\r\n\u003cth\u003echaracterY\u003c/th\u003e\r\n\u003cth\u003eitemX\u003c/th\u003e\r\n\u003cth\u003eitemY\u003c/th\u003e\r\n\u003cth\u003eresult\u003c/th\u003e\r\n\u003c/tr\u003e\r\n\u003c/thead\u003e\r\n        \u003ctbody\u003e\u003ctr\u003e\r\n\u003ctd\u003e[[1,1,7,4],[3,2,5,5],[4,3,6,9],[2,6,8,8]]\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e8\u003c/td\u003e\r\n\u003ctd\u003e17\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[1,1,8,4],[2,2,4,9],[3,6,9,8],[6,3,7,7]]\u003c/td\u003e\r\n\u003ctd\u003e9\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e6\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e11\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[1,1,5,7]]\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e4\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e9\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[2,1,7,5],[6,4,10,10]]\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e7\u003c/td\u003e\r\n\u003ctd\u003e10\u003c/td\u003e\r\n\u003ctd\u003e15\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003ctr\u003e\r\n\u003ctd\u003e[[2,2,5,5],[1,3,6,4],[3,1,4,6]]\u003c/td\u003e\r\n\u003ctd\u003e1\u003c/td\u003e\r\n\u003ctd\u003e4\u003c/td\u003e\r\n\u003ctd\u003e6\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003ctd\u003e10\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003c/tbody\u003e\r\n      \u003c/table\u003e\r\n\r\n##### 입출력 예 설명\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/87694.%E2%80%85%EC%95%84%EC%9D%B4%ED%85%9C%E2%80%85%EC%A4%8D%EA%B8%B0/README.md#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%98%88-%EC%84%A4%EB%AA%85)\r\n\r\n입출력 예 #1\r\n\r\n![rect_5.png](6.png)\r\n\r\n캐릭터 위치는 (1, 3)이며, 아이템 위치는 (7, 8)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다.\r\n\r\n입출력 예 #2\r\n\r\n![rect_7.png](7.png)\r\n\r\n캐릭터 위치는 (9, 7)이며, 아이템 위치는 (6, 1)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다.\r\n\r\n입출력 예 #3\r\n\r\n[![rect_8.png](8.png)]\r\n\r\n캐릭터 위치는 (1, 1)이며, 아이템 위치는 (4, 7)입니다. 위 그림과 같이 굵은 선을 따라 이동하는 경로가 가장 짧습니다.\r\n\r\n## 구현 방법\r\n### 전체 직사각형들을 합친 것의 바깥쪽 테두리만 돌게하려면 어떻게 하는가?\r\n- rectangle을 순회하면서 범위 중 직사각형 내부는 0으로 테두리는 1로 board값을 갱신한다.\r\n- 이 때, 만일 `다른 직사각형의 내부안에 현재 직사각형의 테두리가 있지 않을 경우`에만 board를 1로 갱신한다. \r\n### 예외 사항\r\n![exception.png](exception.png)\r\n좌표가 인접한 경우 위와 같이 의도하지 않은 경우를 초래할 수도 있다.\r\n\r\n따라서 이를 해결하기 위해 모든 좌표의 값을 **2배**씩 해주어야 한다.\r\n\r\n이를 모두 반영하여 board 테이블을 만들면,\r\n\r\n```python\r\nboard = [[-1 for _ in range(102)] for _ in range(102)];\r\nfor r in rectangle:\r\n\t# map 객체를 통해 모든 좌표값에 2배\r\n\tx1,y1,x2,y2 = map(lambda x: x*2,r);\r\n     for i in range(x1,x2+1):\r\n        for j in range(y1,y2+1):\r\n\t        # 직사각형 내부의 경우 0으로 개신\r\n            if x1\u003ci\u003cx2 and y1\u003cj\u003cy2:\r\n               board[i][j] = 0;\r\n            # 현재 직사각형의 내부가 아니면서 다른 직사각형의 내부 역시 아닐 때\r\n            elif board[i][j] != 0:\r\n               board[i][j] = 1;\r\n```\r\n이제 여기서 `bfs`를 이용하여 캐릭터 위치에서 아이템 위치까지의 최단거리를 구하면 된다.\r\n\r\n## 전체 코드\r\n```python\r\nfrom collections import deque\r\n\r\ndef solution(rectangle, characterX, characterY, itemX, itemY):\r\n\tboard = [[-1 for _ in range(102)] for _ in range(102)];\r\n\tfor r in rectangle:\r\n\t\t# map 객체를 통해 모든 좌표값에 2배\r\n\t\tx1,y1,x2,y2 = map(lambda x: x*2,r);\r\n\t     for i in range(x1,x2+1):\r\n\t        for j in range(y1,y2+1):\r\n\t\t        # 직사각형 내부의 경우 0으로 개신\r\n\t            if x1\u003ci\u003cx2 and y1\u003cj\u003cy2:\r\n\t               board[i][j] = 0;\r\n\t            # 현재 직사각형의 내부가 아니면서 다른 직사각형의 내부 역시 아닐 때\r\n\t            elif board[i][j] != 0:\r\n\t               board[i][j] = 1;\r\n    dir = [(1,0),(0,1),(-1,0),(0,-1)];\r\n\tvisited = [[0 for _ in range(102)] for _ in range(102)];\r\n    queue = deque();\r\n    queue.append((characterX*2,characterY*2));\r\n    visited[characterX*2][characterY*2] = 1;\r\n    while queue:\r\n        x,y = queue.popleft();\r\n        for dx,dy in dir:\r\n            nx,ny = x+dx,y+dy;\r\n            if 0\u003c=nx\u003c102 and 0\u003c=ny\u003c102:\r\n\t            # 직사각형의 테두리이면서 아직 방문하지 않았을 때\r\n                if board[nx][ny] == 1 and visited[nx][ny] == 0:\r\n                    queue.append((nx,ny));\r\n                    # 거리 갱신\r\n                    visited[nx][ny] = visited[x][y] + 1;\r\n    return visited[itemX*2][itemY*2]//2 \r\n```\r\n\r\n## 느낀 점\r\n직사각형의 내부와 테두리를 갱신하는 방법은 어떻게 떠올렸지만, 예외 상항과 그에 대한 해결 방법은 떠올리지는 못했다. 예외 처리에 관한 관점을 조금 더 넓혀나갈 수 있던 문제였다."},{"slug":"posts/Algorithm/[프로그래머스lv3]징검다리건너기","title":"[프로그래머스 level 3] 징검다리 건너기","date":"2024-07-08T18:33:24.000Z","image":"index.png","summary":"이분탐색을 활용한 프로그래머스 [level 3] 징검다리 건너기 문제 풀이 입니다.","tags":["Algorithm","프로그래머스","lv3","이분탐색"],"content":"# [level 3] 징검다리 건너기 - 64062\r\n\r\n## 문제 설명\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/64062.%E2%80%85%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%E2%80%85%EA%B1%B4%EB%84%88%EA%B8%B0/README.md#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85)\r\n\r\n**[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]**\r\n\r\n카카오 초등학교의 \"니니즈 친구들\"이 \"라이언\" 선생님과 함께 가을 소풍을 가는 중에  **징검다리**가 있는 개울을 만나서 건너편으로 건너려고 합니다. \"라이언\" 선생님은 \"니니즈 친구들\"이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.\r\n\r\n-   징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.\r\n-   디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.\r\n-   단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.\r\n\r\n\"니니즈 친구들\"은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.  \r\n\"니니즈 친구들\"은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.\r\n\r\n디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.\r\n\r\n#### [제한사항]\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/64062.%E2%80%85%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%E2%80%85%EA%B1%B4%EB%84%88%EA%B8%B0/README.md#%EC%A0%9C%ED%95%9C%EC%82%AC%ED%95%AD)\r\n\r\n-   징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.\r\n-   stones 배열의 크기는 1 이상 200,000 이하입니다.\r\n-   stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.\r\n-   k는 1 이상 stones의 길이 이하인 자연수입니다.\r\n\r\n----------\r\n\r\n#### [입출력 예]\r\n\r\n\r\n\u003ctable class=\"table\"\u003e\r\n        \u003cthead\u003e\u003ctr\u003e\r\n\u003cth\u003estones\u003c/th\u003e\r\n\u003cth\u003ek\u003c/th\u003e\r\n\u003cth\u003eresult\u003c/th\u003e\r\n\u003c/tr\u003e\r\n\u003c/thead\u003e\r\n        \u003ctbody\u003e\u003ctr\u003e\r\n\u003ctd\u003e[2, 4, 5, 3, 2, 1, 4, 2, 5, 1]\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003ctd\u003e3\u003c/td\u003e\r\n\u003c/tr\u003e\r\n\u003c/tbody\u003e\r\n      \u003c/table\u003e\r\n\r\n##### **입출력 예에 대한 설명**\r\n\r\n[](https://github.com/phnml1/CodingTest/blob/master/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/3/64062.%E2%80%85%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%E2%80%85%EA%B1%B4%EB%84%88%EA%B8%B0/README.md#%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%98%88%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85)\r\n\r\n----------\r\n\r\n**입출력 예 #1**\r\n\r\n첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.  \r\n![1.png](1.png)\r\n\r\n첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  \r\n두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.  \r\n![2.png](2.png)\r\n\r\n두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  \r\n세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.  \r\n![3.png](3.png)\r\n\r\n세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.  \r\n네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다.  \r\n![4.png](4.png)\r\n\r\n따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.\r\n\r\n## 접근 방법\r\n브루트 포스로 1명씩 건너기에는, stones 배열의 크기가 최대 200,000이고,  stones 배열의 각 원소들의 값 역시 최대 200,000,000이기 때문에, 시간 초과가 날 확률이 높다고 생각했고(사실 그렇게 쉬우면 lv3 일리가 없지), 아니나 다를까 시간초과가 났다. \r\n\r\n고민하다가 도저히 해결책이 안나와서 찾아보니 `이분탐색`을 사용하여 풀 수 있었다.\r\n\r\n- 건널 수 있는 인원의 최소는 1명, 최대는 max(stones)명이다. 모든 돌들의 합이 같거나, 다르다 하더라도 건널수 없는 곳이 k이하면 건널 수 있기 때문이다.  \r\n- 따라서 start = 1 end = max(stones)로 이분탐색을 시작할 수 있다.\r\n\r\nmid 값만큼의 사람이 건널 수 있는지 확인하기 위한 check함수는 다음과 같다.\r\n```python\r\ndef check(stones, mid,k):\r\n    cnt = 0;\r\n    for stone in stones:\r\n\t    # 밟을 수 없으므로 건너뛰어야하는 횟수를 늘린다.\r\n        if (stone - mid) \u003c= 0:\r\n            cnt += 1;\r\n        # 밟을 수 있으므로 최대 건너뛰는 횟수를 초기화시킨다.\r\n        else:\r\n            cnt = 0;\r\n        # 건너뛰는 횟수가 k보다 크거나 같으면 안되므로 False 리턴 \r\n        if cnt\u003e=k:\r\n            return False;\r\n    return True;\r\n```\r\n건널 수 있다면 mid보다 큰 범위에서 값을 찾아야하므로 start를 mid+1로 갱신하고, 반대라면, mid보다 작은 범위에서 값을 찾아야하므로 end를 mid-1로 갱신한다.\r\n \r\ncheck 시간 복잡도는 O(N)이고 이분탐색을 했을 때 O(logN)의 시간복잡도가 나오므로,  총 O(NlogN)의 시간 복잡도가 나오므로, 시간초과가 나지 않는다.\r\n\r\n전체 코드는 다음과 같다.\r\n```python\r\ndef check(stones, mid,k):\r\n    cnt = 0;\r\n    for stone in stones:\r\n        if (stone - mid) \u003c= 0:\r\n            cnt += 1;\r\n        else:\r\n            cnt = 0;\r\n        if cnt\u003e=k:\r\n            return False;\r\n    return True;\r\n\r\ndef solution(stones, k):\r\n    start,end = 1,max(stones);\r\n    answer = 0;\r\n    while start\u003c=end:\r\n        mid = (start + end) // 2;\r\n        if check(stones, mid,k):\r\n            start = mid+1;\r\n        else:\r\n            answer = mid;\r\n            end = mid-1;    \r\n    return answer;\r\n```\r\n\r\n## 느낀 점\r\n이분탐색 문제를 많이는 아니더라도 어느정도는 풀어봤다고 생각했는데, 이 문제에서 이분탐색으로 푸는 아이디어를 떠올리지 못해서 아쉽다. \r\n\r\n또한 처음에 위에 코드의 6번째줄에서 else문을 쓰지않고, 이러한 코드로 제출하여서 시간초과가 났다.\r\n```python\r\nif (stone - mid) \u003c= 0:\r\n\tcnt += 1;\r\nif (stone - mid)\u003e0:\r\n\tcnt = 0;\r\n```\r\nㅎㅎ.. 사실 위와 같은 경우에서 if else문을 쓰는 것이 기본인데, 그래도 시간초과가 날 수 있는 직접적인 원인까지는 되지 않을 거라고 안일하게 생각해서 코드를 짠 게 화근이었다. 기본을 지키자!"},{"slug":"posts/Javascript/javascriptdeepdive10","title":"객체 리터럴","date":"2024-04-29T15:33:24.000Z","image":"javascript.png","summary":"자바스크립트 딥다이브 책 내용 중 '객체 리터럴'의 정리 내용입니다.","tags":["JavaScript"],"content":"\r\n\r\n# 객체 리터럴\r\n\r\n## 객체란?\r\n\r\n\u003e 자바스크립트는 `객체`기반의 프로그래밍 언어이며 자바스크립트를 구성하는 거의 `모든 것`이 객체이다.\r\n\r\n- 원시타입의 값, 원시 값은 변경 불가능 한 값이지만, 객체 타입의 값, 즉 객체는 변경가능한 값이다.\r\n\r\n- 객체는 0개 이상의 `프로퍼티`로 구성된 집합, 프로퍼티는 `키(key): 값(value)`로 구성(**함수도 프로퍼티 값으로 사용 가능!**)\r\n- - 프로퍼티: 객체의 상태를 나타내는 값(data)\r\n\t\r\n  - 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작\r\n\r\n객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 `객체지향 프로그래밍` 이라고 함.\r\n\r\n## 객체리터럴에 의한 객체 생성\r\n```\r\n 인스턴스: 클래스에 의해 생성되어 메모리에 저장된 실체, 객체는 클래스와 인스턴스를 포함한 개념, 클래스는 인스턴스를 생성하기 위한 템플릿의 역할을 한다.\r\n ```\r\n자바스크립트는 **프로토타입 객체지향 언어** 로서, 클래스 기반 객체지향 언어와는 달리  다양한 객체 생성방법을 지원한다.\r\n\r\n- 객체 리터럴\r\n- Object 생성자 함수\r\n- 생성자 함수\r\n- Object.create 메서드\r\n- 클래스(ES6)\r\n\r\n객체 리터럴은 **중괄호**(  `{ ... }`  ) 내에 0개 이상의 프로퍼티를 정의한다. **변수에 할당되는 시점**에 자바스크립트 엔진은 **객체 리터럴을 해석**해 객체를 생성한다.\r\n```js\r\nvar person = {\r\n  name: \"Wi\",\r\n  sayHello: function () {\r\n    console.log(`Hello My name is ${this.name}`);\r\n  },\r\n};\r\n\r\nconsole.log(typeof person); // object\r\nconsole.log(person); // { name: 'Wi', sayHello: [Function: sayHello] }\r\n```\r\n중괄호 내에 프로퍼티 정의하지 않으면 **빈 객체** 생성\r\n\r\n## 프로퍼티\r\n**객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.**\r\n```js\r\nvar person = {\r\n  name: \"LEE\", // 프로퍼티 키는 name, 프로퍼티 값은 \"LEE\"\r\n  age: 26, // 프로퍼티 키는 age, 프로퍼티 값은 26\r\n};\r\n```\r\n-   `프로퍼티 키(key)`  : 빈 문자열(  `''`  ) 을 포함하는 모든  `문자열(string)`  또는  `심벌(symbol) 값`\r\n-   `프로퍼티 값(value)`  : 자바스크립트에서 사용할 수 있는 모든 값\r\n\u003cbr/\u003e\r\n\r\n**식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다** (규칙 준수하면 사용안해도 ㄱㅊ)\r\n```js\r\nvar person = {\r\n\tfirstName: 'Joo-young',  // 식별자 네이밍 규칙을 준수한 프로퍼티 키\r\n\t'last-name': 'Lee',       // 식별자 네이밍 규칙을 준수하지 않은 프로퍼티 키 ( 따옴표를 사용해 문자열 형태 유지 )\r\n  last-name: 'Lee'          // SyntaxError: Unexpected token ( 식별자 네이밍 규칙을 준수하지 않은 프로퍼티 키\r\n};\r\nconsole.log(person) // {firstName: 'Joo-young', last-name: 'Lee'}\r\n```\r\n\u003cbr/\u003e\r\n\r\n프로퍼티에 문자열이나 심벌 값 외의 값을 사용하면  **암묵적 타입 변환** 을 통해 문자열이 된다.\r\n```js\r\nvar foo = {\r\n  0: 1,\r\n  1: 2,\r\n  2: 3,\r\n};\r\n\r\nconsole.log(foo); // { 0: 1, 1: 2, 2: 3 } \u003c- 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지 않지만 내부적으로는 문자열로 변환된다. \r\n```\r\n\u003cbr/\u003e\r\n이미 존재하는 프로퍼티 중복 선언시 나중에 선언한 프로퍼티가 덮어씌워진다. (에러가 발생하지 않는 것 주의하자)\r\n\u003cbr/\u003e\r\n\r\n```js\r\nvar foo = {\r\nname: 'Lee',\r\nname: 'Kim',\r\n}\r\nconsole.log(foo); // {name: 'Kim'}\r\n```\r\n\r\n## 메서드\r\n자바스크립트에서 사용할 수 있는 모든 값은 **프로퍼티 값**으로 사용 가능, 자바스크립트의 함수는 객체(일급 객체) 이다. 따라서 함수는 값으로 취급할 수 있기 때문에 **프로퍼티 값으로 사용할 수 있다.** \r\n\r\n프로퍼티 값이 함수인 경우, 일반 함수와 구분하기 위해, `메서드`라고 부른다. 즉 메서드는 객체에 묶여있는 함수를 의미한다.\r\n\r\n```js\r\nvar circle= {\r\n  // 프로퍼티\r\n  radius: 5,\r\n\r\n  // 메서드\r\n  getDiameter: function () {\r\n    return 2 * this.radius;\r\n  },\r\n};\r\n\r\nconsole.log(person.getDiameter()); // 10\r\n```\r\n## 프로퍼티 접근\r\n- 마침표 프로퍼티 접근 연산자(.)로 사용하는 **마침표 표기법**\r\n- 대괄호 프로퍼티 접근 연산자([...]) 사용하는 **대괄호 표기법**\r\n\r\n\t```js\r\n\tvar person = {\r\n\t\tname: 'Lee'\r\n\t};\r\n\r\n\t// 마침표 표기법에 의한 프로퍼티 접근\r\n\tconsole.log(person.name); // Lee\r\n\r\n\t// 대괄호 표기법에 의한 프로퍼티 접근\r\n\tconsole.log(persone['name']); // Lee\r\n\t```\r\n- 대괄호 표기법을 사용하는 경우 **접근 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열**이어야 한다.\r\n\u003cbr/\u003e\r\n- 대괄호 프로퍼티 접근 연산자 내에 문자열 형태가 아닌 프로퍼티 키로 사용하면 자바스크립트 엔진은 **식별자로 해석**한다.\r\n-  객체에 존재하지 않는 프로퍼티에 접근하면 **undefined**를 반환한다.\r\n\r\n\t```js\r\n\t// 문자열 형태가 아닌 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석함\r\n\tconsole.log(person[name]); // ReferenceError: name is not defined\r\n\t// 객체에 존재하지 않는 프로퍼티에 접근하면 undefined반환\r\n\tconsole.log(person.age); // undefined\r\n\t```\r\n\r\n## 프로퍼티 동적 생성 \u0026 삭제\r\n```js\r\nvar person = {\r\n  name: \"Lee\",\r\n};\r\n// person 객체에 age는 존재x\r\n// 따라서 person객체에 age프로퍼티가 동적으로 생성되고 값이 할당된다.\r\nperson.age = 20; // { age: 20 } \r\nconsole.log(person); // { name: 'Lee', age: 20 }\r\n\r\ndelete person.age; // age 라는 프로퍼티 키가 존재하므로 해당 프로퍼티가 삭제된다.\r\ndelete person.address; // address이라는 프로퍼티 키는 없으므로 삭제 할 수 없지만, 에러는 발생하지 않는다.\r\n\r\nconsole.log(person); // { name: 'Lee' }\r\n```\r\n## ES6에서 추가된 객체 리터럴의 확장 기능\r\n\r\n\r\n### 프로퍼티 축약 표현\r\n```js\r\n// ES5\r\nvar x = 1, y=2;\r\n\r\nvar obj = {\r\n\tx:x,\r\n\ty:y\r\n};\r\nconsole.log(obj); // {x:1, y:2}\r\n\r\n// ES6(프로퍼티 축약 표현)\r\nlet x = 1, y = 2;\r\nconst obj = {x,y};\r\nconsole.log(obj);\r\n```\r\n### 계산된 프로퍼티 이름\r\n`ES5`\r\n```js\r\nvar prefix = \"prop\";\r\nvar i = 0;\r\n\r\nvar obj = {};\r\n\r\n// 계산된 프로퍼티 이름으로 프로퍼티 키 동적 생성\r\n// '객체 외부'에서만 가능\r\nobj[prefix + \"-\" + ++i] = i;\r\nobj[prefix + \"-\" + ++i] = i;\r\nobj[prefix + \"-\" + ++i] = i;\r\n\r\nconsole.log(obj); // { prop-1: 1, prop-2: 2, prop-3: 3 }\r\n```\r\n`ES6`\r\n```js\r\nconst prefix = \"prop\";\r\nlet i = 0;\r\n\r\n// '객체 리터럴 내부'에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성\r\nconst obj = {\r\n  [`${prefix}-${++i}`]: i,\r\n  [`${prefix}-${++i}`]: i,\r\n  [`${prefix}-${++i}`]: i,\r\n};\r\n\r\nconsole.log(obj); // { prop-1: 1, prop-2: 2, prop-3: 3 }\r\n```\r\n\r\n### 메서드 축약 표현\r\n`ES5`\r\n```js\r\nvar obj = {\r\n\tname: \"Lee\",\r\n\tsayHi: function () {\r\n\t\tconsole.log('Hi!' + this.name);\r\n\t},\r\n};\r\n\r\nobj.sayHi(); // Hi! Lee\r\n```\r\n`ES6`\r\n```js\r\nconst obj = {\r\n\tname: \"JY\",\r\n\t // 메서드 축약 표현\r\n\tsayHi() {\r\n\t\tconsole.log(`Hi! ${this.name}`);\r\n\t},\r\n};\r\n\r\nobj.sayHi(); // Hi! JY\r\n```\r\n메서드 축약 표현 으로 정의한 메서드는 프로퍼티에 할당한 함수 와 다르게 동작한다.\r\n(이후 자세히 살펴볼 예정)"},{"slug":"posts/Javascript/javascriptdeepdive11","title":"원시 값과 객체의 비교","date":"2024-04-26T14:30:51.000Z","image":"javascript.png","summary":"자바스크립트 딥다이브 책 내용 중 '원시 값과 객체의 비교'의 정리 내용입니다.","tags":["JavaScript"],"content":"\r\n# 원시 값과 객체의 비교\r\n\r\n\r\n## 원시 타입 vs 객체 타입\r\n- 원시 타입의 값, 즉 `원시 값`은 **변경 불가능한 값(immutable value)** vs  `객체(참조) 타입의 값`, 즉 객체는 **변경 가능한 값(mutable value)**이다.\r\n- `원시 값`을 변수에 할당하면 변수(확보된 메모리 공간)에는 **실제 값이 저장** vs `객체` 를 변수에 할당하면 변수(확보된 메모리 공간)에는 **참조 값이 저장**\r\n- `원시 값을 갖는 변수`를 다른 변수에 할당하면 원본의 **원시 값이 복사되어 전달**(**값에 의한 전달**)  vs  `객체를 가리키는 변수`를 다른 변수에 할당하면 **원본의 참조 값이 복사되어 전달**(**참조에 의한 전달**)\r\n\r\n## 원시 값\r\n\r\n**원시 값: 원시 타입의 값, 원시 값은 변경 불가능한 값**(`읽기 전용의 값(readonly)`)\r\n\r\n**❗ 변수와 값은 엄연히 다른것!**\r\n- `변수`는 하나의 값을 저장하기 위해 확보한 **메모리 공간 자체** 또는 그 **메모리 공간을 식별하기 위해 붙인 이름**\r\n- `값`은 변수에 저장된 **데이터 표현식이 평가되어 생성된 결과**\r\n- 변경 불가능한 것은 **값에 대한 진술**, 변수는 재할당을 통해, 변수 값을 변경(교체) 가능\r\n\r\n** 변수vs상수 **\r\n+ 변수는 언제든지 `재할당`을 통해 변수 값을 변경(교체)할 수 있다. 그래서 \"변수\"다.\r\n+ 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 `변수`라고 할 수 있다.\r\n+ 하지만, 상수는 단 한 번만 할당이 허용하므로 변수 값을 변경할 수 없다. (이를 변경 불가능한 값으로 동일시하면 안됨 상수는 **재할당이 금지된 변수**)\r\n\r\n###  불변성\r\n변경 불가능한 값인 **원시 값**은 값을 변경하는 것이 아닌, 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수가 참조하던 메모리 공간의 주소를 변경한다. 값의 이러한 특성을 `불변성` 이라고 한다.  \r\n\r\n**`불변성` 을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법**이 없다.\r\n\r\n### 문자열과 불변성\r\n자바스크립트는 개발자의 편의를 위해 문자열 타입을 원시 타입으로 제공한다.\r\n\r\n문자열은 유사 배열객체이면서 이터러블이므로 **배열과 유사하게 각 문자에 접근**할 수 있다.\r\n\r\n**유사 배열 객체란?**\r\n\r\n- 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있으며, length 프로퍼티를 갖는 객체\r\n- length 프로퍼티를 갖기 때문에 유사 배열 객체 이며, for 문으로 순회도 할 수 있다.\r\n\t```js\r\n\tvar str = 'string';\r\n\t// 유사배열이므로, 배열과 유사하게 인덱스를 사용해 각 문자로 접근\r\n\tconsole.log(str[0]);\r\n\t// 원시 값인 문자열이 객체처럼 동작\r\n\tconsole.log(str.length); //6\r\n\tconsole.log(str.toUpperCase()); //STRING\r\n\t```\r\n```js\r\nvar str = 'string'\r\n// 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근\r\n// 하지만 문자열은 원시 값이므로 변경할 수 없다. 이때 에러는 발생 x\r\nstr[0] = 'S'\r\nconsole.log(str)// string\r\n```\r\n이는 데이터의 신뢰성을 보장한다. 변수에 새로운 문자열을 재할당하는 것은 물론 가능\r\n\r\n### 값에 의한 전달\r\n```js\r\nvar score = 80;\r\nvar copy = score;\r\n\r\nscore = 100;\r\n\r\nconsole.log(score); // 100 (원본 값)\r\nconsole.log(copy); // 80  (복사한 값)\r\n```\r\nscore는 변수 값 80으로 평가 되므로, copy 변수에도 80이 할당된다. 이때 새로운 숫자 값 80이 생성되어 copy변수에 할당된다\r\n\r\n변수(copy)에는 할당되는 변수(score)의 **원시 값이 복사되어 전달**된다. \r\n 이를,  `값에 의한 전달`이라고 한다.\r\n\r\ncopy와 score는 별개의 값으로써, 서로의 변수의 값에 어떠한 영향도 주지않음.\r\n\r\n또한,\r\n엄격하게 말하자면, 변수에는 값이 전달되는 것이 아니라, **메모리 주소가 전달되는 것이다.**\r\n이는 변수와 같은 식별자는 값이 아니라 **메모리 주소를 기억**하기 때문이다.\r\n\u003e 이처럼 \"값에 의한 전달\"도 사실은 값을 전달하는 것이 아니라, 메모리 주소를 전달한다. 단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.\r\n\r\n하지만 중요한 것은,\r\n\r\n❗ **결국 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다.**\r\n\r\n## 객체\r\n\u003e 자바스크립트는 다른 객체지향 언어와는 달리, 클래스 없이 객체 생성가능하며, 객체가 생성된 이후라도 동적으로 프로퍼티와 메서드 추가가 가능하다. V8 엔진에서는 **히든 클래스**라는 방식을 사용한다.\r\n\r\n### 변경 가능한 값\r\n**객체(참조)타입의 값, 즉 객체는 변경 가능한 값**\r\n\r\n원시 값과 다르게, 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면 **참조 값**에 접근한다!\r\n- `참조 값`: 생성된 객체가 저장된 메모리 공간의 주소, 그 자체\r\n```js\r\nvar person = {\r\n\tname: 'Lee'\r\n};\r\n\r\n// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근한다.\r\nconsole.log(person) //{name: \"Lee\"}\r\n```\r\n객체를 할당한 변수의 경우 \"변수는 객체를 가리키고(참조하고)있다\" 라고 표현한다.\r\n```person 변수는 {name: 'Lee'}를 가리키고(참조하고) 있다.```\r\n객체를 할당한 변수는 원시 값과 달리,  재할당 없이 객체를 직접 변경할 수 있다.\r\n즉, 재할당 없이  **프로퍼티를 동적으로 추가, 프로퍼티 값을 갱신,  프로퍼티 자체를 삭제도 가능**\r\n\r\n```js\r\nvar person = {\r\n  name: \"Lee\",\r\n};\r\n\r\n// 프로퍼티 값 갱신\r\nperson.name = \"Kim\";\r\n\r\n// 프로퍼티 값 동적 추가\r\nperson.address = \"Seoul\";\r\n\r\nconsole.log(person); // { name: 'Kim', address: 'Seoul' }\r\n```\r\n원시 값과는 다르게 **여러개의 식별자가 하나의 객체를 공유할 수 있다**라는 부작용이 있다.\r\n\r\n### 얕은 복사와 깊은 복사\r\n객체를 프로퍼티의 값으로 갖는 객체의 경우 \r\n- `얕은 복사`는 **한단계만 복사**하는 것을 말하며, 객체의 중첩되어있는 객체의 경우 참조 값을 복사한다.\r\n-  `깊은 복사`는 **객체에 중첩되어 있는 객체까지 모두 복사**하며, **원시 값처럼 완전한 복사본을 만든다.**\r\n\r\n### 참조에 의한 전달\r\n```js\r\nvar person = {\r\n\tname: 'Lee'\r\n};\r\n// 참조 값을 복사(얕은 복사)\r\nvar copy = person;\r\n```\r\nperson을 다른 변수(사본, copy)에 할당하면 **원본의 참조 값이 복사되어 전달**된다. 이를 **참조에 의한 전달** 이라고 한다.\r\n원본 person과 사본 copy는 동일한 참조 값을 가진다. 즉, 둘 모두 동일한 객체를 가리킨다. 이것은 **두 개의 식별자가 하나의 객체를 공유한다는 것을 의미**\r\n```js\r\nvar person = {\r\n  name: \"Lee\",\r\n};\r\n\r\n// \"참조 값\"을 \r\n복사, copy와 person이 동일한 참조 값을 갖는다.\r\nvar copy = person;\r\n// 동일한 객체 참조하므로\r\nconsole.log(copy === person); // true\r\n\r\n// copy를 통해 객체의 name 프로퍼티를 변경한다.\r\ncopy.name = \"Kim\";\r\n\r\n// person을 통해 객체의 address 프로퍼티를 동적 생성한다.\r\nperson.address = \"Seoul\";\r\n\r\n// copy와 person은 동일한 객체를 가리키므로 서로 영향을 주고받음\r\nconsole.log(person); // { name: 'Kim', address: 'Seoul' }\r\nconsole.log(copy); // { name: 'Kim', address: 'Seoul' }\r\n```\r\n\"값에 의한 전달\"과 \"참조에 의한 전달\"은 **식별자가 기억하는 메모리 공간에 저장되어 있는 값을 전달한다는 면에서 동일**하다. 따라서 **\"참조에 의한 전달\"은 존재하지 않고 \"값에 의한 전달\"만이 존재한다고 할 수 있다.**"},{"slug":"posts/Javascript/javascriptdeepdive09","title":"자바스크립트 딥다이브: 09.타입 변환과 단축평가","date":"2024-04-22T12:00:24.000Z","image":"javascript.png","summary":"자바스크립트 딥다이브 책 내용 중 '타입 변환과 단축평가'의 정리 내용입니다.","tags":["JavaScript"],"content":"\r\n# 타입 변환과 단축 평가\r\n개발자가 의도적으로 값의 타입을 변환하는 것: `명시적 타입 변환` or `타입캐스팅`\r\n\r\n개발자의 의도와는 상관없이 표현식을 평가하는 도중에 **자바스크립트 엔진에 의해 암묵적으로 타입이 변환**되는 것: `암묵적 타입 변환` or `타입강제 변환`\r\n\r\n## 암묵적 타입 변환\r\n\u003e 자바스크립트 엔진이 표현식을 평가할 때 개발자의 의도와는 상관없이 `코드의 문맥을 고려해 암묵적으로` 데이터 타입을 강제 변환(암묵적 타입 변환)할 때가 있다.\r\n\r\n암묵적 타입 변환은 문자, 숫자, 불리언 같은 **원시 타입**중 하나로 타입을 자동 변환한다.\r\n\r\n### 문자열 타입으로 변환\r\n```js\r\n// 숫자 타입 \r\n0+'' // '0'\r\nNaN + '' // 'NaN'\r\nInfinity + '' // 'Infinity'\r\n\r\n// 불리언 타입\r\ntrue + '' // 'true'\r\n\r\n// null 타입\r\nnull + '' // 'null'\r\n\r\n// undefined 타입\r\nundefined + '';       // \"undefined\"\r\n\r\n// 심벌 타입\r\n(Symbol()) + '';      // TypeError: Cannot convert a Symbol value to a string\r\n\r\n// 객체 타입\r\n({}) + '';            // \"[object Object]\"\r\nMath + '';            // \"[object Math]\"\r\n[] + '';              // \"\"\r\n[10, 20] + '';        // \"10,20\"\r\n(function(){}_ + '';  // \"function(){}\"\r\nArray + '';           // \"function Array() { [native code] }\"\r\n```\r\n\r\n### 숫자 타입으로 변환\r\n```js\r\n// 문자열 타입(+ 단항연산자는 피연산자가 숫자타입이 아니면 숫자 타입으로 암묵적 타입 변환 수행)\r\n+'' // -\u003e 0\r\n+'0' // 0\r\n+'string' // -\u003e NaN\r\n\r\n// 불리언 타입\r\n+true // -\u003e 1\r\n\r\n// null 타입\r\n+null // -\u003e 0\r\n\r\n//undefined 타입\r\n+undefined // -\u003e NaN\r\n\r\n// 심벌 타입\r\n+Symbol(); // TypeError: Cannot convert a Symbol value to a number\r\n\r\n// 객체 타입\r\n+{}; // -\u003e NaN\r\n+[]; // -\u003e 0\r\n+[10, 20]; // NaN\r\n+function () {}; // NaN\r\n```\r\n**빈 문자열 (''), 빈 배열([]), null, false**는 **0**으로, **true**는 **1**로 변환된다. **객체와 빈 배열이 아닌 배열,undefined**는 변환되지 않아 **NaN**이 된다는 것에 주의하자\r\n\r\n### 불리언 타입으로 변환\r\nif문, for문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값, 즉 논리적 참/거짓으로 평가 되어야 하는 표현식이다.\r\n```js\r\n// 모두 코드 블록 실행됨\r\nif(!false) console.log(false + ' is falsy value')\r\nif(!undefined) console.log(undefined + 'is falsy value')\r\nif(!NaN) console.log(NaN + 'is falsy value');\r\nif(!null) console.log(null + 'is falsy value');\r\n```\r\n자바스크립트 엔진은 불리언 타입이 아닌 값을 `Truthy 값(참으로 평가되는 값)` or `Falsy 값(거짓으로 평가되는 값)` 으로 구분한다.\r\n\r\n**자바스크립트 엔진이 Falsy 값으로 판단하는 값**\r\n+ false\r\n+ undefined\r\n+ null\r\n+ 0, -0\r\n+ NaN\r\n+ ''(빈 문자열)\r\n\r\n## 명시적 타입 변환\r\n**개발자의 의도에 따라 명시적으로 타입을 변환하는 것** \r\n\r\n**표준 빌트인 함수(String,Number,Boolean)**을  new연산자 없이 호출하는 방법과 **빌트인 메서드를 사용하는 방법**, 그리고 **암묵적 타입 변환**을 이용하는 방법이 있다.\r\n\r\n### 문자열 타입으로 변환\r\n```js\r\n// String 생성자 함수를 new 연산 없이 호출\r\nString(1); // -\u003e \"1\"\r\nString(NaN); // -\u003e \"NaN\"\r\nString(Infinity); // -\u003e \"Infinity\"\r\nString(false); // -\u003e \"false\"\r\n\r\n// Object.prototype.toString 메서드를 사용하는 방법\r\n(NaN).toString() // -\u003e 'NaN'\r\n(true).toString() // -\u003e 'true'\r\n\r\n// 문자열 연결 연산자\r\nNaN + '' // -\u003e \"NaN\"\r\n```\r\n\r\n### 숫자 타입으로 변환\r\n```js\r\n// Number 생성자 함수를 new 연산자 없이 호출하는 방법\r\nNumber('0') // -\u003e 0\r\nNumber(10.53) // -\u003e 10.53\r\n\r\n// parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)\r\nparseInt('0') // -\u003e 0\r\nparseFloat('10.53') // -\u003e 10.53\r\n\r\n// + 단항 산술 연산자를 이용하는 방법\r\n// 문자열 타입 =\u003e 숫자 타입\r\n+'0'\r\n+'-1'\r\n// 불리언 타입 =\u003e 숫자 타입\r\n+true; //-\u003e1\r\n\r\n// * 산술 연산자를 이용하는 방법\r\n// 문자열 타입 =\u003e 숫자 타입\r\n'0' * 1;\r\n'-1' * 1; //1\r\n// 불리언 타입 =\u003e 숫자 타입\r\ntrue * 1; //-\u003e1\r\n```\r\n\r\n### 불리언 타입으로 변환\r\n```js\r\n// 1. Boolean 생성자 함수를 new 키워드 없이 호출하는 방법\r\nBoolean('x'); // true\r\n\r\nBoolean(0) // false\r\nBoolean(NaN) // false\r\nBoolean(Infinity) // true\r\n\r\nBoolean(null) // false\r\nBoolean(undefined) // false\r\n\r\nBoolean({}) //True\r\n\r\n//2. !(부정 논리 연산자) 두 번 사용\r\n!!'x';  // true ( !(!'x') === !(false) -\u003e true )\r\n```\r\n\r\n## 단축 평가\r\n\u003e `단축 평가` : 논리 연산의 결과를 결정하는 피연산자를 `타입 변환하지 않고 그대로 반환`\r\n-  단축 평가는 표현식을 평가하는 도중에 평가결과가 확정 경우 → 나머지 평가 과정을 생략한다.\r\n단축 평가 표현식\r\n\r\n| 단축 평가 표현식 | 평가 결과 |\r\n|--|--|\r\n|true ll anything  | true |\r\n|false ll anything | anything |\r\n| true \u0026\u0026 anything |  anything|\r\n| false \u0026\u0026 anything | false |\r\n\r\n### 논리 연산자를 단축 평가\r\n`논리곱(\u0026\u0026)` 에서 논리 연산의 결과를 결정하는 것은 **두 번째 피연산자**\r\n```js\r\n'Cat' \u0026\u0026 'Dog'; // Dog\r\n```\r\n\r\n`논리곱(\u0026\u0026) 연산자` 는 두 개의 피연산자가 `모두 true로 평가될 때 true를 반환`, `좌항 -\u003e 우항으로 평가가 진행` \r\n\r\n\r\n`논리합(||)` 에서  논리 연산의 결과를 결정하는 것은 **첫 번째 피연산자**  그러므로 첫 번째 연산자 그대로 반환\r\n```js\r\n'Cat' || 'Dog' // Cat\r\n```\r\n\r\n`논리합 (||) 연산자` 는 `두 개의 피연자 중 하나만 true로 평가되어도 true로 반환`하며, 역시 `좌항에서 우항으로 평가가 진행`\r\n\r\n ```js\r\n // 논리합(||) 연산\r\n\"Cat\" || \"Dog\"; // \"Cat\"\r\nfalse || \"Dog\"; // \"Dog\"\r\n\"Cat\" || false; // \"Cat\"\r\n\r\n// 논리곱(\u0026\u0026) 연산\r\n\"Cat\" \u0026\u0026 \"Dog\"; // \"Dog\"\r\nfalse \u0026\u0026 \"Dog\"; // \"false\"\r\n\"Cat\" \u0026\u0026 false; // \"false\"\r\n ```\r\n **단축평가 사용 예시**\r\n - **if 문대체**\r\n논리 연산자 단축평가를 통해서 if문도 대체할 수 있으며, 값 할당시 보다 더 깔끔할 수 있다.\r\n\t```js\r\n\tvar done = false;\r\n\tvar message = \"\";\r\n\r\n\t// 조건문으로 값 할당\r\n\tif (!done) message = \"미완료\";\r\n\r\n\tmeessage = done || \"미완료\";\r\n\tconsole.log(message) // 미완료\r\n\t```\r\n- **객체를 가리키기를 기대하는 변수의 값이 객체가 아니라 null또는 undefined일 경우** \r\n\r\n\t이러한 경우 타입 에러가 발생한다. 하지만, 단축평가를 사용하면 에러 발생 x\r\n\t```js\r\n\t// elem이 null 또는 undefined같은 Falsy값이면 elem으로 평가\r\n\t// elem이 Truthy값이면 elem.value 값으로 평가\r\n\tvar elem = null;\r\n\tvar value = elem \u0026\u0026 elem.value // null\r\n\t```\r\n- **함수 매개변수에 기본값을 설정**\r\n함수를 호출할 때 인수를 전달하지 않으면 매개변수에는 undefined가 할당된다.  단축평가 사용해 매개변수에 기본값을 설정한다면 에러 방지 가능\r\n\t```js\r\n\t// 단축 평가를 사용한 매개변수의 기본값 설정\r\n\tfunction getStringLength(str) {\r\n\t  str = str || \"\";\r\n\t  return str.length;\r\n\t}\r\n\tgetStringLength(); // 0\r\n\tgetStringLength('hi'); //2\r\n\t//  Es6의 매개변수 default parameter 설정\r\n\tfunction getStringLength(str = \"\") {\r\n\t  return str.length;\r\n\t}\r\n\tgetStringLength(); // 0\r\n\t```\r\n\r\n## 옵셔널 체이닝 연산자\r\n`?` : 좌항의 피 연산자가 null 또는 undefined인 경우 `undefined 반환`, 그렇지않으면 `우항의 포로퍼티 참조`\r\n```js\r\nvar elem = null;\r\nvar value = elem?.value; // undefined\r\n```\r\n-   객체를 가리키기를 기대하는 변수가 null 또는 undefined가 아닌지 확인하고 프로퍼티를 안전하게 참조할 때 유용\r\n-   옵셔널 체이닝 도입 이전에는  `논리곱(\u0026\u0026)을 사용한 단축 평가`를 통해 변수가 null 또는 undefined 인지 확인했음\r\n```js\r\n// 좌항이 Falsy라면 좌항 그대로 반환(0이나 ''반환 할 때도)\r\nvar str = \"\"; //\r\nvar length = str \u0026\u0026 str.length; // ''\r\n\r\n// 좌항 피연산자가 Falsy값이라도 null 또는 undefined 만 아니면, 우항의 프로퍼티를 참조한다.\r\nvar str = \"\";\r\nvar length = str?.length; // 0\r\n```\r\n\r\n## null 병합 연산자 \r\n`??` : 좌항의 피연산자가 **null또는 undefined인 경우** `우항의 피연산자 반환` 그렇지 않으면 `좌항 피연산자 반환`한다.\r\n```js\r\nvar foo = null ?? \"default string\"; // \"default string\"\r\n```\r\n- 변수에 기본값을 설정할 때 유용하며, 그전에는 논리합(||)을 사용한 단축평가로 변수에 기본값 설정\r\n\t```js\r\n\t// 좌항의 피연산자가 Falsy값이면, 우항의 피연산자를 반환 \r\n\t//(Falsy 값인 0 이나 ''도 기본값으로서 유효하다면 예기치 않은 동작이 발생한다.)\r\n\tvar foo = \"\" || \"default string\"; // \"default string\"\r\n\r\n\t//  좌항의 피연산자가 Falsy값이라도 null 또는 undefined 가 아니면, 좌항의 피연산자를 그대로 반환한다.\r\n\tvar foo = \"\" ?? \"default string\"; // ''\r\n\t```"}]},"__N_SSG":true},"page":"/posts/tag/[tag]","query":{"tag":"all"},"buildId":"M_ik3B_k46au3dvCt_K_P","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/media/45cca0c1391027f2-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/e807dee2426166ad-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/21e61e33ca2324ab-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/a5f02fb6311fcdbc-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/61eb19e8a04bc1be-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/e1fc1184cf147048-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/494ccb5802e3694f.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/494ccb5802e3694f.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-aa55ffd08992d156.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-f3cbbc972db2c15a.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/108-ababe0d3bb81df72.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/tag/%5Btag%5D-6f0344953c5fcd5a.js" defer="" crossorigin=""></script><script src="/_next/static/9pSzUQMJk0o3XoDpcpVz0/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/9pSzUQMJk0o3XoDpcpVz0/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"tags":["react native","드래그 앤 드롭","PanResponder","칸반보드","트러블슈팅","google map","expo-location","졸업작품","react","JavaScript","deepdive","useState","hook","next.js","SSR","Suspense","렌더링","테스트","dev tools","SSG","Algorithm","프로그래머스","PCCP","lv2","이분탐색","클로저","생명주기","Virtual DOM","백준","gold","dfs","lv3","bfs"],"currentTag":"드래그 앤 드롭","posts":[{"slug":"posts/React Native/React Native 칸반보드 드래그 앤 드롭 구현기_1","title":"React Native 칸반보드 드래그 앤 드롭 구현기 (1)","date":"2025-12-28T22:16:00.000Z","image":"index.png","summary":"React Native에서 칸반보드 형태의 Drag \u0026 Drop을 구현하며 PanResponder 기반 절대 좌표 시스템을 선택한 이유와 구현 과정을 공유합니다.","tags":["react native","드래그 앤 드롭","PanResponder","칸반보드","트러블슈팅"],"content":"\r\n# React Native 칸반보드 드래그 앤 드롭 구현기(1)\r\n\r\n## 서론\r\n안녕하십니까. 오랜만에 다시 글을 쓰게 되었다.\r\n여러 프로젝트와 취업준비로 인해 한동안 글을 쓰지 못했는데, (~~(사실 의지력 이슈로)~~) 지금부터라도! 다시 열심히 글을 쓰려고 한다!\r\n\r\n관광데이터 공모전에서 다시 expo기반의 React Native로 프로젝트를 진행했었는데, 여기서 구현한 다양한 기능들 중 여행 일정을 관리하기 위해 드래그 앤 드롭을 사용하여 각 Day의 일정들을 드래그 앤 드롭으로 편집할 수 있어야 했다. 백문이 불여일견이라고 실제 구현했던 부분을 보여주겠다.\r\n\r\n\u003cimg src=\"1.gif\" alt=\"드래그 앤 드롭 구현 화면\"/\u003e\r\n\r\n\r\n다음과 같이 같은 Day 내에서의 요소의 터치를 통한 이동, 리스트간에서도 요소를 이동할 수 있어야 했고, 요소가 특정 경계선으로 갈 경우 자동 스크롤도 되어야 했다.\r\n\r\n앞으로 이 기능을 구현할 때 필요했던 기술과 리스트 내에서 요소를 놓는 것을 구현했던 방법들을 보여줄 것이다.\r\n\r\n아직 취준생이라 많이 부족해보이겠지만 모쪼록 잘 부탁드립니다!!\r\n\r\n## 라이브러리 없이 Drag \u0026 Drop을 구현하기로 한 이유\r\n사실... 라이브러리로 구현하는게 분명히 더 쉽고, 정신건강(?)상도 좋았을 것이다. 하지만, 그럼에도 직접 구현을 선택했던 이유가 있다.\r\n\r\n우선, 기존에 나와있던 라이브러리를 살펴보자.\r\n(2025 8월~10월 기준으로 구현했을 때의 기준입니다.)\r\n\r\n\r\n\r\n## 필요 기술들\r\n###  react-beautiful-dnd\r\n가장 유명한 Drag \u0026 Drop 라이브러리는 `react-beautiful-dnd`였다.  \r\n웹 환경에서는 이미 검증된 라이브러리이고, 칸반보드 구현 사례도 풍부했다. 오 이걸로 하면 되겠군! \r\n\r\n하지만,\r\n\r\n-   **웹 전용 라이브러리**\r\n    \r\n-   React Native 환경에서는 사용 불가\r\n    \r\n\r\n아무리 구현 사례가 많아도, 이번 프로젝트에는 적용할 수 없는 선택지였다.\r\n\r\n----------\r\n\r\n###  react-native-draggable-flatlist\r\n\r\n다음으로 검토한 라이브러리는 제일 유명했던  `react-native-draggable-flatlist`였다.  \r\nReact Native 환경에서 Drag \u0026 Drop을 지원하는 대표적인 라이브러리다.\r\n\r\n단일 리스트 내에서 아이템 순서를 변경하는 용도로는 충분히 잘 동작했다.  \r\n하지만 실제 요구사항과 비교해보니 결정적인 차이가 있었다.\r\n\r\n-    **단일 리스트 기준 설계**\r\n    \r\n-   여러 컬럼(Day) 간 이동을 전제로 하지 않음\r\n    \r\n-   드래그 중 다른 리스트 위로 이동하는 시나리오가 구조적으로 맞지 않음\r\n    \r\n\r\n여러 개의 날짜 컬럼을 넘나드는 **칸반보드 형태의 Drag \u0026 Drop**을 구현하기에는  \r\n라이브러리의 기본 설계 자체가 맞지 않았다.\r\n\r\n무리하게 커스터마이징할 수도 있었겠지만,  \r\n그 경우 라이브러리 내부 구현에 강하게 의존하게 되고  \r\n유지보수 비용이 급격히 증가할 가능성이 높았다.\r\n\r\n그 외에도 Stack Overflow와 구글링을 통해 꾸준히 라이브러리를 찾아보았지만, 칸반보드 형태로 리스트 간 드래그 앤 드롭을 구현하는 최신 라이브러리가 없었고, 예제들 역시 매우 예전 것들 밖에 없었다.\r\n\r\n그래서 **직접 구현하자!** 라는 결론에 도달하게 되었다.\r\n\r\n## PanResponder를 선택한 이유\r\n\r\n라이브러리를 직접 구현하기로 결정한 뒤, 가장 먼저 고민한 건  \r\n**어떤 도구로 드래그 입력을 받을 것인가**였다.\r\n\r\nReact Native에서 제스처를 다루는 선택지는 몇 가지가 있지만,  \r\n이번 구현에서는 **PanResponder**를 기반으로 하기로 했다.\r\n\r\n### PanResponder란?\r\n\r\nPanResponder는 React Native에서 제공하는 기본 제스처 시스템이다.  \r\n터치 시작, 이동, 종료와 같은 이벤트를 세밀하게 제어할 수 있고,  \r\n외부 라이브러리 없이도 드래그 인터랙션을 구현할 수 있다.\r\n\r\n```js\r\nconst panResponder = PanResponder.create({\r\n  onStartShouldSetPanResponder: () =\u003e true,\r\n  onPanResponderMove: (evt, gestureState) =\u003e {\r\n    // 터치 이동 처리\r\n  },\r\n  onPanResponderRelease: () =\u003e {\r\n    // 터치 종료 처리\r\n  },\r\n});\r\n```\r\n\r\n사실 단순한 Drag \u0026 Drop이라면,  \r\n`gestureState.dx / dy` 값을 그대로 사용해서  \r\n카드를 움직이는 방식도 충분히 가능하다.\r\n\r\n하지만 이 프로젝트에서는 **그 방식이 맞지 않았다.**\r\n\r\n----------\r\n\r\n## PanResponder를 \"드래그 엔진\"으로 쓰지 않기로 한 이유\r\n칸반보드 형태의 Drag \u0026 Drop에서는\r\n다음과 같은 상황이 동시에 발생한다.\r\n\r\n- 여러 개의 세로 리스트\r\n- 각 리스트의 독립적인 스크롤\r\n- 드래그 중 다른 컬럼으로 이동\r\n- 화면 끝에서 자동 스크롤\r\n\r\n이 환경에서 PanResponder가 제공하는 gestureState.dx / dy 기반의 상대 좌표 시스템은 빠르게 한계를 드러냈다.\r\n상대 좌표의 문제점\r\n\r\n- dx/dy는 제스처 시작점 기준 누적 이동량이라 스크롤이 개입되면 기준점이 틀어진다\r\n- 컬럼이 여러 개일수록 각각의 레이아웃 좌표를 추적하기 복잡해진다\r\n- Portal로 렌더링된 Floating Card는 화면 최상위에 위치하므로 부모 컴포넌트 기준의 상대 좌표와 기준이 어긋난다\r\n\r\n결국 중요한 건\r\n\"제스처 시작점으로부터 얼마나 움직였는가\"가 아니라\r\n**지금 손가락이 화면의 어디에 있는가**였다.\r\n절대 좌표 기반 접근\r\n그래서 PanResponder의 `gestureState.dx/dy`를 버리고\r\n`evt.nativeEvent.pageX / pageY`로 화면 절대 좌표만을 사용했다.\r\n이 방식의 장점은 명확했다.\r\n\r\n- 스크롤 여부와 상관없이 항상 동일한 기준 (화면 좌상단 기준)\r\n- 여러 컬럼 간 이동에도 좌표가 일관됨\r\n- Portal에 렌더링된 Floating Card의 위치 계산과 자연스럽게 연결됨\r\n- 드롭 타겟 판별 시 모든 요소가 같은 좌표계를 공유\r\n\r\n즉, PanResponder는\r\n**상대 이동량을 계산하는 도구**가 아니라\r\n**현재 터치 위치를 전달하는 도구**가 되었다.\r\n**역할을 명확히 나누다**\r\n\r\n이 시점에서 Drag \u0026 Drop 구조는 이렇게 나뉘었다.\r\n\r\n- PanResponder\r\n\r\n  - 터치 시작 / 이동 / 종료 감지\r\n  - 현재 손가락의 절대 좌표(pageX/pageY) 전달\r\n\r\n\r\n- 드래그 로직\r\n  - 절대 좌표 기반 상대 이동량 계산\r\n  - 드롭 위치 판별 (어느 컬럼, 어느 인덱스)\r\n  - 컬럼 간 이동 계산\r\n  - 스크롤 오프셋 보정\r\n  - 데이터 업데이트\r\n\r\n\r\n- 시각적 표현\r\n\r\n  - Portal을 통한 Floating Card 렌더링\r\n  - 절대 좌표 기반 초기 위치 설정\r\n  - Animated.Value로 이동량 반영\r\n  - opacity, scale 등의 피드백 애니메이션\r\n\r\n\r\n\r\nPanResponder가 모든 걸 책임지지 않게 되자,\r\n구현은 오히려 단순해졌고\r\n각 로직을 독립적으로 테스트하고 개선할 수 있었다.\r\n\r\n## 이어서\r\n다음 편에서는 이를 이용한 구현코드들을 보여줄 예정이다. 기대 부탁~"}]},"__N_SSG":true},"page":"/posts/tag/[tag]","query":{"tag":"드래그 앤 드롭"},"buildId":"9pSzUQMJk0o3XoDpcpVz0","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
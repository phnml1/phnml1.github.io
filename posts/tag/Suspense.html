<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/media/a15f2fce4b98b461-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/3d9ea938b6afa941-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/ee285b05ac47a625-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/1de9c871cd3a3669-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/bf54e24be5d8358f-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/media/02701f268eb7de16-s.p.woff2" as="font" type="font/woff2" crossorigin="anonymous" data-next-font="size-adjust"/><link rel="preload" href="/_next/static/css/23abc12e276fc5ef.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/23abc12e276fc5ef.css" crossorigin="" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-59c5c889f52620d6.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-aa55ffd08992d156.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-9f85f92bf56823a0.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/108-ababe0d3bb81df72.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/posts/tag/%5Btag%5D-849b97013b8d825a.js" defer="" crossorigin=""></script><script src="/_next/static/NEdP3VXn9r1vgkE0HJoJ2/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/NEdP3VXn9r1vgkE0HJoJ2/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"tags":["react","next.js","deepdive","SSR","Suspense","렌더링","테스트","트러블슈팅","dev tools","SSG","Algorithm","프로그래머스","PCCP","lv2","이분탐색","JavaScript","useState","hook","클로저","생명주기","Virtual DOM","백준","gold","dfs","lv3","bfs","all"],"currentTag":"Suspense","posts":[{"slug":"posts/React/React와 Nextjs의 Suspense","title":"React와 Next.js의 Suspense에 대해 알아보자","date":"2024-11-25T00:00:24.000Z","image":"index.png","summary":"React와 Next.js에서 Suspense를 어떤 방식으로 다르게 다루는지, 그리고 Next.js에서 이로인해 발생할 수 있는 에러와 해결방법에 대해 알아보자.","tags":["react","next.js","deepdive","SSR","Suspense","렌더링"],"content":"\r\n## 들어가며\r\n프론트엔드에서 React와 Next.js에서는 비동기 로직과 데이터 페칭을 효율적으로 관리하기 위해 **Suspense**를 활용한다. \r\n\r\nReact 18부터 본격적으로 Suspense를 활용하여 관련된 로직을 수행할 수 있는데, React에서 Suspense를 어떻게 사용하는지 알아보고, Next.js에서는 13이상 부터 **자동화된 Suspense**에 대해, 그리고 이로 인해 발생한 에러와 해결방법에 대해 알아볼 것이다.\r\n\r\n## React의 Suspense\r\nReact의 **Suspense**는 비동기 로직이 완료될 때까지 대기 상태를 처리한다. 데이터 로딩, 컴포넌트 코드 스플리팅 등을 위해 주로 사용되며, 다음과 같은 방식으로 동작한다\r\n\r\n#### **Suspense 기본 동작 (React 18 이상)**\r\n\r\n1.  `Suspense`는 컴포넌트 트리의 일부에서 데이터를 로드하거나 리소스를 가져오는 작업이 끝날 때까지 렌더링을 중단한다.\r\n2.  `fallback` 프로퍼티에 지정된 컴포넌트를 먼저 렌더링한다.\r\n3.  작업이 완료되면 `Suspense` 아래의 실제 콘텐츠를 렌더링한다.\r\n\r\n```js\r\nimport React, { Suspense } from 'react';\r\n\r\nconst LazyComponent = React.lazy(() =\u003e import('./LazyComponent'));\r\n\r\nexport default function App() {\r\n  return (\r\n    \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\r\n      \u003cLazyComponent /\u003e\r\n    \u003c/Suspense\u003e\r\n  );\r\n}\r\n\r\n```\r\n이런식으로 명시적으로 Suspense를 배치하여 이를 제어한다.\r\n\r\n`React.lazy`는 컴포넌트를 지연로딩할 때 사용되며 컴포넌트를 처음렌더링 할 때까지 로드하지 않는다.\r\n\r\n대신, 해당 컴포넌트가 실제로 화면에 렌더링될 때, 즉 \"**필요할 때**\" 로드한다.\r\n\r\n이렇게 `React.lazy()`와 `Suspense`를 같이 활용하여 컴포넌트를 지연 로딩하고, 초기 로딩 성능을 개선한다.\r\n\r\n## Next.js에서 자동화된 Suspense\r\n\r\nNext.js 13 이상에서는 App Router를 기반으로 **자동 Suspense**가 도입되었다. React의 Suspense와 비슷한 기능을 제공하되, 일부 동작이 Next.js에 의해 자동화가 된다.\r\n\r\n#### **Next.js 자동 Suspense 동작**\r\n\r\n1.  서버 컴포넌트에서 `fetch`나 비동기 로직을 처리할 때 Suspense가 자동으로 적용된다.\r\n2.  `loading.js`와 같은 특수 파일을 활용하여 Suspense의 `fallback` 역할을 수행한다.\r\n3.  클라이언트 컴포넌트의 경우 별도로 Suspense를 지정해야 동작한다\r\n\r\n즉 서버 컴포넌트에서 미리 비동기로 데이터를 가져올 때,  자동으로 지연 로딩이 되고, 로딩이 되는 동안 loading.tsx를 보여줄 수 있는 것 이다.\r\n\r\n```js\r\n// app/원하는 경로 페이지/page.tsx (서버 컴포넌트) \r\nexport default async function Page() { \r\nconst data = await fetchData(); \r\n\t// 자동 Suspense \r\n\treturn \u003cdiv\u003e{data}\u003c/div\u003e; \r\n}\r\n```\r\n위의 코드는 Next.js의 서버 컴포넌트에서 데이터를 서버 단에서 미리 불러 올 때의 예제이다. 만일 loading.tsx를 만들면 이렇게 서버에서 미리 데이터를 불러오는 동안 사용자에게 로딩 중 컴포넌트를 보여줄 수 있다.\r\n\r\n```js\r\n// app/원하는-경로-페이지/loading.tsx \r\nexport default function Loading() {\r\n return \u003cdiv\u003eLoading...\u003c/div\u003e; \r\n // 간단한 로딩 상태 \r\n }\r\n```\r\n이러한 경우 원하는 경로의 페이지에 접속하는 동안 loading.tsx를 볼 수 있다.\r\n\r\n## Next.js에서 React의 Suspense를 같이 써보자\r\n\r\nNext.js에서 내재되어있는 서버 컴포넌트에서 미리 데이터를 페칭할 때 자동으로 사용되는 Suspense 기능 뿐 아니라, 그 컴포넌트 안에서 react의 Suspense 역시 사용할 수 있다.\r\n\r\n다음 예제를 보자.\r\n```js\r\nimport { Suspense } from 'react';\r\nimport dynamic from 'next/dynamic';\r\n// 비동기 컴포넌트\r\nconst LazyComponent = dynamic(() =\u003e import('./LazyComponent'), { suspense: true, // Suspense를 사용하려면 이 설정이 필요하다. });\r\n\r\nexport default function Page() {\r\nconst data = await fetchData();\r\n  return (\r\n    \u003cdiv\u003e\r\n      \u003ch1\u003eServer Side Rendered Data\u003c/h1\u003e\r\n      \u003cdiv\u003e{data}\u003c/div\u003e\r\n\r\n      \u003cSuspense fallback={\u003cdiv\u003eLoading...\u003c/div\u003e}\u003e\r\n        \u003cLazyComponent /\u003e\r\n      \u003c/Suspense\u003e\r\n    \u003c/div\u003e\r\n  );\r\n}\r\n```\r\n\r\n`next/dynamic`은 **Next.js**에서 제공하는 **동적 import** 기능이다. 이 기능을 사용하면 클라이언트 사이드에서 컴포넌트를 **지연 로딩**(Lazy Loading) 할 수 있으며, **서버 사이드 렌더링(SSR)**을 제어할 수 있다. \r\n\r\n즉 **비동기 로딩**을 통해 성능 최적화와 코드 분할을 지원하는 것이다.\r\n\r\n`next/dynamic`에는 여러 옵션이 있는데\r\n\r\n- suspense :**React Suspense** 기능과 통합하여, 동적 컴포넌트 로딩 중에 fallback UI를 표시할 수 있다.\r\n - loading:  \r\n\t  ```js \r\n\t  const LazyComponent = dynamic(() =\u003e import('./LazyComponent'), {\r\n\t  \t\tloading: () =\u003e \u003cdiv\u003eLoading...\u003c/div\u003e, \r\n\t  \t\t});\r\n\t  \r\n\t ```\r\n\t 이렇게 직접 로딩 컴포넌트를 지정할 수도 있다.\r\n- ssr: `next/dynamic`에서는 이 동적 로딩 컴포넌트가 **서버 사이드 렌더링**에서 제외될 수 있도록 `ssr: false` 옵션을 사용하여 클라이언트 사이드에서만 컴포넌트를 로드할 수 있게 한다. (이 부분으로 에러를 해결하는 포스트를 추후 쓸 것이다.)\r\n\r\nLazyComponent가 볼륨이 높은 페칭 작업을 한다고 가정했을 때 Suspense를 사용하여 데이터를 가져오는 동안 fallback 컴포넌트를 보여줄 수 있다.\r\n\r\n즉, 위의 코드에서 Suspense가 어떻게 작동하는 지 정리해보자면\r\n\r\n- 서버 단에서 데이터를 페칭하여 미리가져오고, 그 데이터를 가져오는 시간 동안 loading.tsx의 컴포넌트를 보여준다.\r\n-  데이터를 가져와서 페이지가 로드된후 Suspense로 감싸준 클라이언트 단의 **LazyComponent에서 작업을 하는 동안** **fallback 컴포넌트를 보여준다.**\r\n-  LazyComponent의 작업이 완료되면 본래 컴포넌트를 보여준다.\r\n\r\n## 마치며\r\n React와 Next.js에서 Suspense를 어떻게 쓸 수 있는지에 대해서, 그리고 next.js에서 두개를 같이 쓰는 예제까지 살펴보았다. 개발 하며 앞으로 보다 나은 사용자 경험과 최적화를 위해 유용하게 사용할 수 있을 듯하다."}]},"__N_SSG":true},"page":"/posts/tag/[tag]","query":{"tag":"Suspense"},"buildId":"NEdP3VXn9r1vgkE0HJoJ2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
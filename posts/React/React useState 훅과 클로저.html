<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>React useState 훅과 클로저</title><meta name="description" content="클로저를 이용한 React useState 훅의 작동 원리를 이해해보자"/><meta property="og:title" content="React useState 훅과 클로저"/><meta property="og:description" content="클로저를 이용한 React useState 훅의 작동 원리를 이해해보자"/><meta property="og:image" content="https://phnml1.github.io/posts/React/React useState 훅과 클로저/index.png"/><meta property="og:url" content="https://phnml1.github.io/posts/React/React useState 훅과 클로저"/><meta property="og:type" content="article"/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/cea7fc6ccc7bac98.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/cea7fc6ccc7bac98.css" crossorigin="" data-n-g=""/><link rel="preload" href="/_next/static/css/570acc098c248c2f.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/570acc098c248c2f.css" crossorigin="" data-n-p=""/><link rel="preload" href="/_next/static/css/0407c34f82b3c3db.css" as="style" crossorigin=""/><link rel="stylesheet" href="/_next/static/css/0407c34f82b3c3db.css" crossorigin="" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" crossorigin="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-6f336cc197ef678d.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/framework-66d32731bdd20e83.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/main-aa55ffd08992d156.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/_app-e287481ee6e74633.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/135-4ea70e0295549ad8.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/393-7217afb82985f4a5.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/979-7390dd4fc9e19803.js" defer="" crossorigin=""></script><script src="/_next/static/chunks/pages/%5B...detail%5D-02480a8ad940e022.js" defer="" crossorigin=""></script><script src="/_next/static/yWUDH0Dw2stFrx7cHXhyt/_buildManifest.js" defer="" crossorigin=""></script><script src="/_next/static/yWUDH0Dw2stFrx7cHXhyt/_ssgManifest.js" defer="" crossorigin=""></script></head><body><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if('system'===e||(!e&&true)){var t='(prefers-color-scheme: dark)',m=window.matchMedia(t);if(m.media!==t||m.matches){d.style.colorScheme = 'dark';c.add('dark')}else{d.style.colorScheme = 'light';c.add('light')}}else if(e){c.add(e|| '')}if(e==='light'||e==='dark')d.style.colorScheme=e}catch(e){}}()</script></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"post":{"slug":"posts/React/React useState 훅과 클로저","title":"React useState 훅과 클로저","date":"2024-10-26T18:00:24.000Z","image":"index.png","summary":"클로저를 이용한 React useState 훅의 작동 원리를 이해해보자","tags":["react","JavaScript","deepdive","useState","hook","클로저"],"content":"# React useState 훅과 클로저\r\n\r\n클로저에 대해 개념은 알고 있었지만, 사실 면접 질문때나 쓰이는 것이고, 실제로 어떻게 쓰이는지에 대해서는 와닿지 못한 부분도 있었다. 그러던 도중 react deep dive를 공부하며, react 개발자가 아마도 가장 많이 사용하는 **useState**에 클로저가 쓰인다는 사실을 알았다! \r\n어떻게 쓰이는 지 함께 살펴보자.\r\n\r\n\r\n\r\n## 상태값을 어떻게 관리할까\r\n보통 useState의 기본 사용법은 다음과 같을 것이다\r\n```js\r\nimport { useState } from 'react'\r\n\r\nconst [state, setState] = useState\r\n```\r\n인수로 state의 초깃값을 넘겨주고, 만일 아무것도 안넘겨주면 초깃값은 undefined일 것이다.\r\n훅의 반환 값은 배열이고, 배열의 첫 번째 원소는 state 값 자체이며, 두 번째 원소는 setState 함수를 통해 해당 state 값을 변경할 수 있다.\r\n\r\n\r\n**리액트에서 렌더링은 함수 컴포넌트의 return을 실행한 다음, 실행 결과를 이전의 리액트 트리와 비교해 리렌더링이 필요한 부분만 업데이트해 이뤄진다.**\r\n그렇기 때문에 렌더링 방식이랑 메커니즘이 다른 변수를 통해서 상태값을 관리하는 것은 적절하지 못하다. (이전 글 react virtualDOM 참고)\r\n\r\n그렇다면 다음 코드를 살펴보자.\r\n\r\n```js\r\nimport React from 'react'\r\n\r\nconst Component = () =\u003e {\r\n  const [,triggerRender] = useState()\r\n  let state = 'hello'\r\n\r\n  function handleButtonClick() {\r\n    state = 'hi'\r\n    triggerRender()\r\n  }\r\n  return (\r\n    \u003c\u003e\r\n      \u003ch1\u003e{state}\u003c/h1\u003e\r\n      \u003cbutton onClick={handleButtonClick}\u003ehi\u003c/button\u003e\r\n    \u003c/\u003e\r\n  )\r\n}\r\n```\r\nuseState 반환값의 두 번째 원소를 실행해 리액트에 렌더링이 일어나게끔 변경했다. \r\n그럼에도 여전히 버튼 클릭시 state의 변경된 값이 렌더링되고 있지 않다. \r\n\r\n그 이유는 리액트의 렌더링은 **함수 컴포넌트에서 반환한 결과물인 return의 값을 비교해 실행되기 때문이다.** \r\n\r\n즉, 매번 렌더링이 발생할 때마다 함수는 새롭게 실행이 되고, 실행한 함수에서 state는 매번 hello로 초기화 되므로 아무리 state를 변경해도 hello로 초기화 되는 것이다. \r\n\r\n근데 렌더링이 될 때마다 초기화되는 변수(값)와는 달리, useState의 결과값은 어떻게 그 값을 유지할까?\r\n\r\nuseState의 결과 값이 유지되도록, state를 함수로 하여 state 값을 호출할 때마다 현재 state를 반환하게 해보자.\r\n```js\r\nfunction useState(initialValue) {\r\n\tlet initialState = initialValue;\r\n\t\r\n\tfunction state() {\r\n\t\treturn initialState\r\n\t}\r\n\tfunction setState(newValue) {\r\n\t\tinitialState = newValue\r\n\t}\r\n\treturn [state, setState];\r\n}\r\nconst [value, setState] = useState(0);\r\nsetValue(1);\r\nconsole.log(value()); // 1\r\n```\r\n위의 코드도 나쁘진 않지만, 우리에게 익숙한 useState훅은 state를 함수가 아닌 상수처럼 사용하고 있다.\r\n\r\n## 클로저를 이용해 상태를 관리하는 useState\r\n이를 위해서 리액트는 **클로저**를 이용한 것이다. \r\nuseState는 클로저를 통해 useState 내부의 선언된 함수(setState)가 함수의 실행이 종료된 이후(useState가 호출된 이후)에도 지역변수인 state를 계속 참조할 수 있다.\r\n\r\nuseState 작동 방식을 대략적으로 흉내 낸 코드는 다음과 같다.\r\n\r\n```js\r\nconst MyReact = (function() {\r\n\tconst global = {}\r\n    let index = 0\r\n    \r\n    function useState(initialState){\r\n    \tif(!global.states) {\r\n    \t// 애플리케이션 전체의 states 배열 초기화, 최초 접근이면 빈 배열로\r\n        \tglobal.states = []\r\n        }\r\n        // states 정보를 조회해서, 현재 상태값이 있는지 확인\r\n        // 없다면 초깃값으로 설정\r\n        const currentState =  global.states[index] || initialState\r\n        // 위에서 조회한 값으로 states의 값 업데이트\r\n        global.states[index] = currentState\r\n        \r\n        // 즉시실행함수로 setter 만듬\r\n        const setState = (function() {\r\n        \t// 클로저로 index를 가둬두어서 동일한 index에 접근이 가능\r\n        \tlet currentIndex = index\r\n            return function(value){\r\n            \tglobal.states[currentIndex] = value\r\n                //컴포넌트 렌더링이 들어가는 부분이다.(실제 코드는 생략)\r\n            }\r\n    })()\r\n    // useState를 쓸 때마다 index를 하나씩 추가하는데, 이는 하나의 state마다\r\n    // index가 할당되어있어, 그 index가 배열의 값(global.states)를 가리키고,\r\n    // 필요할 때마다 그 값을 가져오게 하는 것이다.\r\n    index = index + 1\r\n        \r\n    return [currentState,setState]\r\n}\r\n\r\nfunction Component() {\r\n\tconst [value, setValue] = useState(0);\r\n}\r\n})();\r\n```\r\n\r\n실제 리액트 코드에서는 useReducer를 이용해 구현되어 있어 약간의 차이가 있다.\r\n\r\n아무튼 여기서 함수의 실행이 끝났음에도 함수가 선언된 환경을 기억할 수 있는 방법이 바로 클로저인 것이다. 만약 클로저가 없다면, `setState`는 항상 `index`의 현재 값에 의존하게 된다. 즉, 컴포넌트가 여러 상태를 갖고 있을 때 마지막 `index`만 참조하므로, `setState`가 올바른 위치를 참조하지 않게 되는 것이다.\r\n\r\n매번 실행되는 함수 컴포넌트 환경에서 state의 값을 유지하고 사용하기 위해 리액트는 클로저를 활용하고 있다.\r\n\r\n`\r\n훅에 대한 구현체를 github에서 타고 올라가다보면 __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED 라는 문구를 만나게된다(무섭다 ㅋㅋ)\r\n위의 코드는 Preact의 구현을 기준으로 하고 있다. Preact는 react의 경량화 버전으로,\r\n대부분의 리액트 API를 지원하고 있다. \r\n`\r\n## 결론\r\nReact의 `useState`는 클로저를 통해 상태값을 안정적으로 유지하며, 함수 컴포넌트가 여러 번 호출되더라도 **각 상태값이 고유한 위치에 저장**될 수 있게 한다. `useState`가 반환하는 `setState` 함수는 생성 당시의 상태 위치(`index`)를 클로저로 캡처하여, 해당 상태값만 정확히 업데이트하도록 구현되어 있다.\r\n\r\n정리하자면, 클로저는 `setState`가 함수가 선언된 당시의 환경을 유지하게 해주기 때문에 **컴포넌트가 매번 재실행될 때마다 상태가 초기화되는 것을 방지**하고, 상태가 올바르게 유지될 수 있게 해준다.\r\n\r\n**참고**\r\n\r\n[서적] 모던 리액트 Deep Dive\r\n","readingMinutes":8},"category":"React","prevData":{"title":"클로저에 대하여","slug":"posts/Javascript/클로저에 대하여","summary":"자바스크립트의 어렵지만 중요한 클로저의 개념과 활용 이해해보자"},"nextData":{"title":"자바스크립트 딥다이브: 09.타입 변환과 단축평가","slug":"posts/Javascript/javascriptdeepdive09","summary":"자바스크립트 딥다이브 책 내용 중 '타입 변환과 단축평가'의 정리 내용입니다."}},"__N_SSG":true},"page":"/[...detail]","query":{"detail":["posts","React","React useState 훅과 클로저"]},"buildId":"yWUDH0Dw2stFrx7cHXhyt","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>
{"pageProps":{"tags":["react","테스트","deepdive","next.js","렌더링","트러블슈팅","dev tools","SSR","SSG","Algorithm","프로그래머스","PCCP","lv2","이분탐색","JavaScript","useState","hook","클로저","생명주기","Virtual DOM","백준","gold","dfs","lv3","bfs"],"currentTag":"렌더링","posts":[{"slug":"posts/React/React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험","title":"React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험","date":"2024-11-11T17:00:24.000Z","image":"index.png","summary":"React 개발자 도구(React dev tools)의 기능들과 이를 활용해본 경험을 공유해보겠다.","tags":["react","next.js","렌더링","트러블슈팅","deepdive","dev tools"],"content":"\r\n# React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험\r\n\r\n## 들어가며\r\n\r\nReact Deep dive를 스터디에서 공부하며 리액트 앱을 디버깅하고 검사할 때 보다 효율적으로 할 수 있는 도구인, **React dev tools**(React 개발자 도구)라는 것을 처음 접하게되었다.\r\n이번 포스팅에서는 React 개발자 도구의 각종 기능에 대해 설명한 후, 이것을 통해 본인의 블로그의 페이지에서 본래 모르고 있었던 지속적으로 발생하고 있던 불필요한 렌더링을 없앤 경험도 공유하고자 한다.\r\n\r\n## React Dev tools란?\r\nReact 애플리케이션을 디버깅하고 최적화하는 데 도움을 주는 브라우저 확장 도구이다. 브라우저의 확장 프로그램으로써 설치하면 사용할 수 있다.  \r\n\r\n참고로 React app의 development모드에서만 원활하게 모든 기능을 사용할 수 있으며 production 모드로 빌드되었을시에는 profiler 기능은 비활성화된다.\r\n <img src=\"2.png\" alt=\"nextjs\" width = '40' height = '40'/>\r\n만일 production 빌드시에는 이런식으로\r\n이 도구를 사용할 수 있을 때는 \r\n<img src=\"1.png\" alt=\"nextjs\" width = '40' height = '40'/>\r\n이런식으로 색깔이 들어오게 된다.\r\n\r\n그럼 React dev tools의 기능들인 **Components**, **Profiler** 탭을 보는 방법에 대해서 함께 알아보자\r\n\r\n## Components\r\nComponents 탭에서는 현재 리액트 애플리케이션의 컴포넌트 트리를 확인할 수 있으며, 단순히 구조 뿐만이 아니라, props와 내부 hooks 등 다양한 정보를 확인할 수 있다.\r\n### Components 탭의 기능\r\n- 컴포넌트 트리의 전체적인 구조를 확인할 수 있다.\r\n <img src=\"3.png\" alt=\"nextjs\"/>\r\n- 보통 state, props의 값을 브라우저에서 확인 하려면 `console.log(...)`이런식으로 로그를 출력하여 확인하는데 컴포넌트 탭에서는 특정 컴포넌트를 그 안에 있는 state, props의 값을 확인할 수 있다.\r\n <img src=\"4.png\" alt=\"nextjs\"/>\r\n- 또한 단지 state, props 뿐만 아니라 컴포넌트에서 사용된 훅을 볼 수 있는 hooks 도 있는걸 볼 수 있다.\r\n\t- state : useState\r\n\t- Reducer: useReducer\r\n\t- Context: useContext\r\n\t- Callback: useCallback\r\n\t- Ref: useRef\r\n\t- id: useId\r\n\t- LayoutEffect: useLayoutEffect\r\n\t- Effect: useEffect\r\n\t- 그외의 사용자 훅: use가 빠진채로 보여짐( ex. useCounter면 Counter로)\r\n - 또한 rendered by를 통해 해당 컴포넌트를 렌더링한 부모컴포넌트까지 확인할 수 있다.\r\n- 벌레 모양의 버튼을 클릭하면 `log this component data to the console`이라는 문자가 뜨는데 이걸 클릭하면 컴포넌트의 관한 데이터를 콘솔에 찍어볼 수 있다.\r\n \t<img src=\"5.png\" alt=\"nextjs\"/>\r\n\t\t콘솔에 컴포넌트의 정보가 나타난다.\r\n \t<img src=\"6.png\" alt=\"nextjs\"/>\r\n\r\nComponents탭의 대표적인 기능들만을 소개했지만, 이외에도 직접 에러를 발생시킨다거나, 컴포넌트의 state, props값을 임의로 바꿔본다든가 등의 기능 역시 사용할 수 있다.\r\n\r\n## Profiler\r\n프로파일러는 리액트가 렌더링하는 과정에서 발생하는 상황을 확인하기 위한 도구다. 즉 리액트 애플리케이션이 렌더링되는 과정에서 어떤 컴포넌트가 렌더링됐는지, 또 몇 차례나 렌더링이 일어났으며 어떤 작업에서 오래 걸렸는지와 같은 것을 확인할 수 있다.\r\n\r\n### 프로파일링 시작하기\r\n처음 프로파일러 탭을 열고, \r\n첫번째 버튼 \"🔵\" 버튼을 누르면 기록이 진행된다. 기록을 시작하면 렌더링 관련 정보들이 자동으로 수집되며, 🔴 버튼을 누르면 수집이 중단되고 결과가 나타난다.\r\n\r\n두번째 버튼을 누르면 새로고침 후 동시에 프로파일링이 시작된다 마찬가지로 첫번째 버튼이 🔴로 바뀌며, 이를 누르면 프로파일링이 중단되고, 결과가 나타난다. \r\n\r\n### Flame Chart\r\n <img src=\"7.png\" alt=\"nextjs\"/>\r\nFlame Chart는 특정 커밋에 대한 애플리케이션 상태를 보여준다. \r\n차트의 각 막대는 컴포넌트들을 뜻하며 너비가 넓을 수록 해당 컴포넌트를 렌더링 하는데 오래 걸렸다는 것을 의미한다.\r\n\r\n각 컴포넌트에 마우스를 가져다 대면 해당 컴포넌트의 렌더링과 관련된 정보를 확인할 수 있다. \r\n\r\n또한 오른쪽위의 화살표 혹은 막대 그래프를 누르면 각 렌더 커밋별로 리액트에서 발생한 렌더링 정보와 발생한 횟수를 확인할 수 있어 의도한 횟수만큼 렌더링이 발생했는지도 알 수 있다.\r\n\r\n### Ranked\r\n해당 커밋에서 렌더링하는데 오랜시간이 걸린 컴포넌트를 순서대로 나열한 그래프이다.\r\n <img src=\"8.png\" alt=\"nextjs\"/>\r\nFlamegraph와의 차이점은 모든 컴포넌트가 아닌 단순히 렌더링이 발생한 컴포넌트만 보여준다는 것이다.\r\n\r\n### TimeLine\r\n <img src=\"9.png\" alt=\"nextjs\"/>\r\n리액트 18이상의 환경에서만 확인할 수 있으며, 시간의 흐름에 따라 리액트가 작동하는 내용을 추적하는데 유용하다. 시간 단위로 프로파일링 기간동안 무슨 일이 있었는지 무엇이 렌더링됐고, 어느 시점에 렌더링됐는지 등에 대해 자세히 확인할 수 있다.\r\n\r\n## 이를 직접  활용하여 불필요한 렌더링 줄여본 경험\r\n### 문제 상황\r\n내 블로그 페이지에는 글을 검색할 수 있는 SearchPage가 있다.\r\nprofiler 탭에서 프로파일링을 시작하고 검색어 입력창에 키워드를 입력하고, 프로파일링을 끝내 보았는데, 문제가 발견되었다.\r\n <img src=\"10.png\" alt=\"nextjs\"/>\r\n <img src=\"11.png\" alt=\"nextjs\"/>\r\n검색어를 입력만 했는데 검색어에 따른 포스트들을 보여주는 `PostItem`을 제외하고 이와 관련없는 NavBar, Footer 등 페이지의 모든 요소가 함께 렌더링이 되고 있었다. Ranked로 보니까 시간 역시 제법 차지 하고 있었다.\r\n\r\n또한 검색페이지 뿐만이 아니더라도 카테고리 선택 페이지에서도 마찬가지로 카테고리만 선택했는데도 이와 같은 현상으로 불필요하게 렌더링이 발생하고 있었다.\r\n\r\n... 왜 이런지 Components 탭으로 Header와 Footer와 같은 컴포넌트를 포함하는 컴포넌트인 **Layout 컴포넌트**의 정보를 보니 다음과 같았다.\r\n\r\n그 전에 참고: Layout 컴포넌트 코드 (모달창, 헤더, 푸터등을 관리한다.)\r\n```js\r\nexport default function Layout({ children }: React.PropsWithChildren) {\r\n  const [sidebar,setSideBar] = useState(false);\r\n\t// 사이드바에 관한 useEffect 코드들 (생략)\r\n\treturn (\r\n\t\t\t<Providers>\r\n\t\t\t\t<main\r\n\t\t\t\t\tclassName={cls(\r\n\t\t\t\t\t\tnotoSansKr.className,\r\n\t\t\t\t\t\topensans.variable,\r\n\t\t\t\t\t\tkanit.variable,\r\n\t\t\t\t\t\t'w-full relative flex flex-col items-center dark:bg-dark-primary dark:text-dark-primary transition-[background]',\r\n\t\t\t\t\t)}\r\n\t\t\t\t>\r\n\t\t\t\t\t<Navbar setSideBar = {setSideBar}/>\r\n\t\t\t\t\t<div className=\"w-full flex flex-col items-center\">{children}</div>\r\n\t\t\t\t\t{sidebar && (<SideBar setSideBar={setSideBar}/>)}\r\n\t\t\t\t\t<Footer />\r\n\t\t\t\t</main>\r\n\t\t\t</Providers>\r\n\t\t);\r\n}\r\n\r\n```\r\n**Layout 컴포넌트 정보**\r\n  <img src=\"12.png\" alt=\"nextjs\"/>\r\nrendered by PostSearchPage... 참고로 **PostSearchPage의 컴포넌트 정보**는 다음과 같다.\r\n  <img src=\"13.png\" alt=\"nextjs\"/>\r\n1번째 State인 검색결과,  2번째 State인 검색 키워드 까지 여기서 관리되고 있었기에 당연히 검색을 할 때마다 PostSearchPage이 렌더링되고 이에 따라 **자식 컴포넌트인 Layout역시 같이 렌더링**이 되는 것 이었다.\r\n\r\nPostSearchPage의 코드를 보면,\r\n```js\r\nexport  default  function  PostSearchPage(props: {posts:Post[]}) {\r\n\tconst [posts,setPosts] =  useState<Post[]>(props.posts);\r\n\tconst [keyword,setKeyword] =  useState<string>('');\r\n\tuseEffect(()=>{\r\n\t\tconst  filteredPosts:Post[] =  searchPosts(props.posts,keyword);\r\n\t\tsetPosts(filteredPosts);\r\n\t},[keyword, props.posts]);\r\n\treturn (\r\n\t<Layout>\r\n\t\t<div  className='w-full mt-8 md:w-4/5 px-8'>\r\n\t\t\t<SearchInput  keyword={keyword}  setKeyword  =  {setKeyword}/>\r\n\t\t</div>\r\n\t\t{/* 검색결과를 보여주는 레이아웃 */}\r\n\t\t<PostLayout  posts={posts}  currentCategory={keyword}  theme='search'/>\r\n\t</Layout>\r\n\t);\r\n}\r\n```\r\nLayout이 자식으로 있는걸 볼 수 있다.\r\n\r\n### 해결 방법\r\n\r\n이에 대한 해결 방법으로 물론, `Layout`을  메모이제이션을 통해서 변경이 발생할 때만 렌더링 되도록 최적화 할 수도 있지만, `Layout` 컴포넌트가 모든 페이지에서 공통으로 사용되고, `Layout` 자체에서 각 페이지에 의존하는 상태가 없는 점을 고려하여 `_app.tsx`에서 이를 최상위 레이아웃으로 설정하는 것이 더 적절해 보였다.\r\n\r\n> Next.js의 page router에서 `_app.tsx` 파일은 애플리케이션 전체의 최상위 컴포넌트를 정의하는 역할을 한다.\r\n\r\n_app.tsx\r\n```js\r\nexport  default  function  App({ Component, pageProps }:  AppProps) {\r\n\treturn (\r\n\t\t<ThemeProvider  attribute='class'  >\r\n\t\t\t<Layout>\r\n\t\t\t\t<Component  {...pageProps}  />\r\n\t\t\t</Layout>\r\n\t\t</ThemeProvider>\r\n\t);\r\n}\r\n```\r\n변경된 PostSearchPage의 return문\r\n```js\r\nreturn (\r\n<>\r\n\t<div  className='w-full mt-8 md:w-4/5 px-8'>\r\n\t\t<SearchInput  keyword={keyword}  setKeyword  =  {setKeyword}/>\r\n\t</div>\r\n\t{/* 검색결과를 보여주는 레이아웃 */}\r\n\t<PostLayout  posts={posts}  currentCategory={keyword}  theme='search'/>\r\n</>\r\n);\r\n```\r\n\r\n이와같이 변경하고 다시 프로파일링을 해보니\r\n <img src=\"14.png\" alt=\"nextjs\"/>\r\nLayout이 더이상 렌더링이 되지않고, 당연히 그전에 불필요하게 렌더링 되었던 Navbar와 Footer도 렌더링이 되지않는다! \r\n\r\n## 마치며\r\n지금까지 React Devtools의 기능에 대해 알아보고, 필자가 이를 이용해서 본인의 블로그에서 발생되는 불필요한 렌더링을 없앤 경험까지 소개해보았다.\r\n\r\n후후.. 지나가는 형님들은 이걸 보며 '뭐야 이 바보는 당연한거 아닌가' 라고 생각할 수도 있겠지만 지금까지 '구현만 되어라' 만 생각했던 구현충인 내가 나름 처음으로 한 최적화? 경험이기에 조금 뿌듯했다. \r\n\r\n그리고 React Devtools를 사용하며 기능 자체는 좋았는데, 뭐가 문제인진 모르겠는데 자꾸 중간에 멈추고 먹통이 되어서 짜증났다. 해결되기 전까지는 chrome 개발자 도구 사용하련다. "},{"slug":"posts/React/서버사이드 렌더링에 대해 알아보자","title":"서버사이드 렌더링에 대해 알아보자(Feat: next.js, SSG)","date":"2024-11-03T22:00:24.000Z","image":"index.png","summary":"클라이언트 사이드 렌더링(CSR)과 서버 사이드 렌더링(SSR)에 대해서 그리고 SSR을 활용한 next.js 예제와 SSG의 개념과 예제까지 알아보자.","tags":["react","next.js","deepdive","SSR","SSG","렌더링"],"content":"\r\n프론트엔드를 공부하노라면 **SPA**(Single Page Application)와  **CSR**(Client Side Rendering)과 **SSR(Server Side Rendering)**에 대해 한번 씩 이라도 들어보았을 것 이다.\r\n\r\n하지만 개념이 확실히 안잡힐 때가 있고, 뭐를 써야 더 좋은지도 모를 때도 많다.\r\n\r\n이번 포스팅에서는 SPA,CSR에 대해 간단히 알아본 후, **SSR**에 대해서 보다 더 자세히 개념과  이것이 쓰이는 Next.js 코드 예제에 대해서도 살펴볼 것이다. \r\n\r\n그리고 더 나아가 정적 데이터를 미리 로드하는**SSG**(Static Site Generation)에 대해서도 알아볼 것이다.\r\n\r\n## 그 전에 SPA란?\r\n\r\n**싱글 페이지 애플리케이션(SPA)**은 SSR(Server-Side Rendering)과 다른 렌더링 방식인 **CSR(Client-Side Rendering)**을 주로 사용하여 서버가 아닌 브라우저에서 페이지를 렌더링하고 전환한다.\r\n\r\nSPA는 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 **브라우저의 JavaScript에 의존하는 방식**인 CSR을 사용하여 구현된다. \r\n\r\nSPA에서는 주로 CSR을 사용하여 처음 페이지를 로드할 때 필요한 데이터를 한 번에 받아오고, 이후에는 서버에서 HTML을 새로 내려받지 않고 **하나의 페이지에서 모든 작업을 처리하기 때문에** **싱글 페이지 애플리케이션(SPA)**이라고 불리는 것이다.\r\n```html\r\n<body><noscript>You need to enable JavaScript to run this app.</noscript><div id=\"root\"></div></body></html>\r\n```\r\n위의 SPA를 사용하는 HTML소스를 보면  HTML 코드의 `body` 내부가 비어 있다. \r\n\r\n이는 사이트 렌더링에 필요한 body 내부의 내용을 모두 **자바스크립트 코드**로 삽입한 후에 렌더링하기 때문이다. .\r\n\r\nCSR을 사용하는 SPA는 한번 로딩된 이후에는 페이지 전환 속도가 빠르고 사용자와의 상호작용이 부드럽다는 장점이 있지만, 최초의 로딩해야 할 자바스크립트 리소스가 커진다는 것 그리고 그로 인해 초기 로딩 속도가 길어진다는 단점이 있다.\r\n\r\n## SSR\r\n싱글 페이지 애플리케이션이 자바스크립트를 활용해 하나의 페이지에서만 렌더링을 수행한다면 서버 사이드 렌더링은 **최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식**이다.\r\n\r\n즉 앞서 살펴보았던 CSR과 SSR의 차이는 웹페이지 렌더링의 책임을 어디에 두느냐인데,  CSR을 사용하는 SPA는 사용자에게 제공되는 자바스크립트 번들에서 렌더링을 담당하지만, SSR을 채택하면 렌더링에 필요한 작업을 모두 서버에서 수행한다. \r\n\r\n클라이언트 렌더링은 사용자 기기의 성능에 영향을 받지만, 서버 사이드 렌더링은 서버에서 제공하기 때문에 안정적인 렌더링이 가능하다.\r\n\r\n## SSR의 장단점\r\n### 장점\r\n- 최초 페이지 진입이 비교적 빠르다.\r\n\t\r\n\t최초 페이지 진입 시 페이지에 유의미한 정보가 그려지는 시간인 FCP(First Contentful Paint)가 SPA에 비해 더 빨라질 수 있다. 다만, 서버가 사용자에게 렌더링을 제공할 수 있는 충분한 리소스가 확보되어 있다라는 가정하에 비교한 것이다.\r\n\t\r\n- 검색 엔진과 SNS 공유 등 메타 데이터 제공이 쉽다.\r\n\t\r\n\t검색 엔진 로봇이 페이지의 정보를 가져올 때 HTML을 다운로드 하는데, 단, **이 때 자바스크립트 코드는 실행하지 않는다.** \r\n\r\n\t다운로드한 HTML 페이지 내부의 오픈 그래프(Open Graph)나 메타(meta) 태그 정보를 \t기반으로 페이지의 검색 정보를 가져오고, 이를 바탕으로 검색 엔진에 저장한다.\r\n\r\n\t서버사이드 렌더링을 사용하면 최초의 렌더링 작업이 서버에서 일어난다. 즉 검색 엔진에서 제공할 정보를 서버에서 가공하여 HTML 응답으로 제공할 수 있으므로 SEO에 대응하기가 용이하다.\r\n\t\r\n\tSSR을 사용하는 next js에서는 generateMetaData라는 함수를 사용 (14버전 app router기준) 하여 데이터를 미리 페칭하여 동적으로 이와 같이 비교적 쉽게 메타데이터의 내용을 설정할 수도 있다. \r\n\t```js\r\n\t// params는 groupId라고 설정된 페이지의 동적 파라미터를 받아오는 것\r\n\texport  async  function  generateMetadata({params}: {params: {groupId:  string}}) {\r\n\t// 이 params를 통해서 서버에 미리 데이터를 요청한다.\r\n\tconst  response  =  await  fetchGroupData({queryKey: ['groupDetail',Number(params.groupId)]});\r\n\t// 요청한 데이터를 이런식으로 return 하여 head 태그의 title과 description에 넣을 수 있다.\r\n\t\treturn {\r\n\t\t\ttitle:  `${response.name}`,\r\n\t\t\tdescription:  `${response.description}`,\r\n\t\t}\r\n\t}\r\n\t```\r\n\r\n- 누적 레이아웃 이동이 적다.\r\n\t누적 레이아웃 이동은 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥 거리는 것과 같은 부정적인 사용자 경험을 말하는 것이다. \r\n\r\n\tapi요청이 다 완료된 이후에 완성된 페이지를 제공하는 서버 사이드 렌더링은 이러한 문제에서 비교적 자유롭다.\r\n\r\n- 사용자의 디바이스 성능에 비교적 자유롭다.\r\n\t- 서버와 함께 데이터를 로드하는 부담을 나누므로, 보다 사용자 디바이스 성능에 자유롭다.\r\n\r\n### 단점\r\n- 소스코드를 작성할 때 항상 서버를 고려해야 한다.\r\n\r\n\twindow 또는 sessionStorage와 같은 브라우저 전역 객체에 접근하는 코드는 서버에서 실행될 수 없어 이를 고려 해야 하고, 외부 라이브러리 역시 서버에 대한 고려를 해야만한다.\r\n- 적절한 서버가 구축되어있어야 한다.\r\n\r\n\t서버 사이드 렌더링은 말 그대로 사용자의 요청을 받아 렌더링을 수행할 서버가 필요하므로, 사용자의 요청에 따라 적절히 대응하는 것, 예기치 못한 장애상황에 대응하는 전략도 필요하다\r\n- 서비스 지연 문제\r\n\t\r\n\tSPA에서는 최초에 어떤 화면이라도 보여준 상태에서 느린 작업이 수행되기 때문에 '로딩 중'과 같은 것으로 안내하면 되지만, SSR에서는 특히 이 지연 작업이 최초 렌더링에 발생한다면 사용자에게 그 어떤 정보를 제공할 수 없기에, 더 안좋은 사용자 경험을 제공할 수 있다.\r\n\r\n## Next js에서 사용되는 SSR\r\n\r\nReact DeepDive는 Next.js 13을 기준으로 책이 쓰여졌기에 page router의 **getServerSideProps**를 사용하는 것을 next.js의 서버 사이드 렌더링의 예제로 사용하고 있다.\r\n\r\n 해당 함수가 있다면 무조건 페이지 진입 전에 이 함수를 실행한다.\r\n\r\n이 함수는 응답값에 따라 페이지의 컴포넌트에 props를 반환할 수도, 혹은 다른 페이지로 리다이렉트 시킬 수 있다.\r\n```js\r\nimport type {GetServerSideProps} from 'next';\r\n\r\nexport default function Post({post}: {post:Post}) {\r\n\t// 렌더링\r\n}\r\n\r\nexport const getServerSideProps: GetServerSideProps = async (context) => {\r\n\t// /post/[id]와 같은 경로에 있는 id 값에 접근할 수 있다. (여기서 id는 동적 파라미터)\r\n\tconst {\r\n\tquery: {id: ''},\r\n\t} = context\r\n\tconst post = await fetchPost(id.toString());\r\n\treturn {\r\n\t\tprops: {post},\r\n\t}\r\n}\r\n```\r\n\r\nconstext.query.id를 사용하면  /post/[id] 같은 경로에 있는 id 값에 접근할 수 있다. \r\n(ex ) `www.aaa.com/post/12` 면 `12`추출 가능)\r\n\r\n위의 코드는 페이지의 경로의 id에 접근하여 그 값을 파라미터로 받는 데이터 요청 함수(fetchPost)를 통해 데이터를 받고 받은 데이터를 props에 return 하고 있다.\r\n\r\n이렇게 getServerSideProps로 미리 props를 제공하면 페이지의 Post 컴포넌트에 해당 값을 제공하여 이 반환 값을 기반으로 렌더링 한다.\r\n\r\n그렇다면 14버전의 Next.js App router에서는 이를 어떻게 구현할지도 살펴보자.\r\n\r\n```js\r\n// app/post/[id]/page.js\r\n\r\nimport { fetchPost } from '@/lib/api'; // fetchPost 함수는 외부 API 호출 함수라고 가정\r\n\r\nexport default async function Post({ params }) {\r\n  const { id } = params;\r\n  const post = await fetchPost(id); // 데이터를 서버 측에서 가져옴\r\n\r\n  return (\r\n    <>\r\n      <PostInfo title = {post.title} content = {post.content}/>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n14버전 next js은 getServerSideProps와 같은 함수를 쓰는 대신, 컴포넌트를 **클라이언트 컴포넌트**와 **서버 컴포넌트**로 나눈다. \r\n\r\n위의 컴포넌트 Post는 서버 컴포넌트이다. 14버전의 next.js에서는 최상단에 따로 명령어를 쓰지 않으면 컴포넌트를 서버 컴포넌트로 인식한다. \r\n\r\nPost 컴포넌트에서는 페이지 파라미터 값을 통해 데이터를 서버 단에서 가져오고 있다.\r\n우리는 이 데이터를 클라이언트 컴포넌트인 PostInfo에 props로 넘겨줄 것 이다.\r\n\r\n클라이언트 컴포넌트를 사용하고 싶다면 'use client'를 최상단에 쓰면 된다. \r\n```js\r\n'use client'\r\n\r\nexport default async function PostInfo({title, content}) {\r\n\treturn (\r\n\t\t<div> \r\n\t\t\t<h1>{title}</h1> \r\n\t\t\t<p>{content}</p> \r\n\t\t</div>\r\n\t);\r\n}\r\n```\r\nPostInfo는 맨 위에 'use client'를 선언했으므로, **클라이언트 컴포넌트** 이다. 서버 컴포넌트인 Post에서 미리 로드하여 넘겨준 데이터를 props로 받아 화면에 나타내는 역할을 한다.\r\n\r\n이와 같이 Next.js 에서는 여러 API를 사용해서 복잡하게 SSR을 복잡하게 구현해야 하는 react에 비해서 비교적 간단하게 SSR을 구현할 수 있다.\r\n\r\n## + SSG\r\n\r\nSSG(Static Site Generation)는 Next.js에서 페이지를 빌드할 때 미리 HTML 파일로 생성하여 저장해 두고, 사용자가 해당 페이지에 접근할 때 서버 요청 없이 정적 파일을 제공하는 방식이다. \r\n\r\n이는 특히 자주 변경되지 않는 콘텐츠를 가진 블로그와 같은 페이지에서 성능과 SEO 최적화에 유리한 방법이다.\r\n\r\n내 블로그 역시 이와 같은 방식을 사용하고 있는데, Next.js의 page router를 사용하고 있어서 `getStaticProps`와 `getStaticPath`로 SSG를 구현하고 있다.\r\n\r\n- getStaticPaths: 페이지가 접근 가능한 주소를 미리 정의하는 함수이다. 예를 들어, /pages/post/[id]라는 경로가 있고\r\n\t```js\r\n\texport default getStaticPaths = async () => {\r\n\t\treturn {\r\n\t\t\tpaths: [{params: {id: '1'}}, {params: {id:'2'}}],\r\n\t\t\tfallback: false,\r\n\t\t}\r\n\t}\r\n\t```\r\n\t이와 같이 함수가 정의 되어있다면 /post/1과 /post/2 만 접근이 가능하며, 그외의 /posts/3 등은 404를 반환한다. (단, fallback이 true라면 빌드가 되기전까지 fallback 컴포넌트를 보여주고, 그 이후에는 해당 페이지를 보여준다.) \r\n\t\r\n- getStaticProps: 앞에서 정의한 페이지를 기준으로 해당 페이지로 요청이 왔을 때 제공할 props를 반환하는 함수이다. 위에처럼 id가 1과 2로만 제한되므로, fetchPost(1), fetchPost(2)을 기준으로 함수의 응답값을 props의 {post}로 반환한다.\r\n\t```js\r\n\texport const getStaticProps = async ({params}) => {\r\n\t\tconst {id} = params;\r\n\t\tconst post = await fetchPost(id);\r\n\t\t\r\n\t\treturn {\r\n\t\t\tprops: {post}\r\n\t\t}\r\n\t}\r\n\t```\r\n\r\n### 내 블로그에서 사용한 코드\r\n\r\n\r\n```js\r\nexport  function  getStaticPaths() {\r\n\t// 파일들을 모두 받아오고, slug를 추출한다.\r\n\tconst  slugs  =  getAllPosts().map((file:Post) =>  file.slug);\r\n\t// 이 slug들을 경로로 미리 지정한다.\r\n\treturn {\r\n\t\tpaths:  slugs.map((slug:  string) => {\r\n\t\t\r\n\t\t\tconst  detail  =  slug.split('/');\r\n\t\t\t// params에 각각의 경로는 배열로 넘겨줘야 한다. (ex. /posts/detail이면 ['post', 'detail'] 이런 식 으로\r\n\t\t\treturn { params: { detail } };\r\n\t\t}),\r\n\t\tfallback:  false,\r\n\t};\r\n}\r\n```\r\n나의 블로그에서는 getStaticPaths에서는 모든 포스트들의 slug\r\n(slug는 /posts/category/파일명 방식으로 되어있는 파일의 경로로 보면 된다.)를 params로 넘겨주어 경로를 미리 지정했다.\r\n\r\n```js\r\nexport  const  getStaticProps  :GetStaticProps  = ({params}) => {\r\n\r\n\tconst {detail} =  params  as {detail:string[]};\r\n\t// 배열을 다시 문자열로 바꾸고, 여기에 .mdx를 붙인다.\r\n\tconst  detailPath  =  detail.join('/')+'.mdx';\r\n\tconst  postData  =  getPostData(`${detailPath}`);\r\n\r\n\treturn {\r\n\t\tprops: {\r\n\t\t\tpost:  JSON.parse(JSON.stringify(postData)),\r\n\t\t},\r\n\t};\r\n}\r\n```\r\n이후 받아온 params를 사용하여 해당하는 mdx파일을 미리 받아온다.  이를 props로 넘겨주면 페이지에서 이 데이터를 사용할 수 있다.\r\n```js\r\nexport  function  PostDetailPage(props:PostDetailProps) {\r\n\treturn (\r\n\t<>\r\n\t\t<Head>\r\n\t\t\t<title>{props.post.title}</title>\r\n\t\t\t<meta  name=\"description\"  content={`${props.post.summary}`}  />\r\n\t\t</Head>\r\n\t\t<PostDetailLayout  post={props.post} />\r\n\t</>\r\n\t)\r\n}\r\n```\r\nprops로 미리 빌드하여 생성한 데이터를 받아와서 사용하는 모습이다.\r\n(또한 Head태그를 사용하여(page router 기준) 메타데이터 역시 받아온 데이터 정보로 설정하여 SEO에 유리하게 했다.)\r\n\r\n이 두함수를 적절히 설정하고 페이지를 npm run build를 사용했을 때 모습을 보자.\r\n<img src=\"nextjs.png\" alt=\"nextjs\"/>\r\n\r\n앞서 살펴본 상세 페이지인 [...detail]외와 /posts/[caregory], /posts/tag/[tag] 까지 각 페이지 별로 원하는 path와 데이터를 제공했더니 가능한 모든 조합을 빌드 시점에 불러와 페이지로 렌더링했다.\r\n(그래서 뒤지게 배포가 오래 걸린다)\r\n이렇게 페이지를 모조리 빌드해두고 배포하면 사용자는 이미 완성되어 있는 페이지를 받기만 하면 되므로 굉장히 빠르게 해당 페이지를 확인할 수 있다.\r\n\r\n## 마치며\r\n페이지의 다양한 렌더링 방식인 CSR, SSR에 대해서 그리고 더 나아가 SSG에 대해서도 살펴보았다. 뭐가 확실히 더 좋다라기 보다는 각 방식을 확실히 이해하고 상황에 따라 적절히 이를 활용하는 것이 중요할 듯 하다.\r\n"}]},"__N_SSG":true}
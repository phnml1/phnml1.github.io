{"pageProps":{"tags":["react","테스트","deepdive","next.js","렌더링","트러블슈팅","dev tools","SSR","SSG","Algorithm","프로그래머스","PCCP","lv2","이분탐색","JavaScript","useState","hook","클로저","생명주기","Virtual DOM","백준","gold","dfs","lv3","bfs"],"currentTag":"deepdive","posts":[{"slug":"posts/React/리액트 컴포넌트 테스트 코드 시작하기","title":"리액트 컴포넌트 테스트 코드 시작하기","date":"2024-11-18T17:00:24.000Z","image":"index.png","summary":"React Deepdive 서적의 React 컴포넌트의 테스트 코드를 정리하였다.","tags":["react","테스트","deepdive"],"content":"\r\n## 들어가며\r\n리액트에서 테스트라는 개념이 있다는 걸 알고 있었지만, 정확히 무슨 개념인지 또한 구체적으로 어떻게 하는 건지 몰랐었다. \r\n\r\nreact deep dive를 공부해보면서 `08 좋은 리액트 코드 작성을 위한 환경 구축하기` 단원 에서 리액트 컴포넌트 테스트코드를 작성하는 부분이 있어서 이 부분에서 공부하면서 배운 리액트 컴포넌트의 기초적인 테스트 코드를 작성하는 방법을 정리해보고자 한다. \r\n\r\n## 리액트 컴포넌트 테스트 \r\n\r\n기본적으로 리액트에서 컴포넌트 테스트는 다음과 같은 순서로 진행된다.\r\n\r\n\t1. 컴포넌트를 렌더링한다.\r\n\t2. 컴포넌트에서 특정 액션을 수행한다.\r\n\t3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과와 실제 결과와 비교한다.\r\n\r\n**App.tsx**\r\n```js\r\nimport React from 'react';\r\nimport logo from './logo.svg';\r\nimport './App.css';\r\nimport StaticComponent from './components/StaticComponent';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n        <p>\r\n          Edit <code>src/App.tsx</code> and save to reload.\r\n        </p>\r\n        <a\r\n          className=\"App-link\"\r\n          href=\"https://reactjs.org\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Learn React\r\n        </a>\r\n      </header>\r\n      <StaticComponent />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n**테스트 코드**\r\n```js\r\nimport React from 'react';\r\nimport { render, screen } from '@testing-library/react';\r\nimport App from './App';\r\n\r\ntest('renders learn react link', () => {\r\n  render(<App />);\r\n  const linkElement = screen.getByText(/learn react/i);\r\n  expect(linkElement).toBeInTheDocument();\r\n});\r\n\r\n```\r\nApp.test.tsx가 App.tsx에서 테스트하는 내용은 다음과 같이 요약할 수 있다.\r\n1. App 렌더링 \r\n2. App에서 'leartn react' 라는 문자열 가진 DOM 요소 찾기 \r\n3. expect(linkElement).toBeInTheDocument() 라는 어설션을 활용해 2번에서 찾은 요소가 document 내부에 있는지 확인하기\r\n\t\r\n위와 같이 일반적인 리액트 컴포넌트 테스트 시나리오는 특정한 무언가를 지닌 HTML 요소가 있는지 여부이다. \r\n이를 확인하는 방법은 3가지인데,\r\n\r\n- getBy... : 인수에 조건에 맞는 요소를 반환한다. 복수 개를 찾으려면 getAllBy.. 를 사용해야 한다.  \r\n- findBy... : getBy와 유사하지만 Promise를 반환, 즉 비동기로 찾는 것을 의미하며 기본적으로 1s의 타임아웃을 가지고 있다.  복수 개는 findAllBy를 사용한다.\r\n- queryBy... : 인수에 조건에 맞는 요소를 반환하는 대신, 요소를 찾지 못한다면 null이 반환된다. 찾지 못한경우 에 에러를 일으키지 않고 싶을 때 사용한다. 복수 개는 queryAllBy를 사용한다.\r\n\r\n\r\n자 그럼 본격적으로 리액트 컴포넌트들의 테스트 코드를 작성해보자.\r\n\r\n\r\n\r\n## 정적 컴포넌트\r\n\r\n`정적 컴포넌트`란 별도의 상태가 존재하지 않아 항상 같은 결과를 반환하는 컴포넌트이다.\r\n\r\n**정적 컴포넌트**\r\n```js\r\nimport { memo } from 'react'\r\n\r\nconst AnchorTagComponent = memo(function AnchorTagComponent({\r\n  name,\r\n  href,\r\n  targetBlank,\r\n}: {\r\n  name: string\r\n  href: string\r\n  targetBlank?: boolean\r\n}) {\r\n  return (\r\n    <a\r\n      href={href}\r\n      target={targetBlank ? '_blank' : undefined}\r\n      rel=\"noopener noreferrer\"\r\n    >\r\n      {name}\r\n    </a>\r\n  )\r\n})\r\n\r\nexport default function StaticComponent() {\r\n  return (\r\n    <>\r\n      <h1>Static Component</h1>\r\n      <div>유용한 링크</div>\r\n\r\n      <ul data-testid=\"ul\" style={{ listStyleType: 'square' }}>\r\n        <li>\r\n          <AnchorTagComponent\r\n            targetBlank\r\n            name=\"리액트\"\r\n            href=\"https://reactjs.org\"\r\n          />\r\n        </li>\r\n        <li>\r\n          <AnchorTagComponent\r\n            targetBlank\r\n            name=\"네이버\"\r\n            href=\"https://www.naver.com\"\r\n          />\r\n        </li>\r\n        <li>\r\n          <AnchorTagComponent name=\"블로그\" href=\"https://yceffort.kr\" />\r\n        </li>\r\n      </ul>\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n이 컴포넌트에서 링크가 제대로 있는지 확인해볼 것이다.\r\n\r\n**테스트 코드**\r\n```js\r\nimport { render, screen } from '@testing-library/react'\r\n\r\nimport StaticComponent from './index'\r\n\r\nbeforeEach(() => {\r\n  render(<StaticComponent />)\r\n})\r\n\r\ndescribe('링크 확인', () => {\r\n  it('링크가 3개 존재한다.', () => {\r\n    const ul = screen.getByTestId('ul')\r\n    expect(ul.children.length).toBe(3)\r\n  })\r\n\r\n  it('링크 목록의 스타일이 square다.', () => {\r\n    const ul = screen.getByTestId('ul')\r\n    expect(ul).toHaveStyle('list-style-type: square;')\r\n  })\r\n})\r\n\r\ndescribe('리액트 링크 테스트', () => {\r\n  it('리액트 링크가 존재한다.', () => {\r\n    const reactLink = screen.getByText('리액트')\r\n    expect(reactLink).toBeVisible()\r\n  })\r\n\r\n  it('리액트 링크가 올바른 주소로 존재한다.', () => {\r\n    const reactLink = screen.getByText('리액트')\r\n\r\n    expect(reactLink.tagName).toEqual('A')\r\n    expect(reactLink).toHaveAttribute('href', 'https://reactjs.org')\r\n  })\r\n})\r\n\r\ndescribe('네이버 링크 테스트', () => {\r\n  it('네이버 링크가 존재한다.', () => {\r\n    const naverLink = screen.getByText('네이버')\r\n    expect(naverLink).toBeVisible()\r\n  })\r\n\r\n  it('네이버 링크가 올바른 주소로 존재한다.', () => {\r\n    const naverLink = screen.getByText('네이버')\r\n\r\n    expect(naverLink.tagName).toEqual('A')\r\n    expect(naverLink).toHaveAttribute('href', 'https://www.naver.com')\r\n  })\r\n})\r\n\r\ndescribe('블로그 링크 테스트', () => {\r\n  it('블로그 링크가 존재한다.',()=>{\r\n    const blogLink = screen.getByText('블로그')\r\n    expect(blogLink).toBeVisible()\r\n  })\r\n  it('블로그 링크가 올바른 주소로 존재한다.', ()=>{\r\n    const blogLink = screen.getByText('블로그')\r\n\r\n    expect(blogLink.tagName).toEqual('A');\r\n    expect(blogLink).toHaveAttribute('href','https://yceffort.kr')\r\n  })\r\n\r\n  it('블로그는 같은 창에서 열려야 한다.', () => {\r\n    const blogLink = screen.getByText('블로그');\r\n    expect(blogLink).not.toHaveAttribute('target');\r\n  })\r\n})\r\n```\r\n각 테스트를 수행하기전에 StaticComponent를 렌더링하고 describe로 연관된 테스트를 묶어서 it으로 it 함수 내부에 수행하는 테스트파일이다.\r\n\r\n몇 가지 새로운 jest 메서드가 보인다.\r\n\r\n- beforeEach : 각 테스트들을 실행하기 전에 실행하는 함수  \r\n- describe : 비슷한 속성을 가진 테스트를 하나로 묶음 describe 안에 describe를 사용하는것도 가능  \r\n- it : test와 완전히 동일하며 축약어이다.  \r\n- testId : get등의 선택자로 선택하기 어렵거나 곤란한 요소를 선택하기 위해 사용한다.\r\n`\r\n참고로 HTML에 data-testid를 추가하면 getByTestId를 사용할 수 있다.\r\n이는 button의 개수가 많을 때와 같은 특정 시나리오에서 유용하게 사용할 수 있다.\r\n`\r\n\r\n## 동적 컴포넌트\r\n상태값이 있는 컴포넌트, 예를 들어 useState를 사용해 상태값을 관리하는 컴포넌트는 어떻게 테스트할까? 일반적으로 리액트에서는 정적인 경우보다 동적인 경우가 훨씬 많다.\r\n이 경우도 살펴보자.\r\n```js\r\nimport { useState } from 'react'\r\n\r\nexport function InputComponent() {\r\n  const [text, setText] = useState('')\r\n\r\n  function handleInputChange(event: React.ChangeEvent<HTMLInputElement>) {\r\n    const rawValue = event.target.value\r\n    const value = rawValue.replace(/[^A-Za-z0-9]/gi, '')\r\n    setText(value)\r\n  }\r\n\r\n  function handleButtonClick() {\r\n    alert(text)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <label htmlFor=\"input\">아이디를 입력하세요.</label>\r\n      <input\r\n        aria-label=\"input\"\r\n        id=\"input\"\r\n        value={text}\r\n        onChange={handleInputChange}\r\n        maxLength={20}\r\n      />\r\n      <button onClick={handleButtonClick} disabled={text.length === 0}>\r\n        제출하기\r\n      </button>\r\n    </>\r\n  )\r\n}\r\n```\r\n사용자의 키보드 타이핑 입력을 받는 input, 이를 alert로 띄우는 button으로 구성된 간단한 컴포넌트다. \r\n\r\ninput은 최대 20자까지, 한글 입력만 가능하도록 제한되어있으며, 이는 onChange에서 정규식을 통해 작성되어 있다. 그리고 버튼은 글자가 없으면 disable되도록 처리되어있고, 클릭 시 alert 창을 띄운다.\r\n\r\n테스트 코드는 다음과 같다.\r\n```\r\nimport { fireEvent, render } from '@testing-library/react'\r\nimport userEvent from '@testing-library/user-event'\r\n\r\nimport { InputComponent } from '.'\r\n\r\ndescribe('InputComponent 테스트', () => {\r\n  const setup = () => {\r\n    const screen = render(<InputComponent />)\r\n    const input = screen.getByLabelText('input') as HTMLInputElement\r\n    const button = screen.getByText(/제출하기/i) as HTMLButtonElement\r\n    return {\r\n      input,\r\n      button,\r\n      ...screen,\r\n    }\r\n  }\r\n\r\n  it('input의 초기값은 빈 문자열이다.', () => {\r\n    const { input } = setup()\r\n    expect(input.value).toEqual('')\r\n  })\r\n\r\n  it('input의 최대길이가 20자로 설정되어 있다.', () => {\r\n    const { input } = setup()\r\n    expect(input).toHaveAttribute('maxlength', '20')\r\n  })\r\n\r\n  it('영문과 숫자만 입력된다.', () => {\r\n    const { input } = setup()\r\n    const inputValue = '안녕하세요123'\r\n    userEvent.type(input, inputValue)\r\n    expect(input.value).toEqual('123')\r\n  })\r\n\r\n  it('아이디를 입력하지 않으면 버튼이 활성화 되지 않는다.', () => {\r\n    const { button } = setup()\r\n    expect(button).toBeDisabled()\r\n  })\r\n\r\n  it('아이디를 입력하면 버튼이 활성화 된다.', () => {\r\n    const { button, input } = setup()\r\n\r\n    const inputValue = 'helloworld'\r\n    userEvent.type(input, inputValue)\r\n\r\n    expect(input.value).toEqual(inputValue)\r\n    expect(button).toBeEnabled()\r\n  })\r\n\r\n  it('버튼을 클릭하면 alert가 해당 아이디로 뜬다.', () => {\r\n    const alertMock = jest\r\n      .spyOn(window, 'alert')\r\n      .mockImplementation((_: string) => undefined)\r\n\r\n    const { button, input } = setup()\r\n    const inputValue = 'helloworld'\r\n\r\n    userEvent.type(input, inputValue)\r\n    fireEvent.click(button)\r\n\r\n    expect(alertMock).toHaveBeenCalledTimes(1)\r\n    expect(alertMock).toHaveBeenCalledWith(inputValue)\r\n  })\r\n})\r\n```\r\n- setup : 내부에서 컴포넌트를 렌더링하고 테스트에 필요한 button,input을 반환한다.  \r\n- userEvent.type : 사용자가 타이핑 하는것을 흉내내는 메서드이다. userEvent.type을 사용하면 사용자가 타이핑하는 것과 동일한 작동을 만들 수 있다.\r\nuserEvent는 fireEvent의 여러 이벤트를 순차적으로 실행해 좀 더 자세하게 사용자의 작동을 흉내낸다. \r\n예를 들어 userEvent.click를 수행하면 \r\n\t- fireEvent.MouseOver  \r\n\t- fireEvent.mouseMove \r\n\t- fireEvent.mouseDown \r\n\t- fireEvent.mouseUp  \r\n\t- fireEvent.click \r\n\r\n\t을 수행한다. \r\n  \r\n  즉 userEvent는 사용자의 작동을 **여러 fireEvent를 통해 좀 더 자세하게 흉내 내는 모듈이**라고 볼 수 있는 것이다.\r\n\r\n\t대부분의 이벤트를 테스트할 때는 fireEvent로 충분하고 훨씬 빠르지만, 특별히 사용자의 이벤트를 흉내 내야 할 때만 userEvent를 사용한다.\r\n  \r\n- **jest.spyOn(window,'alert').mockImplementation()**  \r\n\t- spyOn : 특정 메서드를 오염시키지 않고 실행이 되었는지 , 어떤 인수로 실행되었는지 실행과 관련된 정보만 얻고 싶을때 사용한다. 즉 위의 코드에서는 window 객체의 메서드 alert를 구현하지 않고 해당 메서드가 실행되었는지를 관찰한다는 뜻이다.\r\n\t\r\n\t\r\n\t\tspyon으로 `한번 호출되었는지`(toBeCalledTimes(1)), `원하는 인수와 함께 호출되었는지` (toBeCalledWith(1,2))를 확인할 수 있다. \r\n\t**calc.add자체에는 영향을 미치지 않는다.**\r\n\t- mockImplementation: 해당 메서드에 대한 모킹을 도와준다. Jest환경에서는 window.alert가 존재하지 않는데, 이를 모의함수(mock)로 구현할 수 해주는 메서드이다.\r\n\r\n\t즉 jest.spyOn을 사용해 Node.js에서 존재하지 않는 window.alert를 관찰하고, mockImpletation을 사용해 window.alert가 실행되었는지의 정보를 확인할 수 있도록 처리한 것이다.\r\n\r\n## 비동기 함수 컴포넌트\r\n## 비동기 이벤트가 발생하는 컴포넌트\r\n그렇다면 비동기 이벤트 중 fetch가 실행되는 컴포넌트를 예로 들어보자\r\n\r\n이 코드는 버튼을 클릭하면 /todos/:id로 fetch 요청을 보내 데이터를 불러온다.\r\n\r\n이 fetch를 어떻게 테스트 할 수 있을까?\r\n\r\n우리는 이를 위해 `MSW`를 사용해 볼 것이다.\r\n \r\n MSW는 브라우저에서 사용할 때는 서비스 워커를 활용해 실제 네트워크 요청을 가로채는 방식으로 모킹을 구현하고, Node.js 환경에서는 https나 XMLHttpRequest의 요청을 가로채는 방식으로 작동한다.\r\n즉 node.js에서나 브라우저에서 fetch 요청을 하는 것과 동일하게 네트워크 요청을 수행하고, 이 요청을 중간에 MSW가 감지하고 미리 준비한 모킹 데이터를 제공하는 방식이다.\r\n\r\n이는 fetch의 모든 기능을 그대로 사용하고 응답에 대해서만 모킹할 수 있으므로 fetch를 모킹하는게 훨씬 수월해진다.\r\n\r\n비동기 함수 컴포넌트 테스트 코드\r\n```js\r\nimport { fireEvent, render, screen } from '@testing-library/react'\r\nimport { rest } from 'msw'\r\nimport { setupServer } from 'msw/node'\r\n\r\nimport { FetchComponent } from '.'\r\n\r\nconst MOCK_TODO_RESPONSE = {\r\n  userId: 1,\r\n  id: 1,\r\n  title: 'delectus aut autem',\r\n  completed: false,\r\n}\r\n// 서버를 만드는 역할\r\nconst server = setupServer(\r\n  rest.get('/todos/:id', (req, res, ctx) => {\r\n    const todoId = req.params.id\r\n\r\n    if (Number(todoId)) {\r\n      return res(ctx.json({ ...MOCK_TODO_RESPONSE, id: Number(todoId) }))\r\n    } else {\r\n      return res(ctx.status(404))\r\n    }\r\n  }),\r\n)\r\n// \r\nbeforeAll(() => server.listen())\r\n// 초기화했던 초기값유지위해서 이 테스트는 마지막이어서 상관없지만, 그렇지않으면 다른 곳에서도 503에러\r\n// afterEach(() => server.resetHandlers());\r\nafterAll(() => server.close())\r\n\r\nbeforeEach(() => {\r\n  render(<FetchComponent />)\r\n})\r\n\r\ndescribe('FetchComponent 테스트', () => {\r\n  it('데이터를 불러오기 전에는 기본 문구가 뜬다.', async () => {\r\n    const nowLoading = screen.getByText(/불러온 데이터가 없습니다./)\r\n    expect(nowLoading).toBeInTheDocument()\r\n  })\r\n\r\n  it('버튼을 클릭하면 데이터를 불러온다.', async () => {\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const data = await screen.findByText(MOCK_TODO_RESPONSE.title)\r\n    expect(data).toBeInTheDocument()\r\n  })\r\n\r\n  //여기서만 에러떠야하므로 위에서 resetHandlers 사용\r\n  it('버튼을 클릭하고 서버요청에서 에러가 발생하면 에러문구를 노출한다.', async () => {\r\n    server.use(\r\n      rest.get('/todos/:id', (req, res, ctx) => {\r\n        return res(ctx.status(503))\r\n      }),\r\n    )\r\n\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const error = await screen.findByText(/에러가 발생했습니다/)\r\n    expect(error).toBeInTheDocument()\r\n  })\r\n})\r\n```\r\n전체 코드를 나눠서 살펴보자\r\n```js\r\n// 서버를 만드는 역할\r\nconst server = setupServer(\r\n  rest.get('/todos/:id', (req, res, ctx) => {\r\n    const todoId = req.params.id\r\n\r\n    if (Number(todoId)) {\r\n      return res(ctx.json({ ...MOCK_TODO_RESPONSE, id: Number(todoId) }))\r\n    } else {\r\n      return res(ctx.status(404))\r\n    }\r\n  }),\r\n)\r\n```\r\n- setupServer: 이름 그대로 서버를 만드는 역할이다. \r\n라우트 /todos/:id의 요청만 가로채서 todoId가 숫자인지 확인한 다음, 숫자일 때만 MOCK_TODO_RESPONSE와 id를 반환하고, 숫자가 아니라면 404를 반환하도록 코드를 구성했다. \r\n\r\n테스트 코드를 시작하기 전에는 서버를 기동하고, 종료되면 서버를 종료시킨다. \r\nafterEach에 있는 server.resetHandlers()는 만일 `서버가 실패가 발생하는 경우`를 테스트할 때 ctx.status(503)과 같은 형태로 변경하는데, 이를 리셋하지 않으면 실패하는 코드로 남아있을 것이므로 테스트 실행마다 resetHandlers를 통해 setupServer로 초기화했던 초깃값을 유지하기 위한 것이다.\r\n\r\n그 다음 describe를 시작으로 테스트하고 싶은 내용을 테스트 코드로 작성해보자.\r\n```js\r\nit('버튼을 클릭하면 데이터를 불러온다.', async () => {\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const data = await screen.findByText(MOCK_TODO_RESPONSE.title)\r\n    expect(data).toBeInTheDocument()\r\n  })\r\n```\r\n버튼을 클릭해 fetch가 발생하는 시나리오를 테스트한다. 버튼을 클릭하는 것 까지는 동일하지만 이후 fetch 응답이 온 뒤에서야 비로소 찾고자 하는 값을 렌더링할 것이다.\r\n\r\n요소가 렌더링될 때까지 일정 시간 동안 기다리는 `find 메서드`를 사용해 요소를 검색한다.\r\n\r\n```js\r\n//여기서만 에러떠야하므로 위에서 resetHandlers 사용\r\n  it('버튼을 클릭하고 서버요청에서 에러가 발생하면 에러문구를 노출한다.', async () => {\r\n    server.use(\r\n      rest.get('/todos/:id', (req, res, ctx) => {\r\n        return res(ctx.status(503))\r\n      }),\r\n    )\r\n\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const error = await screen.findByText(/에러가 발생했습니다/)\r\n    expect(error).toBeInTheDocument()\r\n  })\r\n```\r\n앞서 setupServer는 정상적인 응답만 모킹했기 때문에 에러가 발생하는 경우를 테스트하기 힘들다.\r\n\r\n서버 응답이 실패하는 경우를 테스트하기 위해서는 `server.use`를 사용해 기존 `setupServer`의 내용을 새롭게 덮어쓴다. 모든 경우에 503이 오도록 작성했고, 서버 설정이 끝난 후에는 findBy를 이용해 에러 문구가 정상적으로 노출됐는지 확인한다.\r\n\r\nserver.use를 활용해 서버 기본 작동을 덮어쓰는 작업은 위의 코드에서만 유효해야하고, 다른 코드에서는 원래대로 다시 서버 작동이 되어야하므로 위에서 afterEach에서 resetHandlers를 실행하는 것이다. \r\n\r\n비동기 컴포넌트의 테스트에서 중요한 것은 **MSW를 사용한 fetch 응답 모킹**과 **findBy를 활용해 비동기 요청이 끝난 뒤에 제대로 된 렌더링이 일어났는지 기다린 후에 확인하는 것**이다.\r\n## 마치며\r\n지금까지 리액트에서 사용될 수 있는 3가지 종류의 컴포넌트 `정적 컴포넌트`, `동적 컴포넌트`, `비동기 이벤트가 발생하는 컴포넌트`의 간단한 테스트 코드를 살펴보았다.\r\n\r\n책에는 이외에도 추가로 `사용자 정의 훅을 테스트하기`가 있는데, 이 부분은 조만간 테스트가 익숙해진 이후 실제로 프로젝트에서 사용해본 사용자 정의 훅을 테스트하는  글을 포스팅해볼 예정이다.\r\n\r\n테스트에 관한 글은 계속 올릴 것 이니 많관부.\r\n\r\n\r\n"},{"slug":"posts/React/React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험","title":"React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험","date":"2024-11-11T17:00:24.000Z","image":"index.png","summary":"React 개발자 도구(React dev tools)의 기능들과 이를 활용해본 경험을 공유해보겠다.","tags":["react","next.js","렌더링","트러블슈팅","deepdive","dev tools"],"content":"\r\n# React 개발자 도구(React dev tools)로 불필요한 렌더링을 없애본 경험\r\n\r\n## 들어가며\r\n\r\nReact Deep dive를 스터디에서 공부하며 리액트 앱을 디버깅하고 검사할 때 보다 효율적으로 할 수 있는 도구인, **React dev tools**(React 개발자 도구)라는 것을 처음 접하게되었다.\r\n이번 포스팅에서는 React 개발자 도구의 각종 기능에 대해 설명한 후, 이것을 통해 본인의 블로그의 페이지에서 본래 모르고 있었던 지속적으로 발생하고 있던 불필요한 렌더링을 없앤 경험도 공유하고자 한다.\r\n\r\n## React Dev tools란?\r\nReact 애플리케이션을 디버깅하고 최적화하는 데 도움을 주는 브라우저 확장 도구이다. 브라우저의 확장 프로그램으로써 설치하면 사용할 수 있다.  \r\n\r\n참고로 React app의 development모드에서만 원활하게 모든 기능을 사용할 수 있으며 production 모드로 빌드되었을시에는 profiler 기능은 비활성화된다.\r\n <img src=\"2.png\" alt=\"nextjs\" width = '40' height = '40'/>\r\n만일 production 빌드시에는 이런식으로\r\n이 도구를 사용할 수 있을 때는 \r\n<img src=\"1.png\" alt=\"nextjs\" width = '40' height = '40'/>\r\n이런식으로 색깔이 들어오게 된다.\r\n\r\n그럼 React dev tools의 기능들인 **Components**, **Profiler** 탭을 보는 방법에 대해서 함께 알아보자\r\n\r\n## Components\r\nComponents 탭에서는 현재 리액트 애플리케이션의 컴포넌트 트리를 확인할 수 있으며, 단순히 구조 뿐만이 아니라, props와 내부 hooks 등 다양한 정보를 확인할 수 있다.\r\n### Components 탭의 기능\r\n- 컴포넌트 트리의 전체적인 구조를 확인할 수 있다.\r\n <img src=\"3.png\" alt=\"nextjs\"/>\r\n- 보통 state, props의 값을 브라우저에서 확인 하려면 `console.log(...)`이런식으로 로그를 출력하여 확인하는데 컴포넌트 탭에서는 특정 컴포넌트를 그 안에 있는 state, props의 값을 확인할 수 있다.\r\n <img src=\"4.png\" alt=\"nextjs\"/>\r\n- 또한 단지 state, props 뿐만 아니라 컴포넌트에서 사용된 훅을 볼 수 있는 hooks 도 있는걸 볼 수 있다.\r\n\t- state : useState\r\n\t- Reducer: useReducer\r\n\t- Context: useContext\r\n\t- Callback: useCallback\r\n\t- Ref: useRef\r\n\t- id: useId\r\n\t- LayoutEffect: useLayoutEffect\r\n\t- Effect: useEffect\r\n\t- 그외의 사용자 훅: use가 빠진채로 보여짐( ex. useCounter면 Counter로)\r\n - 또한 rendered by를 통해 해당 컴포넌트를 렌더링한 부모컴포넌트까지 확인할 수 있다.\r\n- 벌레 모양의 버튼을 클릭하면 `log this component data to the console`이라는 문자가 뜨는데 이걸 클릭하면 컴포넌트의 관한 데이터를 콘솔에 찍어볼 수 있다.\r\n \t<img src=\"5.png\" alt=\"nextjs\"/>\r\n\t\t콘솔에 컴포넌트의 정보가 나타난다.\r\n \t<img src=\"6.png\" alt=\"nextjs\"/>\r\n\r\nComponents탭의 대표적인 기능들만을 소개했지만, 이외에도 직접 에러를 발생시킨다거나, 컴포넌트의 state, props값을 임의로 바꿔본다든가 등의 기능 역시 사용할 수 있다.\r\n\r\n## Profiler\r\n프로파일러는 리액트가 렌더링하는 과정에서 발생하는 상황을 확인하기 위한 도구다. 즉 리액트 애플리케이션이 렌더링되는 과정에서 어떤 컴포넌트가 렌더링됐는지, 또 몇 차례나 렌더링이 일어났으며 어떤 작업에서 오래 걸렸는지와 같은 것을 확인할 수 있다.\r\n\r\n### 프로파일링 시작하기\r\n처음 프로파일러 탭을 열고, \r\n첫번째 버튼 \"🔵\" 버튼을 누르면 기록이 진행된다. 기록을 시작하면 렌더링 관련 정보들이 자동으로 수집되며, 🔴 버튼을 누르면 수집이 중단되고 결과가 나타난다.\r\n\r\n두번째 버튼을 누르면 새로고침 후 동시에 프로파일링이 시작된다 마찬가지로 첫번째 버튼이 🔴로 바뀌며, 이를 누르면 프로파일링이 중단되고, 결과가 나타난다. \r\n\r\n### Flame Chart\r\n <img src=\"7.png\" alt=\"nextjs\"/>\r\nFlame Chart는 특정 커밋에 대한 애플리케이션 상태를 보여준다. \r\n차트의 각 막대는 컴포넌트들을 뜻하며 너비가 넓을 수록 해당 컴포넌트를 렌더링 하는데 오래 걸렸다는 것을 의미한다.\r\n\r\n각 컴포넌트에 마우스를 가져다 대면 해당 컴포넌트의 렌더링과 관련된 정보를 확인할 수 있다. \r\n\r\n또한 오른쪽위의 화살표 혹은 막대 그래프를 누르면 각 렌더 커밋별로 리액트에서 발생한 렌더링 정보와 발생한 횟수를 확인할 수 있어 의도한 횟수만큼 렌더링이 발생했는지도 알 수 있다.\r\n\r\n### Ranked\r\n해당 커밋에서 렌더링하는데 오랜시간이 걸린 컴포넌트를 순서대로 나열한 그래프이다.\r\n <img src=\"8.png\" alt=\"nextjs\"/>\r\nFlamegraph와의 차이점은 모든 컴포넌트가 아닌 단순히 렌더링이 발생한 컴포넌트만 보여준다는 것이다.\r\n\r\n### TimeLine\r\n <img src=\"9.png\" alt=\"nextjs\"/>\r\n리액트 18이상의 환경에서만 확인할 수 있으며, 시간의 흐름에 따라 리액트가 작동하는 내용을 추적하는데 유용하다. 시간 단위로 프로파일링 기간동안 무슨 일이 있었는지 무엇이 렌더링됐고, 어느 시점에 렌더링됐는지 등에 대해 자세히 확인할 수 있다.\r\n\r\n## 이를 직접  활용하여 불필요한 렌더링 줄여본 경험\r\n### 문제 상황\r\n내 블로그 페이지에는 글을 검색할 수 있는 SearchPage가 있다.\r\nprofiler 탭에서 프로파일링을 시작하고 검색어 입력창에 키워드를 입력하고, 프로파일링을 끝내 보았는데, 문제가 발견되었다.\r\n <img src=\"10.png\" alt=\"nextjs\"/>\r\n <img src=\"11.png\" alt=\"nextjs\"/>\r\n검색어를 입력만 했는데 검색어에 따른 포스트들을 보여주는 `PostItem`을 제외하고 이와 관련없는 NavBar, Footer 등 페이지의 모든 요소가 함께 렌더링이 되고 있었다. Ranked로 보니까 시간 역시 제법 차지 하고 있었다.\r\n\r\n또한 검색페이지 뿐만이 아니더라도 카테고리 선택 페이지에서도 마찬가지로 카테고리만 선택했는데도 이와 같은 현상으로 불필요하게 렌더링이 발생하고 있었다.\r\n\r\n... 왜 이런지 Components 탭으로 Header와 Footer와 같은 컴포넌트를 포함하는 컴포넌트인 **Layout 컴포넌트**의 정보를 보니 다음과 같았다.\r\n\r\n그 전에 참고: Layout 컴포넌트 코드 (모달창, 헤더, 푸터등을 관리한다.)\r\n```js\r\nexport default function Layout({ children }: React.PropsWithChildren) {\r\n  const [sidebar,setSideBar] = useState(false);\r\n\t// 사이드바에 관한 useEffect 코드들 (생략)\r\n\treturn (\r\n\t\t\t<Providers>\r\n\t\t\t\t<main\r\n\t\t\t\t\tclassName={cls(\r\n\t\t\t\t\t\tnotoSansKr.className,\r\n\t\t\t\t\t\topensans.variable,\r\n\t\t\t\t\t\tkanit.variable,\r\n\t\t\t\t\t\t'w-full relative flex flex-col items-center dark:bg-dark-primary dark:text-dark-primary transition-[background]',\r\n\t\t\t\t\t)}\r\n\t\t\t\t>\r\n\t\t\t\t\t<Navbar setSideBar = {setSideBar}/>\r\n\t\t\t\t\t<div className=\"w-full flex flex-col items-center\">{children}</div>\r\n\t\t\t\t\t{sidebar && (<SideBar setSideBar={setSideBar}/>)}\r\n\t\t\t\t\t<Footer />\r\n\t\t\t\t</main>\r\n\t\t\t</Providers>\r\n\t\t);\r\n}\r\n\r\n```\r\n**Layout 컴포넌트 정보**\r\n  <img src=\"12.png\" alt=\"nextjs\"/>\r\nrendered by PostSearchPage... 참고로 **PostSearchPage의 컴포넌트 정보**는 다음과 같다.\r\n  <img src=\"13.png\" alt=\"nextjs\"/>\r\n1번째 State인 검색결과,  2번째 State인 검색 키워드 까지 여기서 관리되고 있었기에 당연히 검색을 할 때마다 PostSearchPage이 렌더링되고 이에 따라 **자식 컴포넌트인 Layout역시 같이 렌더링**이 되는 것 이었다.\r\n\r\nPostSearchPage의 코드를 보면,\r\n```js\r\nexport  default  function  PostSearchPage(props: {posts:Post[]}) {\r\n\tconst [posts,setPosts] =  useState<Post[]>(props.posts);\r\n\tconst [keyword,setKeyword] =  useState<string>('');\r\n\tuseEffect(()=>{\r\n\t\tconst  filteredPosts:Post[] =  searchPosts(props.posts,keyword);\r\n\t\tsetPosts(filteredPosts);\r\n\t},[keyword, props.posts]);\r\n\treturn (\r\n\t<Layout>\r\n\t\t<div  className='w-full mt-8 md:w-4/5 px-8'>\r\n\t\t\t<SearchInput  keyword={keyword}  setKeyword  =  {setKeyword}/>\r\n\t\t</div>\r\n\t\t{/* 검색결과를 보여주는 레이아웃 */}\r\n\t\t<PostLayout  posts={posts}  currentCategory={keyword}  theme='search'/>\r\n\t</Layout>\r\n\t);\r\n}\r\n```\r\nLayout이 자식으로 있는걸 볼 수 있다.\r\n\r\n### 해결 방법\r\n\r\n이에 대한 해결 방법으로 물론, `Layout`을  메모이제이션을 통해서 변경이 발생할 때만 렌더링 되도록 최적화 할 수도 있지만, `Layout` 컴포넌트가 모든 페이지에서 공통으로 사용되고, `Layout` 자체에서 각 페이지에 의존하는 상태가 없는 점을 고려하여 `_app.tsx`에서 이를 최상위 레이아웃으로 설정하는 것이 더 적절해 보였다.\r\n\r\n> Next.js의 page router에서 `_app.tsx` 파일은 애플리케이션 전체의 최상위 컴포넌트를 정의하는 역할을 한다.\r\n\r\n_app.tsx\r\n```js\r\nexport  default  function  App({ Component, pageProps }:  AppProps) {\r\n\treturn (\r\n\t\t<ThemeProvider  attribute='class'  >\r\n\t\t\t<Layout>\r\n\t\t\t\t<Component  {...pageProps}  />\r\n\t\t\t</Layout>\r\n\t\t</ThemeProvider>\r\n\t);\r\n}\r\n```\r\n변경된 PostSearchPage의 return문\r\n```js\r\nreturn (\r\n<>\r\n\t<div  className='w-full mt-8 md:w-4/5 px-8'>\r\n\t\t<SearchInput  keyword={keyword}  setKeyword  =  {setKeyword}/>\r\n\t</div>\r\n\t{/* 검색결과를 보여주는 레이아웃 */}\r\n\t<PostLayout  posts={posts}  currentCategory={keyword}  theme='search'/>\r\n</>\r\n);\r\n```\r\n\r\n이와같이 변경하고 다시 프로파일링을 해보니\r\n <img src=\"14.png\" alt=\"nextjs\"/>\r\nLayout이 더이상 렌더링이 되지않고, 당연히 그전에 불필요하게 렌더링 되었던 Navbar와 Footer도 렌더링이 되지않는다! \r\n\r\n## 마치며\r\n지금까지 React Devtools의 기능에 대해 알아보고, 필자가 이를 이용해서 본인의 블로그에서 발생되는 불필요한 렌더링을 없앤 경험까지 소개해보았다.\r\n\r\n후후.. 지나가는 형님들은 이걸 보며 '뭐야 이 바보는 당연한거 아닌가' 라고 생각할 수도 있겠지만 지금까지 '구현만 되어라' 만 생각했던 구현충인 내가 나름 처음으로 한 최적화? 경험이기에 조금 뿌듯했다. \r\n\r\n그리고 React Devtools를 사용하며 기능 자체는 좋았는데, 뭐가 문제인진 모르겠는데 자꾸 중간에 멈추고 먹통이 되어서 짜증났다. 해결되기 전까지는 chrome 개발자 도구 사용하련다. "},{"slug":"posts/React/서버사이드 렌더링에 대해 알아보자","title":"서버사이드 렌더링에 대해 알아보자(Feat: next.js, SSG)","date":"2024-11-03T22:00:24.000Z","image":"index.png","summary":"클라이언트 사이드 렌더링(CSR)과 서버 사이드 렌더링(SSR)에 대해서 그리고 SSR을 활용한 next.js 예제와 SSG의 개념과 예제까지 알아보자.","tags":["react","next.js","deepdive","SSR","SSG","렌더링"],"content":"\r\n프론트엔드를 공부하노라면 **SPA**(Single Page Application)와  **CSR**(Client Side Rendering)과 **SSR(Server Side Rendering)**에 대해 한번 씩 이라도 들어보았을 것 이다.\r\n\r\n하지만 개념이 확실히 안잡힐 때가 있고, 뭐를 써야 더 좋은지도 모를 때도 많다.\r\n\r\n이번 포스팅에서는 SPA,CSR에 대해 간단히 알아본 후, **SSR**에 대해서 보다 더 자세히 개념과  이것이 쓰이는 Next.js 코드 예제에 대해서도 살펴볼 것이다. \r\n\r\n그리고 더 나아가 정적 데이터를 미리 로드하는**SSG**(Static Site Generation)에 대해서도 알아볼 것이다.\r\n\r\n## 그 전에 SPA란?\r\n\r\n**싱글 페이지 애플리케이션(SPA)**은 SSR(Server-Side Rendering)과 다른 렌더링 방식인 **CSR(Client-Side Rendering)**을 주로 사용하여 서버가 아닌 브라우저에서 페이지를 렌더링하고 전환한다.\r\n\r\nSPA는 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 **브라우저의 JavaScript에 의존하는 방식**인 CSR을 사용하여 구현된다. \r\n\r\nSPA에서는 주로 CSR을 사용하여 처음 페이지를 로드할 때 필요한 데이터를 한 번에 받아오고, 이후에는 서버에서 HTML을 새로 내려받지 않고 **하나의 페이지에서 모든 작업을 처리하기 때문에** **싱글 페이지 애플리케이션(SPA)**이라고 불리는 것이다.\r\n```html\r\n<body><noscript>You need to enable JavaScript to run this app.</noscript><div id=\"root\"></div></body></html>\r\n```\r\n위의 SPA를 사용하는 HTML소스를 보면  HTML 코드의 `body` 내부가 비어 있다. \r\n\r\n이는 사이트 렌더링에 필요한 body 내부의 내용을 모두 **자바스크립트 코드**로 삽입한 후에 렌더링하기 때문이다. .\r\n\r\nCSR을 사용하는 SPA는 한번 로딩된 이후에는 페이지 전환 속도가 빠르고 사용자와의 상호작용이 부드럽다는 장점이 있지만, 최초의 로딩해야 할 자바스크립트 리소스가 커진다는 것 그리고 그로 인해 초기 로딩 속도가 길어진다는 단점이 있다.\r\n\r\n## SSR\r\n싱글 페이지 애플리케이션이 자바스크립트를 활용해 하나의 페이지에서만 렌더링을 수행한다면 서버 사이드 렌더링은 **최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식**이다.\r\n\r\n즉 앞서 살펴보았던 CSR과 SSR의 차이는 웹페이지 렌더링의 책임을 어디에 두느냐인데,  CSR을 사용하는 SPA는 사용자에게 제공되는 자바스크립트 번들에서 렌더링을 담당하지만, SSR을 채택하면 렌더링에 필요한 작업을 모두 서버에서 수행한다. \r\n\r\n클라이언트 렌더링은 사용자 기기의 성능에 영향을 받지만, 서버 사이드 렌더링은 서버에서 제공하기 때문에 안정적인 렌더링이 가능하다.\r\n\r\n## SSR의 장단점\r\n### 장점\r\n- 최초 페이지 진입이 비교적 빠르다.\r\n\t\r\n\t최초 페이지 진입 시 페이지에 유의미한 정보가 그려지는 시간인 FCP(First Contentful Paint)가 SPA에 비해 더 빨라질 수 있다. 다만, 서버가 사용자에게 렌더링을 제공할 수 있는 충분한 리소스가 확보되어 있다라는 가정하에 비교한 것이다.\r\n\t\r\n- 검색 엔진과 SNS 공유 등 메타 데이터 제공이 쉽다.\r\n\t\r\n\t검색 엔진 로봇이 페이지의 정보를 가져올 때 HTML을 다운로드 하는데, 단, **이 때 자바스크립트 코드는 실행하지 않는다.** \r\n\r\n\t다운로드한 HTML 페이지 내부의 오픈 그래프(Open Graph)나 메타(meta) 태그 정보를 \t기반으로 페이지의 검색 정보를 가져오고, 이를 바탕으로 검색 엔진에 저장한다.\r\n\r\n\t서버사이드 렌더링을 사용하면 최초의 렌더링 작업이 서버에서 일어난다. 즉 검색 엔진에서 제공할 정보를 서버에서 가공하여 HTML 응답으로 제공할 수 있으므로 SEO에 대응하기가 용이하다.\r\n\t\r\n\tSSR을 사용하는 next js에서는 generateMetaData라는 함수를 사용 (14버전 app router기준) 하여 데이터를 미리 페칭하여 동적으로 이와 같이 비교적 쉽게 메타데이터의 내용을 설정할 수도 있다. \r\n\t```js\r\n\t// params는 groupId라고 설정된 페이지의 동적 파라미터를 받아오는 것\r\n\texport  async  function  generateMetadata({params}: {params: {groupId:  string}}) {\r\n\t// 이 params를 통해서 서버에 미리 데이터를 요청한다.\r\n\tconst  response  =  await  fetchGroupData({queryKey: ['groupDetail',Number(params.groupId)]});\r\n\t// 요청한 데이터를 이런식으로 return 하여 head 태그의 title과 description에 넣을 수 있다.\r\n\t\treturn {\r\n\t\t\ttitle:  `${response.name}`,\r\n\t\t\tdescription:  `${response.description}`,\r\n\t\t}\r\n\t}\r\n\t```\r\n\r\n- 누적 레이아웃 이동이 적다.\r\n\t누적 레이아웃 이동은 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥 거리는 것과 같은 부정적인 사용자 경험을 말하는 것이다. \r\n\r\n\tapi요청이 다 완료된 이후에 완성된 페이지를 제공하는 서버 사이드 렌더링은 이러한 문제에서 비교적 자유롭다.\r\n\r\n- 사용자의 디바이스 성능에 비교적 자유롭다.\r\n\t- 서버와 함께 데이터를 로드하는 부담을 나누므로, 보다 사용자 디바이스 성능에 자유롭다.\r\n\r\n### 단점\r\n- 소스코드를 작성할 때 항상 서버를 고려해야 한다.\r\n\r\n\twindow 또는 sessionStorage와 같은 브라우저 전역 객체에 접근하는 코드는 서버에서 실행될 수 없어 이를 고려 해야 하고, 외부 라이브러리 역시 서버에 대한 고려를 해야만한다.\r\n- 적절한 서버가 구축되어있어야 한다.\r\n\r\n\t서버 사이드 렌더링은 말 그대로 사용자의 요청을 받아 렌더링을 수행할 서버가 필요하므로, 사용자의 요청에 따라 적절히 대응하는 것, 예기치 못한 장애상황에 대응하는 전략도 필요하다\r\n- 서비스 지연 문제\r\n\t\r\n\tSPA에서는 최초에 어떤 화면이라도 보여준 상태에서 느린 작업이 수행되기 때문에 '로딩 중'과 같은 것으로 안내하면 되지만, SSR에서는 특히 이 지연 작업이 최초 렌더링에 발생한다면 사용자에게 그 어떤 정보를 제공할 수 없기에, 더 안좋은 사용자 경험을 제공할 수 있다.\r\n\r\n## Next js에서 사용되는 SSR\r\n\r\nReact DeepDive는 Next.js 13을 기준으로 책이 쓰여졌기에 page router의 **getServerSideProps**를 사용하는 것을 next.js의 서버 사이드 렌더링의 예제로 사용하고 있다.\r\n\r\n 해당 함수가 있다면 무조건 페이지 진입 전에 이 함수를 실행한다.\r\n\r\n이 함수는 응답값에 따라 페이지의 컴포넌트에 props를 반환할 수도, 혹은 다른 페이지로 리다이렉트 시킬 수 있다.\r\n```js\r\nimport type {GetServerSideProps} from 'next';\r\n\r\nexport default function Post({post}: {post:Post}) {\r\n\t// 렌더링\r\n}\r\n\r\nexport const getServerSideProps: GetServerSideProps = async (context) => {\r\n\t// /post/[id]와 같은 경로에 있는 id 값에 접근할 수 있다. (여기서 id는 동적 파라미터)\r\n\tconst {\r\n\tquery: {id: ''},\r\n\t} = context\r\n\tconst post = await fetchPost(id.toString());\r\n\treturn {\r\n\t\tprops: {post},\r\n\t}\r\n}\r\n```\r\n\r\nconstext.query.id를 사용하면  /post/[id] 같은 경로에 있는 id 값에 접근할 수 있다. \r\n(ex ) `www.aaa.com/post/12` 면 `12`추출 가능)\r\n\r\n위의 코드는 페이지의 경로의 id에 접근하여 그 값을 파라미터로 받는 데이터 요청 함수(fetchPost)를 통해 데이터를 받고 받은 데이터를 props에 return 하고 있다.\r\n\r\n이렇게 getServerSideProps로 미리 props를 제공하면 페이지의 Post 컴포넌트에 해당 값을 제공하여 이 반환 값을 기반으로 렌더링 한다.\r\n\r\n그렇다면 14버전의 Next.js App router에서는 이를 어떻게 구현할지도 살펴보자.\r\n\r\n```js\r\n// app/post/[id]/page.js\r\n\r\nimport { fetchPost } from '@/lib/api'; // fetchPost 함수는 외부 API 호출 함수라고 가정\r\n\r\nexport default async function Post({ params }) {\r\n  const { id } = params;\r\n  const post = await fetchPost(id); // 데이터를 서버 측에서 가져옴\r\n\r\n  return (\r\n    <>\r\n      <PostInfo title = {post.title} content = {post.content}/>\r\n    </>\r\n  );\r\n}\r\n```\r\n\r\n14버전 next js은 getServerSideProps와 같은 함수를 쓰는 대신, 컴포넌트를 **클라이언트 컴포넌트**와 **서버 컴포넌트**로 나눈다. \r\n\r\n위의 컴포넌트 Post는 서버 컴포넌트이다. 14버전의 next.js에서는 최상단에 따로 명령어를 쓰지 않으면 컴포넌트를 서버 컴포넌트로 인식한다. \r\n\r\nPost 컴포넌트에서는 페이지 파라미터 값을 통해 데이터를 서버 단에서 가져오고 있다.\r\n우리는 이 데이터를 클라이언트 컴포넌트인 PostInfo에 props로 넘겨줄 것 이다.\r\n\r\n클라이언트 컴포넌트를 사용하고 싶다면 'use client'를 최상단에 쓰면 된다. \r\n```js\r\n'use client'\r\n\r\nexport default async function PostInfo({title, content}) {\r\n\treturn (\r\n\t\t<div> \r\n\t\t\t<h1>{title}</h1> \r\n\t\t\t<p>{content}</p> \r\n\t\t</div>\r\n\t);\r\n}\r\n```\r\nPostInfo는 맨 위에 'use client'를 선언했으므로, **클라이언트 컴포넌트** 이다. 서버 컴포넌트인 Post에서 미리 로드하여 넘겨준 데이터를 props로 받아 화면에 나타내는 역할을 한다.\r\n\r\n이와 같이 Next.js 에서는 여러 API를 사용해서 복잡하게 SSR을 복잡하게 구현해야 하는 react에 비해서 비교적 간단하게 SSR을 구현할 수 있다.\r\n\r\n## + SSG\r\n\r\nSSG(Static Site Generation)는 Next.js에서 페이지를 빌드할 때 미리 HTML 파일로 생성하여 저장해 두고, 사용자가 해당 페이지에 접근할 때 서버 요청 없이 정적 파일을 제공하는 방식이다. \r\n\r\n이는 특히 자주 변경되지 않는 콘텐츠를 가진 블로그와 같은 페이지에서 성능과 SEO 최적화에 유리한 방법이다.\r\n\r\n내 블로그 역시 이와 같은 방식을 사용하고 있는데, Next.js의 page router를 사용하고 있어서 `getStaticProps`와 `getStaticPath`로 SSG를 구현하고 있다.\r\n\r\n- getStaticPaths: 페이지가 접근 가능한 주소를 미리 정의하는 함수이다. 예를 들어, /pages/post/[id]라는 경로가 있고\r\n\t```js\r\n\texport default getStaticPaths = async () => {\r\n\t\treturn {\r\n\t\t\tpaths: [{params: {id: '1'}}, {params: {id:'2'}}],\r\n\t\t\tfallback: false,\r\n\t\t}\r\n\t}\r\n\t```\r\n\t이와 같이 함수가 정의 되어있다면 /post/1과 /post/2 만 접근이 가능하며, 그외의 /posts/3 등은 404를 반환한다. (단, fallback이 true라면 빌드가 되기전까지 fallback 컴포넌트를 보여주고, 그 이후에는 해당 페이지를 보여준다.) \r\n\t\r\n- getStaticProps: 앞에서 정의한 페이지를 기준으로 해당 페이지로 요청이 왔을 때 제공할 props를 반환하는 함수이다. 위에처럼 id가 1과 2로만 제한되므로, fetchPost(1), fetchPost(2)을 기준으로 함수의 응답값을 props의 {post}로 반환한다.\r\n\t```js\r\n\texport const getStaticProps = async ({params}) => {\r\n\t\tconst {id} = params;\r\n\t\tconst post = await fetchPost(id);\r\n\t\t\r\n\t\treturn {\r\n\t\t\tprops: {post}\r\n\t\t}\r\n\t}\r\n\t```\r\n\r\n### 내 블로그에서 사용한 코드\r\n\r\n\r\n```js\r\nexport  function  getStaticPaths() {\r\n\t// 파일들을 모두 받아오고, slug를 추출한다.\r\n\tconst  slugs  =  getAllPosts().map((file:Post) =>  file.slug);\r\n\t// 이 slug들을 경로로 미리 지정한다.\r\n\treturn {\r\n\t\tpaths:  slugs.map((slug:  string) => {\r\n\t\t\r\n\t\t\tconst  detail  =  slug.split('/');\r\n\t\t\t// params에 각각의 경로는 배열로 넘겨줘야 한다. (ex. /posts/detail이면 ['post', 'detail'] 이런 식 으로\r\n\t\t\treturn { params: { detail } };\r\n\t\t}),\r\n\t\tfallback:  false,\r\n\t};\r\n}\r\n```\r\n나의 블로그에서는 getStaticPaths에서는 모든 포스트들의 slug\r\n(slug는 /posts/category/파일명 방식으로 되어있는 파일의 경로로 보면 된다.)를 params로 넘겨주어 경로를 미리 지정했다.\r\n\r\n```js\r\nexport  const  getStaticProps  :GetStaticProps  = ({params}) => {\r\n\r\n\tconst {detail} =  params  as {detail:string[]};\r\n\t// 배열을 다시 문자열로 바꾸고, 여기에 .mdx를 붙인다.\r\n\tconst  detailPath  =  detail.join('/')+'.mdx';\r\n\tconst  postData  =  getPostData(`${detailPath}`);\r\n\r\n\treturn {\r\n\t\tprops: {\r\n\t\t\tpost:  JSON.parse(JSON.stringify(postData)),\r\n\t\t},\r\n\t};\r\n}\r\n```\r\n이후 받아온 params를 사용하여 해당하는 mdx파일을 미리 받아온다.  이를 props로 넘겨주면 페이지에서 이 데이터를 사용할 수 있다.\r\n```js\r\nexport  function  PostDetailPage(props:PostDetailProps) {\r\n\treturn (\r\n\t<>\r\n\t\t<Head>\r\n\t\t\t<title>{props.post.title}</title>\r\n\t\t\t<meta  name=\"description\"  content={`${props.post.summary}`}  />\r\n\t\t</Head>\r\n\t\t<PostDetailLayout  post={props.post} />\r\n\t</>\r\n\t)\r\n}\r\n```\r\nprops로 미리 빌드하여 생성한 데이터를 받아와서 사용하는 모습이다.\r\n(또한 Head태그를 사용하여(page router 기준) 메타데이터 역시 받아온 데이터 정보로 설정하여 SEO에 유리하게 했다.)\r\n\r\n이 두함수를 적절히 설정하고 페이지를 npm run build를 사용했을 때 모습을 보자.\r\n<img src=\"nextjs.png\" alt=\"nextjs\"/>\r\n\r\n앞서 살펴본 상세 페이지인 [...detail]외와 /posts/[caregory], /posts/tag/[tag] 까지 각 페이지 별로 원하는 path와 데이터를 제공했더니 가능한 모든 조합을 빌드 시점에 불러와 페이지로 렌더링했다.\r\n(그래서 뒤지게 배포가 오래 걸린다)\r\n이렇게 페이지를 모조리 빌드해두고 배포하면 사용자는 이미 완성되어 있는 페이지를 받기만 하면 되므로 굉장히 빠르게 해당 페이지를 확인할 수 있다.\r\n\r\n## 마치며\r\n페이지의 다양한 렌더링 방식인 CSR, SSR에 대해서 그리고 더 나아가 SSG에 대해서도 살펴보았다. 뭐가 확실히 더 좋다라기 보다는 각 방식을 확실히 이해하고 상황에 따라 적절히 이를 활용하는 것이 중요할 듯 하다.\r\n"},{"slug":"posts/React/React useState 훅과 클로저","title":"React useState 훅과 클로저","date":"2024-10-26T18:00:24.000Z","image":"index.png","summary":"클로저를 이용한 React useState 훅의 작동 원리를 이해해보자","tags":["react","JavaScript","deepdive","useState","hook","클로저"],"content":"# React useState 훅과 클로저\r\n\r\n클로저에 대해 개념은 알고 있었지만, 사실 면접 질문때나 쓰이는 것이고, 실제로 어떻게 쓰이는지에 대해서는 와닿지 못한 부분도 있었다. 그러던 도중 react deep dive를 공부하며, react 개발자가 아마도 가장 많이 사용하는 **useState**에 클로저가 쓰인다는 사실을 알았다! \r\n어떻게 쓰이는 지 함께 살펴보자.\r\n\r\n\r\n\r\n## 상태값을 어떻게 관리할까\r\n보통 useState의 기본 사용법은 다음과 같을 것이다\r\n```js\r\nimport { useState } from 'react'\r\n\r\nconst [state, setState] = useState\r\n```\r\n인수로 state의 초깃값을 넘겨주고, 만일 아무것도 안넘겨주면 초깃값은 undefined일 것이다.\r\n훅의 반환 값은 배열이고, 배열의 첫 번째 원소는 state 값 자체이며, 두 번째 원소는 setState 함수를 통해 해당 state 값을 변경할 수 있다.\r\n\r\n\r\n**리액트에서 렌더링은 함수 컴포넌트의 return을 실행한 다음, 실행 결과를 이전의 리액트 트리와 비교해 리렌더링이 필요한 부분만 업데이트해 이뤄진다.**\r\n그렇기 때문에 렌더링 방식이랑 메커니즘이 다른 **변수**를 통해서 상태값을 관리하는 것은 적절하지 못하다. (이전 글 react virtualDOM 참고)\r\n\r\n그렇다면 다음 코드를 살펴보자.\r\n\r\n```js\r\nimport React from 'react'\r\n\r\nconst Component = () => {\r\n  const [,triggerRender] = useState()\r\n  let state = 'hello'\r\n\r\n  function handleButtonClick() {\r\n    state = 'hi'\r\n    triggerRender()\r\n  }\r\n  return (\r\n    <>\r\n      <h1>{state}</h1>\r\n      <button onClick={handleButtonClick}>hi</button>\r\n    </>\r\n  )\r\n}\r\n```\r\nuseState 반환값의 두 번째 원소를 실행해 리액트에 렌더링이 일어나게끔 변경했다. \r\n그럼에도 여전히 버튼 클릭시 state의 변경된 값이 렌더링되고 있지 않다. \r\n\r\n그 이유는 리액트의 렌더링은 **함수 컴포넌트에서 반환한 결과물인 return의 값을 비교해 실행되기 때문이다.** \r\n\r\n즉, 매번 렌더링이 발생할 때마다 함수는 새롭게 실행이 되고, 실행한 함수에서 state는 매번 hello로 초기화 되므로 아무리 state를 변경해도 hello로 초기화 되는 것이다. \r\n\r\n근데 렌더링이 될 때마다 초기화되는 변수(값)와는 달리, useState의 결과값은 어떻게 그 값을 유지할까?\r\n\r\n\r\n\r\n그럼 우리가 알고있는 useState는 대체 어떻게 구현이 되있는 것일지 한번 최대한 비슷하게 구현한 코드를 살펴보자.\r\n\r\n**먼저 useState의 결과 값이 유지되도록, state를 함수로 하여 state 값을 호출할 때마다 현재 state를 반환하게 해보자.**\r\n```js\r\nfunction useState(initialValue) {\r\n\tlet initialState = initialValue;\r\n\t\r\n\tfunction state() {\r\n\t\treturn initialState\r\n\t}\r\n\tfunction setState(newValue) {\r\n\t\tinitialState = newValue\r\n\t}\r\n\treturn [state, setState];\r\n}\r\nconst [value, setState] = useState(0);\r\nsetValue(1);\r\nconsole.log(value()); // 1\r\n```\r\n위의 코드도 나쁘진 않지만, 우리에게 익숙한 useState훅은 state를 함수가 아닌 상수처럼 사용하고 있다.\r\n어떻게 그게 가능한 걸까?\r\n\r\n## 클로저를 이용해 상태를 관리하는 useState\r\n이를 위해서 리액트는 **클로저**를 이용한 것이다. \r\nuseState는 클로저를 통해 useState 내부의 선언된 함수(setState)가 함수의 실행이 종료된 이후(useState가 호출된 이후)에도 지역변수인 state를 계속 참조할 수 있다.\r\n\r\nuseState 작동 방식을 대략적으로 흉내 낸 코드는 다음과 같다.\r\n\r\n```js\r\nconst MyReact = (function() {\r\n\tconst global = {}\r\n    let index = 0\r\n    \r\n    function useState(initialState){\r\n    \tif(!global.states) {\r\n    \t// 애플리케이션 전체의 states 배열 초기화, 최초 접근이면 빈 배열로\r\n        \tglobal.states = []\r\n        }\r\n        // states 정보를 조회해서, 현재 상태값이 있는지 확인\r\n        // 없다면 초깃값으로 설정\r\n        const currentState =  global.states[index] || initialState\r\n        // 위에서 조회한 값으로 states의 값 업데이트\r\n        global.states[index] = currentState\r\n        \r\n        // 즉시실행함수로 setter 만듬\r\n        const setState = (function() {\r\n        \t// 클로저로 index를 가둬두어서 동일한 index에 접근이 가능\r\n        \tlet currentIndex = index\r\n            return function(value){\r\n            \tglobal.states[currentIndex] = value\r\n                //컴포넌트 렌더링이 들어가는 부분이다.(실제 코드는 생략)\r\n            }\r\n    })()\r\n    // useState를 쓸 때마다 index를 하나씩 추가하는데, 이는 하나의 state마다\r\n    // index가 할당되어있어, 그 index가 배열의 값(global.states)를 가리키고,\r\n    // 필요할 때마다 그 값을 가져오게 하는 것이다.\r\n    index = index + 1\r\n        \r\n    return [currentState,setState]\r\n}\r\n\r\nfunction Component() {\r\n\tconst [value, setValue] = useState(0);\r\n}\r\n})();\r\n```\r\n\r\n실제 리액트 코드에서는 useReducer를 이용해 구현되어 있어 약간의 차이가 있다.\r\n\r\n아무튼 여기서 함수의 실행이 끝났음에도 함수가 선언된 환경을 기억할 수 있는 방법이 바로 클로저인 것이다. 만약 클로저가 없다면, `setState`는 항상 `index`의 현재 값에 의존하게 된다. 즉, 컴포넌트가 여러 상태를 갖고 있을 때 마지막 `index`만 참조하므로, `setState`가 올바른 위치를 참조하지 않게 되는 것이다.\r\n\r\n매번 실행되는 함수 컴포넌트 환경에서 state의 값을 유지하고 사용하기 위해 리액트는 클로저를 활용하고 있다.\r\n\r\n`\r\n훅에 대한 구현체를 github에서 타고 올라가다보면 __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED 라는 문구를 만나게된다(무섭다 ㅋㅋ)\r\n위의 코드는 Preact의 구현을 기준으로 하고 있다. Preact는 react의 경량화 버전으로,\r\n대부분의 리액트 API를 지원하고 있다. \r\n`\r\n## 결론\r\nReact의 `useState`는 클로저를 통해 상태값을 안정적으로 유지하며, 함수 컴포넌트가 여러 번 호출되더라도 **각 상태값이 고유한 위치에 저장**될 수 있게 한다. `useState`가 반환하는 `setState` 함수는 생성 당시의 상태 위치(`index`)를 클로저로 캡처하여, 해당 상태값만 정확히 업데이트하도록 구현되어 있다.\r\n\r\n정리하자면, 클로저는 `setState`가 함수가 선언된 당시의 환경을 유지하게 해주기 때문에 **컴포넌트가 매번 재실행될 때마다 상태가 초기화되는 것을 방지**하고, 상태가 올바르게 유지될 수 있게 해준다.\r\n\r\n**참고**\r\n\r\n[서적] 모던 리액트 Deep Dive\r\n"},{"slug":"posts/Javascript/클로저에 대하여","title":"클로저에 대하여","date":"2024-10-25T20:00:24.000Z","image":"index.png","summary":"자바스크립트의 어렵지만 중요한 클로저의 개념과 활용 이해해보자","tags":["JavaScript","deepdive","클로저","생명주기"],"content":"# 클로저에 대하여\r\n\r\n면접 질문 중 단골이고, 자바스크립트에 관심이 있다면 한번쯤 들어봤을 개념인 **클로저**.\r\n\r\n사실 많이 난해한 개념이기도 하고, 필자 역시 전에 한번 공부를 해보았지만 아직 확실히 와닿지는 않는 개념이다. \r\n\r\n그래서 이번 기회에 제대로 정리하고 넘어가고자 한다. 함께 이 개념이 대체 뭔지 살펴보자.\r\n\r\n## 클로저의 정의\r\n> 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.\r\n\r\n'이게 뭔소리지?' 싶은가?  나도 그러하다. 위의 정의에서 이해하여야 할 핵심 키워드는 **함수가 선언된 렉시컬 환경**이다.\r\n\r\n ```js\r\n const x = 1;\r\n function outerFunc( ) {\r\n\t const x = 10;\r\n\t function innerFunc( ) {\r\n\t\t console.log(x); // 10\r\n\t}\r\n\tinnerFunc( );\r\n}\r\nouterFunc( );\r\n```\r\n`outerFunc` 내부에서 중첩 함수 `innerFunc`가 정의되고 호출되었다. \r\n\r\n따라서 중첩 함수 `innerFunc` 내부에서 자신을 포함하고 있는 `outerFunc`의 x 변수에 접근할 수 있다. **만약 innerFunc 함수가 outerFunc의 내부에서 정의되지 않았다면, 즉 외부에서 별도로 정의 되었다면** innerFunc를 outerFunc 내부에서 호출해도 outerFunc 함수의 변수에 접근이 불가능하다.\r\n\r\n ```js\r\n const x = 1;\r\n function outerFunc( ) {\r\n\t const x = 10;\r\n\t// 안에서 호출되었지만 접근 불가능\r\n\t innerFunc( );\r\n}\r\nfunction innerFunc( ) {\r\n\t// 상위 스코프인 전역에서 선언된 1\r\n\tconsole.log(x); // 1\r\n}\r\nouterFunc( );\r\n```\r\n\r\n위와 같은 현상은 자바스크립트가 **렉시컬 스코프**를 따르기에 발생한다.\r\n\r\n## 렉시컬 스코프\r\n자바스크립트 엔진은 함수를 **어디서 호출했느냐**가 아니라 함수를 **어디서 정의했는지**에 따라 **상위 스코프를 결정** 한다. \r\n\r\n이를 **렉시컬 스코프**라고 한다.\r\n\r\n위의 예제코드를 다시한번 본다면, outerFunc와 innerFunc는 모두 전역에서 정의 되었고, 함수의 상위 스코프는 함수를 어디서 정의했는지에 따라 결정되므로 **두 함수의 상위 스코프는 모두 전역이다.**\r\n\r\n함수의 상위 스코프는 결국, **함수의 정의된 위치에 따라 정적으로 결정**되고, 함수의 호출된 위치는 어떠한 영향도 주지 못한다.\r\n\r\n>렉시컬환경:  **변수를 저장하고 외부 스코프와 연결을 유지하는 객체**라고 생각하면된다. 자바스크립트에서는 함수가 생성될 때마다 렉시컬 환경이 만들어지며, 함수 내부의 변수뿐 아니라 함수가 선언된 위치에 있는 외부 변수도 기억하게된다.\r\n>\r\n> 코드가 위치한 곳에 따라 **변수와 함수를 어디서 찾아볼지 알려주는 일종의 \"지도\"**라고 생각할 수도 있다\r\n\r\n\r\n렉시컬 환경은 자신의 **외부 렉시컬 환경에 대한 참조**를 통해 상위 렉시컬 환경과 연결이된다.\r\n\r\n따라서 함수의 상위 스코프를 결정한다는 것은, 현재 함수의 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값을 결정한다는 것을 의미한다.\r\n\r\n렉시컬 스코프를 다시한번 정의해보자면, 렉시컬 환경의 \"외부 렉시컬 환경에 대한 참조\"에 저장한 참조값, 즉 상위 스코프에 대한 참조는 **함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)**에 의해 결정되는 것이라고 할 수 있다. \r\n\r\n\r\n\r\n**함수는 자신의 내부슬롯 [[Environment]]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.** \r\n이곳을 참조해서 자신이 호출되었을 때 생성될 함수 렉시컬환경의 \"외부 렉시컬 환경에 대한 참조\"에 저장될 참조값을 보고, 자신이 존재하는 한, 이 [[Environment]] 슬롯에 저장한 렉시컬 환경의 참조, 즉 **상위 스코프**를 기억한다.\r\n\r\n## 클로저와 렉시컬환경\r\n그렇다면 다음의 코드를 살펴보자\r\n```js\r\nconst x = 1 ;\r\nfunction outer() {\r\n\tconst x = 10;\r\n\tconst inner = function ( ) {console.log(x)}\r\n\t//inner함수 반환\r\n\treturn inner;\r\n}\r\n// outer함수를 호출하면 중첩 함수 inner를 반환한다.\r\n// 그리고 outer 함수의 실행 컨텍스트는 제거된다.\r\nconst innerFunc = outer( );\r\ninnerFunc( )// 10\r\n```\r\nouter함수를 호출하면 outer함수는 중첩함수 inner를 반환하고 생명주기를 마감한다. \r\n\r\n즉 outer함수의 실행이 종료되었으므로, 실행컨텍스트가 제거된다. (실행컨텍스트 스택에서 pop된다.)\r\n\r\n이때 outer 함수의 지역변수x 역시 생명주기를 마감했으므로, 실행 컨텍스트가 제거되어 유효하지 않아 보인다.\r\n\r\n그러나 위의 실행 결과는 outer 지역 변수x 의 값인 10을 반환한다. 이미 생명 주기가 종료되어 outer 함수의 지역변수 x가 실행 컨텍스트 스택에서 제거되었는데도 다시 부활이라도 한 것 마냥 말이다. \r\n\r\n이처럼 **외부 함수보다 중첩함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명주기가 종료한 외부함수의 변수를 참조**할 수 있다. \r\n\r\n이러한 **중첩 함수를 클로저**라고 부른다.\r\n\r\n다시 정의로 돌아가보자.\r\n> 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.\r\n\r\n위 정의를 예제에 대입해보자면 `함수`는 반환된 `중첩함수(inner)`를 의미하고 `그 함수가 선언될 때의 렉시컬 환경(Lexical environment)`란 그 `중첩 함수(inner)가 정의됐을 때의 스코프`를 의미하는 것이다.\r\n\r\n즉, **클로저는 반환된 중첩 함수가 자신이 선언됐을 때의 렉시컬 환경 즉, 스코프를 기억하여 자신이 선언됐을 때의 렉시컬 환경 밖에서 호출되어도 그 렉시컬 환경(스코프)에 접근할 수 있는 함수**를 말한다. \r\n\r\n조금 더 간단히 말하면 **클로저는 자신이 생성될 때의 상위 스코프(렉시컬 환경)을 기억하는 함수이다**\r\n\r\n<img src = \"그림1.jpg\" width=\"800\" height=\"500\" />\r\n\r\n\r\ninner 함수의 [[Environment]] 슬롯이 outer 함수의 렉시컬 환경을 참조하고, inner가 전역 변수 innerFunc에 저장되어 계속 사용되고 있으므로, 이와 연결된 모든 요소는 가비지 컬렉터에 의해 제거되지 않습니다.\r\n\r\n\r\n> **가비지 컬렉터(Garbage Collector)는 프로그램이 더 이상 사용하지 않는 메모리를 자동으로 해제해 주는 자바스크립트 엔진의 기능**이다.\r\n> \r\n> 가비지 컬렉터는 특정 메모리 공간이 더 이상 참조되지 않을 때 그 공간을 \"가비지\"로 판단하여 메모리를 해제한다.  반대로, **누군가가 참조하고 있는 메모리 공간은 함부로 해제하지 않는다**.\r\n\r\n클로저는 자바스크립트의 강력한 기능으로, 필요하다면 적극 활용해야 한다. 클로저가 유용하게 사용되는 상황을 살펴보자.\r\n\r\n## 클로저의 활용\r\n\r\n### 상태를 안전하게 변경하고 유지할 때\r\n\r\n클로저는 **상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고, 특정 함수에게만 상태 변경을 허용하여, 상태를 안전하게 변경하고 유지할 수 있도록 사용한다.**\r\n```js\r\nconst counter = (function ( ) {\r\n// 은닉된 상태 (외부에서 접근 불가)\r\nlet num = 0;\r\n// 클로저인 메서드를 갖는 객체를 반환한다.\r\n// 객체 리터럴은 스코프를 만들지 않는다.\r\n// 따라서 아래 메서드들의 상위 스코프는 즉시 실행 함수의 렉시컬 환경이다.\r\nreturn {\r\n\tincrease() {\r\n\t\treturn ++num;\r\n\t}\r\n\tdecrease() {\r\n\t\treturn num>0? --num: 0;\r\n\t}\r\n}());\r\n\r\nconsole.log(counter.increase()); // 1\r\nconsole.log(counter.decrease()); // 2\r\n\r\nconsole.log(counter.decrease()); // 1\r\nconsole.log(counter.decrease()); // 0\r\n```\r\n즉시 실행 함수는 호출된 이후 소멸되지만, 즉시 실행 함수가 반환한 클로저(increase, decrease)는  **자신의 상위 스코프인 즉시 실행함수의  렉시컬 환경을 기억하고 있다**. \r\n\r\n이 코드에서 \r\n- 카운터 상태(num 변수의 값)은 increase, decrease 함수가 호출되기 전까지 변경되지않고 유지되며 **외부에서 접근할 수 없다**.\r\n- 카운터 상태는 오직 **increase, decrease로 정의된 함수로만 변경이 가능**하다.\r\n\r\n\r\n\r\n이처럼 클로저는 **상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정함수에게만 상태 변경을 허용하여 상태를 안전하게 변경하고 유지하기 위해 사용**된다.\r\n\r\n### 전역변수의 사용을 억제할 때\r\n\r\n클로저는 전역 변수 사용을 억제하고 대신 **함수 내부의 변수로 상태를 관리**할 수 있도록 도와준다. 이렇게 하면 전역 변수를 사용하지 않고도 데이터가 안전하게 유지되며, 다른 코드와 충돌하지 않는 이점을 얻을 수 있다.\r\n\r\n```js\r\nlet counter = 0; // 전역 변수\r\n\r\nfunction incrementCounter() {\r\n    counter += 1;\r\n    return counter;\r\n}\r\n\r\nconsole.log(incrementCounter()); // 1\r\nconsole.log(incrementCounter()); // 2\r\nconsole.log(counter); // 전역 변수에 접근 가능 (위험)\r\n```\r\n위 코드에서는 `counter`가 전역에 선언되어 있기 때문에 어디서든 접근 가능하여,  이러면 다른 코드에서 `counter`를 실수로 변경할 위험이 있다.\r\n```js\r\nfunction createCounter() {\r\n    let counter = 0; // 함수 내부 변수로 관리\r\n\r\n    return function() {\r\n        counter += 1;\r\n        return counter;\r\n    };\r\n}\r\n\r\nconst incrementCounter = createCounter();\r\n\r\nconsole.log(incrementCounter()); // 1\r\nconsole.log(incrementCounter()); // 2\r\nconsole.log(typeof counter); // 'undefined' - 전역에서 접근 불가\r\n```\r\n\r\n이 코드에서는 `counter` 변수가 **`createCounter` 함수 내부에만 존재**하므로 외부에서 직접 접근하거나 수정할 수 없다. \r\n\r\n대신, `incrementCounter` 함수는 **클로저를 통해 `counter`를 기억**하고 있으므로 호출할 때마다 `counter`를 안전하게 증가시킬 수 있다.\r\n\r\n이처럼, 클로저를 사용하면 함수 내 지역 변수를 통해 상태를 관리하게 되어 **전역 변수를 사용하지 않아도 안전하게 데이터 상태를 유지**할 수 있다.\r\n\r\n### React의 useState\r\n\r\n이런 이점을 활용하여 react의 useState에도 클로저가 활용된다.\r\n\r\n`useState`를 사용하면 컴포넌트 내에서 **상태를 관리**하게 되는데, 이 상태가 **컴포넌트가 렌더링될 때마다 유지**되도록, 또한 `setState` 함수로만 상태가 변경되도록 하는 데에 클로저가 활용되는 것이다.\r\n\r\n이와 관련하여서는 다음 포스팅에서 자세하게 다룰 예정이다.\r\n\r\n\r\n## 결론\r\n\r\n지금까지 자바스크립트의 어렵지만 주요한 개념인 클로저에 대해 살펴보았다.\r\n\r\n**클로저**는 **함수와 그 함수가 선언된 렉시컬 환경의 조합으로, 자바스크립트에서 함수는 자신이 정의된 위치에 따라 상위 스코프를 결정하는 렉시컬 스코프**를 따르므로, \r\n중첩 함수가 외부 함수의 스코프를 참조하여 외부함수가 생명주기가 끝났음에도 그 함수의 변수를 참조할 수 있는 함수를 의미한다."},{"slug":"posts/React/[React DeepDive] React의 가상 DOM","title":"[React DeepDive] React의 가상 DOM","date":"2024-09-25T12:00:24.000Z","image":"React.svg","summary":"리액트 딥다이브 책 내용 중 '가상 DOM과 파이버'의 정리 내용입니다.","tags":["react","deepdive","Virtual DOM"],"content":"# [React DeepDive] React의 가상 DOM\r\n\r\n\r\n리액트의 특징 중 하나는 실제 DOM이 아닌 가상 DOM을 운영한다는 것이다. 이번 글에서는 React DeepDive에서 다루는 **가상 DOM이 무엇인지**, **그리고 실제 DOM에 대해 어떤 이점이 있는지 살펴보고**, 가상 DOM을 다룰 때 **주의할 점**에 대해서도 다루려고 한다.\r\n\r\n## DOM과 브라우저 렌더링 과정\r\n> **DOM**: 웹페이지에 대한 인터페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.\r\n\r\n브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정은 다음과 같다.\r\n\r\n<img src=\"트리를 그리는과정.png\" alt=\"트리를 그리는 과정\" width=\"800\" height=\"600\"/>\r\n\r\n\r\n1. 브라우저가 사용자 요청한 주소에서 HTML파일을 다운로드한다.\r\n\r\n2. 브라우저의 렌더링 엔진이 HTML을 파싱해 DOM노드로 구성된 트리 즉, `DOM`을 만든다.\r\n3. 2번 과정에서 CSS파일을 만나면 해당 CSS 파일도 다운로드한다.\r\n4. 브라우저의 렌더링 엔진이 이 CSS역시 파싱해 CSS 노드로 구성된 트리 즉, `CSSOM`을 만든다\r\n5. 브라우저는 DOM 노드를 순회하는데 모든 노드가 아닌, **사용자 눈에 보이는 노드만**(display:none과 같은 노드는 방문 x) 방문한다.\r\n6. 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. \r\n>\t-  `레이아웃`: 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정이며, 이 과정을 거치면 **페인팅 과정도 거치게 된다.**\r\n>-  `페인팅`: 레이아웃 단계를 거친 노드의 색과 같은 **실제 유효한 모습을 그리는 과정**\r\n\r\n## 가상 DOM의 탄생 배경\r\n\r\n### 웹페이지를 추가로 렌더링 하는데 드는 비용\r\n앞에서 살펴본 브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다. \r\n\r\n또한 정보를 보여주는데 그치지 않고 사용자의 인터렉션을 통해 다양한 정보를 노출해야 하기에, 렌더링이 완료된 이후에도 **사용자의 인터렉션으로 웹페이지가 변경되는 상황** 또한 고려해야 한다.\r\n\r\n이 과정에서 예를 들어,\r\n- 특정 요소의 색상이 변경되는 경우: 페인팅만이 일어나서 빠른처리가 가능하다.\r\n\r\n- **특정 요소의 노출 여부나 사이즈가 변경되는 경우**: 레이아웃이 일어나고, 레이아웃은 **필연적으로 리페인팅을 발생**하기 때문에 더 많은 비용이 든다.\r\n\r\n- DOM 변경이 일어나는 요소가 **자식 요소를 많이 가지고 있는 경우**: 하위 자식 요소 역시 변경되야 해서 더 많은 비용 지불\r\n\r\n이러한 추가 렌더링 작업은 하나의 페이지에서 모든 작업이 일어나는 `싱글 페이지 애플리케이션(SPA)`에서 더 많아진다. \r\n\r\n페이지가 변경될 때 처음부터 HTML을 새로 받아서 다시금 렌더링 과정을 시작하는 일반적인 웹페이지와는 다르게, 하나의 페이지에서 계속해서 요소의 위치를 재계산하게 된다.\r\n\r\n그러므로 라우팅이 변경되는 경우 고정된 헤더와 같은 요소들을 제외하고 대부분의 요소를 삭제, 삽입 및 요소의 위치를 다시 계산해야 하므로, DOM을 관리하는 과정에서 부담하는 비용이 커진다.\r\n\r\n### 가상 DOM의 탄생\r\n사용자의 인터렉션에 따라 DOM의 모든 변경 사항을 추적하는 것은 개발자에게는 너무나 수고스러운 일이다.  그렇기에 모든 DOM의 변경보다 **결과적으로 만들어지는 DOM 결과물 하나만 아는 것**이 개발자의 입장에서 더 유용할 것이다.\r\n\r\n이것을 해결하기 위해 탄생한 것이 바로 `가상 DOM`이다.  \r\n가상 DOM은 실제 브라우저가 아닌 리액트가 관리하는 가상의 DOM을 의미한다.\r\n\r\n가상 DOM은 웹페이지가 표시해야 할 DOM을 일단 **메모리에 저장**하고, 리액트가 실제 변경에 대한 준비가 완료되었을 때, 실제 브라우저의 DOM에 반영한다.\r\n\r\n이렇게 DOM 계산을 메모리에서 계산하는 과정을 한 번 거치게 된다면 실제로는 여러 번 발생했을 렌더링 과정을 최소화하여 부담을 덜 수 있다.\r\n\r\n> 가상 DOM은 **일반적인 브라우저보다 무조건 항상 빠르지는 않다**. \r\n>\r\n> 무조건 빠른 것이 아닌, 대부분의 상황에서 웬만한 애플리케이션을 만들 정도로 충분히 빠르다고 보는 것이 옳다.\r\n\r\n## 가상 DOM을 위한 아키텍처, 리액트 파이버\r\n가상 DOM과 렌더링 과정 최적화를 가능하게 해주는 것이 `리액트 파이버`이다.\r\n\r\n`리액트 파이버`는 리액트에서 관리하는 평범한 자바스크립트 객체이다. \r\n`파이버`는 `파이버 재조정자(fiber reconciler)`가 관리하는데, 가상 DOM과 실제 DOM을 비교하여 변경에 관련된 정보를 가지고 있는 파이버를 기준으로 화면에 렌더링을 요청하는 역할을 한다.\r\n\r\n> 재조정(reconcilation): 리액트에서 어떤 부분을 새로 렌더링 해야하는지 가상 DOM과 실제 DOM을 비교하는 과정 \r\n\r\n파이버는 애니메이션,레이아웃,사용자 인터랙션에 올바른 결과물을 만드는 반응성 문제를 해결하며, 다음과 같은 일을 할 수 있다.\r\n-  작업을 작은 단위로 쪼개고  **우선순위를  매긴다.**\r\n\r\n-  이 작업들은 일시 정지 및 다시 시작이 가능하다.\r\n\r\n- 이전 작업을 재사용 하거나 필요 없는 경우에는 폐기할 수 있다.\r\n\r\n이러한 모든 과정은 **비동기로 일어난다**. 과거에는 이러한 조정 알고리즘이 동기적인 스택 알고리즘으로 이뤄져 있었고, 동기적으로 작업이 이뤄졌기에 자바스크립트의 싱글 스레드의 특징 상 수행 중인 작업은 중단될 수 없었다. \r\n이러한 문제 때문에 리액트 팀은 스택 조정자 대신 파이버라는 개념을 탄생시킨다.\r\n\r\n### 파이버는 어떻게 구현되어 있을까?\r\n`파이버`는 일단 하나의 작업 단위로 구성되어 있다. 리액트는 작업 단위를 하나씩 처리하고, **finishWork( )** 라는 작업으로 마무리한다. 그리고 이 작업을 커밋해 브라우저 DOM에 가시적인 변경 사항을 만들어 낸다. \r\n이러한 단계는 두 단계로 나뉘는데,\r\n- `렌더 단계`: 사용자에게 노출되지 않는 모든 **비동기** 작업을 수행하고, **우선 순위를 지정하거나 중지시키거나 버리는 등의 작업이 일어난다.**\r\n- `커밋 단계`: DOM에 실제 변경 사항을 반영하기 위한 작업, commitWork( )가 실행되는데, **동기식**으로 일어나고 중단될 수 없다.\r\n\r\n파이버는 실제 리액트 코드에서 이렇게 구현되어 있다.\r\n```js\r\nfunction FiberNode(tag, pendingProps, key, mode) {\r\n  // Instance\r\n  this.tag = tag;\r\n  this.key = key;\r\n  this.elementType = null;\r\n  this.type = null;\r\n  this.stateNode = null;\r\n\r\n  // Fiber\r\n  this.return = null;\r\n  this.child = null;\r\n  this.sibling = null;\r\n  this.index = 0;\r\n\r\n  this.ref = null;\r\n\r\n  this.pendingProps = pendingProps;\r\n  this.memoizedProps = null;\r\n  this.updateQueue = null;\r\n  this.memoizedState = null;\r\n  this.dependencies = null;\r\n\r\n  this.mode = mode;\r\n\r\n  // Effects\r\n  this.effectTag = NoEffect;\r\n  this.nextEffect = null;\r\n\r\n  this.firstEffect = null;\r\n  this.lastEffect = null;\r\n\r\n  this.expirationTime = NoWork;\r\n  this.childExpirationTime = NoWork;\r\n\r\n  this.alternate = null;\r\n}\r\n```\r\n위와 같이 파이버는 단순한 자바스크립트 객체로 구성되어 있다. \r\n파이버와 리액트 요소의 한가지 중요한 차이점은 `리액트 요소`는 렌더링이 발생할 때 마다 새롭게 생성되지만, `파이버`는 컴포넌트가 최초로 마운트 되는 시점에 생성되어 **가급적이면 재사용된다**는 것이다.\r\n\r\n```js\r\nfunction createFiber(tag, pendingProps, key, mode) {\r\n  return new FiberNode(tag, pendingProps, key, mode);\r\n}\r\n```\r\n```js\r\nfunction createFiberFromElement(element, mode, expirationTime) {\r\n  let owner = null;\r\n  const type = element.type;\r\n  const key = element.key;\r\n  const pendingProps = element.props;\r\n  const fiber = createFiberFromTypeAndProps(\r\n    type,\r\n    key,\r\n    pendingProps,\r\n    owner,\r\n    mode,\r\n    expirationTime,\r\n  );\r\n\r\n  return fiber;\r\n}\r\n```\r\n이제 여기서 선언된 주요 속성을 살펴보면서 어떤 내용을 담고 있는지 살펴보자.\r\n\r\n-   `tag`  : 파이버는 하나의 element에 하나의 파이버가 생성되어 1:1 관계를 가진다. 여기서 **1:1로 매칭된 정보를 가지고 있는 것**이 tag필드이다. 연결되는 것은 컴포넌트, DOM노드 등이 될 수 있는데, 될 수 있는 것들은 다음과 같다.\r\n-  `stateNode`: 이 속성은 파이버 자체에 대한 참조 정보를 가지고 있다.\r\n-  `child`,  `sibling`,  `return`  : 파이버 간의 관계 개념을 나타내는 속성이다. 파이버는 트리 형식을 구성하는데 이 트리 형식을 구성하는데 필요한 정보가 이 속성 내부에 적용된다. 한 가지 리액트 컴포넌트 트리와 다른 점은 children이 없다는 것 즉 **단 하나**의 `child`만이 존재한다는 것이다.\r\n\r\n\t여러 개의 자식이 존재할 경우 항상 **첫 번째 자식의 참조**로 구성되며, 나머지는 자식들은 동등한 `sibling`으로 구성, `return`은 부모 파이버를 의미한다.\r\n\r\n-  `index` : 여러 형제들 사이에서 자신의 위치를 나타낸다.\r\n- `pedingProps`  : 아직 처리하지 못한 props\r\n-   `memoizedProps`  : pendingProps를 기준으로 렌더링이 완료된 이후에 pendingProps를 memoizedProps에 저장하여 관리한다.\r\n-  `updateQueue`  : 상태 업데이트, 콜백 함수, DOM 업데이트 등 작업을 담아두는 Queue.\r\n- `memoizedState`  : 함수 컴포넌트의 훅 목록이 저장된다.\r\n-  `alternate`: 뒤이어 설명할 리액트 파이버 트리와 이어질 개념. 리액트의 트리는 두 개인데, alternate는 반대 트리의 파이버를 가리킨다.\r\n\r\n이렇게 생성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다. \r\n이러한 작업들은 작은 단위로 나눠서 처리할 수도, 애니메이션과 같이 우선순위가 높은 작업은 빨리 처리하거나, 낮은 작업을 연기시키는 등 좀 더 유연하게 처리된다.\r\n\r\n\r\n리액트 개발 팀은 사실 리액트는 가상 DOM이 아닌 Value UI, 즉 값을 가지고 있는 UI를 관리하는 라이브러리라는 내용을 피력한 바가 있다. \r\n\r\n즉, 리액트의 핵심원칙은 **UI를 문자열, 숫자, 배열과 같은 값으로 관리한다는 것**이다. \r\n변수에 이러한 UI관련 값을 보관하고, 리액트의 자바스크립트 코드 흐름에 따라 이를 관리하고, 표현하는 것이 바로 리액트다.\r\n\r\n### 파이버 트리\r\n파이버 트리는 하나는 **현재 모습을 담은** 파이버 트리, 다른 하나는 작업 중인 상태를 나타내는 **workInProgress** 트리다. 작업이 끝나면, 리액트는 **단순히 포인터만 변경**해 workInProgress 트리를 **현재 트리**로 바꿔버린다. 이러한 기술을 **더블 버퍼링**이라고 한다.\r\n<img src=\"파이버 트리.png\" alt=\"트리를 그리는 과정\" width=\"800\" height=\"600\"/>\r\n\r\n리액트에서는 미처 다 그리지 못한 모습을 노출시키지 않기 위해 (불완전한 트리를 보여주지 않기 위해) 더블 버퍼링 기법을 쓰는데, 이러한 더블 버퍼링을 위해 트리가 두 개 존재하며, 이 더블 버퍼링은 커밋 단계에서 수행된다.\r\n\r\n- 먼저 현재 UI 렌더링을 위해 존재 하는 **current**를 기준으로 모든 작업이 시작된다.\r\n- 업데이트가 발생하면 파이버는 리액트에서 새로 받은 데이터로 새로운 **workInProgress** 트리를 빌드하기 시작한다.\r\n- 빌드하는 작업이 끝나면 다음 렌더링에 이 트리를 사용한다.\r\n- 빌드된 workInProgress 트리가 UI에 최종적으로 렌더링되어 반영이 완료되면 **current가 이 workProgress로 변경된다**.\r\n\r\n### 파이버의 작업 순서\r\n일반적인 파이버 노드의 생성흐름은 다음과 같다.\r\n1. 리액트는 `beginWork()` 함수를 실행해 파이버 작업을 수행하고, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.\r\n2. 1번의 작업이 끝나면 `completeWork( )` 함수를 실행해 파이버 작업을 완료한다.\r\n3. 형제가 있다면 형제로 넘어간다.\r\n4. 2,3번이 끝난다면 `return`으로 돌아가 자신의 작업이 완료되었음을 알린다.\r\n\r\n이러한 작업으로 트리가 생성이 되었는데, setState 등으로 업데이트가 발생하면 어떻게 될까? 이미 앞서 만든 current트리가 존재하고, setState로 업데이트 요청을 받아 workInProgress트리를 다시 빌드하기 시작한다. \r\n\r\n최초 렌더링 시에는 모든 파이버를 새로 만들어야 했지만 이제는 파이버가 이미 존재하므로 되도록 새로 생성하지 않고, **기존 파이버에서 업데이트 된 props를 받아 파이버 내부에서 처리한다**.\r\n\r\n이처럼, 재조정 작업 때마다 새롭게 파이버 자바스크립트 객체를 만드는 것 이 아닌, 기존의 객체를 재활용하기 위해 내부 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트한다.\r\n\r\n과거에는 이 작업을 동기식으로 처리했고, 트리 업데이트 과정 및 새로운 트리를 만드는 작업은 동기식이고 중단될 수 없다. 그러나 현재는 우선순위가 높은 다른 업데이트가 오면 현재 업데이트 작업을 일시 중단하거나 새로 만들거나 폐기할 수 있으며 작업 단위를 파이버 단위로 나누어 우선순위를 할당하는 것 역시 가능하다.\r\n\r\n### 파이버와 가상 DOM\r\n리액트 컴포넌트에 대한 정보를 **1:1로 가지고 있는 것**이 파이버이며, 이 파이버는 리액트 아키텍처 내부에서 **비동기**로 이뤄진다. 이와 달리 실제 브라우저 구조인 DOM에 반영하는 것은 동기적으로 이뤄져야 하기에, 메모리 상에서 이 작업을 먼저 수행해서 최종적인 결과물만 실제 브라우저 DOM에 적용하는 것이다.\r\n\r\n> 사실 가상 DOM은 오직 웹 어플리케이션에서만 통용되는 개념이고, 리액트 파이버는 리액트 네이티브와 같은 브라우저가 아닌 환경에서도 사용할 수 있기에 엄밀히 하면 파이버와 가상 DOM은 동일한 개념이 아니다. \r\n\r\n### 정리\r\n결국 가상 DOM과 리액트의 핵심은 **브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아니라 바로 값으로 UI를 표현하는 것**이다. \r\n\r\n화면에 표시되는 UI를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고 이러한 흐름을 효율적으로 관리하기 위한 메커니즘이 바로 리액트의 핵심이다."}]},"__N_SSG":true}
{"pageProps":{"tags":["react","JavaScript","deepdive","useState","hook","next.js","SSR","Suspense","렌더링","테스트","트러블슈팅","dev tools","SSG","Algorithm","프로그래머스","PCCP","lv2","이분탐색","클로저","생명주기","Virtual DOM","백준","gold","dfs","lv3","bfs","all"],"currentTag":"hook","posts":[{"slug":"posts/React/setState는 비동기일까","title":"setState는 비동기일까","date":"2025-03-11T13:00:24.000Z","image":"index.png","summary":"setState가 왜 동기 함수인지, 그리고 react서는 setState를 통해 상태 업데이트를 어떻게 하는지 알아보자.","tags":["react","JavaScript","deepdive","useState","hook"],"content":"# setState는 비동기일까?\r\n\r\n## 🔹setState가 왜 바로 반영이 안되지?\r\nReact에서 `setState`를 사용하다 보면, 처음에 많은 프론트엔드 개발자들이 한 가지 의문을 가지게 된다.\r\n```js\r\nconst [count, setCount] = useState(0);\r\n\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  console.log(count);\r\n};\r\n```\r\n`console.log(count)`에서는 업데이트된 값인 **1**이 출력되어야 할거같지만,  그게 아닌아니라 **0**이 출력됩니다.\r\n\r\n코드만 봤을 때는 업데이트된 값인 1이 출력되는게 맞는 거 같은데 **왜 이전 값인 0이 출력되는걸까?** async await를 쓰지 않지만 setState가 비동기라 그런걸까?\r\n\r\n결론부터 말하자면 setState는 **비동기 처럼 동작하지만, 실제로는 동기함수이다.**\r\n 이에 대해 자세히 살펴보자.\r\n\r\n## 🔹 setState의 동작방식\r\n\r\nsetState 자체는 동기적으로 실행되지만, setState로 인한 상태업데이트와 렌더링은 비동기적으로 이루어진다. \r\n\r\n왜 setState가 동기적인지는 우선 이따가 살펴보고, 우선 setState의 동작방식에 대해 알아보자.\r\n\r\n\r\n```js\r\nconst [count, setCount] = useState(0);\r\n\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  console.log(count); // 출력값은 1이다.\r\n};\r\n```\r\n아까 전 살펴봤던 코드이다. 왜 업데이트 된 값이 바로 반영이 안되었던 걸까?\r\n\r\n이유는 React는 최적화를 위해 상태 변경을 비동기적으로 처리하고 있기 때문입니다.\r\n\r\n### 배치 업데이트 (Batching)\r\nReact는 여러 개의 `setState` 호출을 하나로 비동기적으로 묶어서 처리하고, 이것을 **배치(batch) 업데이트**를 수행한다고합니다.  \r\n즉, 같은 이벤트 핸들러에서 여러 개의 `setState`가 호출되더라도 **한 번의 렌더링에서 처리**됩니다. \r\n\r\n```js\r\nconst handleClick = () => {\r\n  setCount(10);\r\n  setCount(count + 1);\r\n  setCount(30);\r\n  console.log(\"현재 count 값:\", count);\r\n};\r\n```\r\n즉 위의 3개의 setState는 한번에 함수 내 에서 하나씩 순서대로 실행되는 것이 아닌, **비동기적으로 한번에 처리가 되는 것 이다.**\r\n\r\n그렇다면 다음 코드를 보자.\r\n```js\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  setCount(count + 1);\r\n  setCount(count + 1);\r\n  console.log(\"현재 count 값:\", count);\r\n};\r\n```\r\n다음과 같은 경우 현재 count 값이 0으로 출력되는 것은 이제 알 것이다.\r\n```js\r\n현재 count 값: 0  // 이전 값이 출력\r\n```\r\n그렇다면 최종적으로 count 값은 몇이 될까? `\r\n\r\n`setCount(count + 1)`가 3번 호출되었지만, 최종적으로 `count` 값은 **1만 증가**한다.\r\n\r\n이유는 역시 React는 동일한 이벤트 핸들러 내에서 여러 개의 `setState`를 **배치 처리**하여 하나로 합쳐버리기 때문이다.\r\n즉, \r\n```js\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\n\r\n```\r\n-   `setState`는 바로 실행되지만, **이벤트 핸들러 내부에서는 `count` 값이 0으로 유지됨**\r\n-   따라서 모든 `setCount(count + 1)`은 결국 `setCount(1)`과 동일\r\n\r\n만일 의도한 바대로 count를 1씩증가시켜 3으로 만들고 싶다면, \r\n```js\r\nconst handleClick = () => {\r\n  setCount(prev => prev + 1);\r\n  setCount(prev => prev + 1);\r\n  setCount(prev => prev + 1);\r\n};\r\n```\r\n이런 식으로 코드를 짜면, 배치 처리와 상관없이 이전 값을 기반으로 상태를 변경한다.\r\n\r\n이렇게 setState는 React내에서 비동기적으로 상태 업데이트를 진행하는데, 왜 그럼에도 동기함수라고 하는걸까?\r\n\r\n## 🔹 setState가 동기함수인 이유\r\n\r\n**setState**의 상태 업데이트는 React내에서 배치처리를 통해 비동기적으로 이루어지지만, setState 자체는 **호출 즉시 실행**되므로 **동기 함수**이다.\r\n\r\n즉, 예를들어서,\r\n```js\r\nconst handleClick = () => {\r\n  console.log(\"Before setState:\", count);\r\n  setCount(count + 1);\r\n  console.log(\"After setState:\", count);\r\n};\r\n```\r\n위의 `setCount(count + 1);` 함수 자체는 실행될 때, 실행되는 즉시 함수가 종료가 된다. \r\n`setCount`가 진짜 비동기 함수였다면, **비동기 작업(Promise 등)을 반환**해야 하지만 그런 동작을 하지 않는 것이다.\r\n\r\n다만 setCount가 실행되어 상태 변경을 요청하면, \r\n**React가 이 요청을 현재 수행중인 이벤트가 핸들러가 끝날 때까지 기다린 후 배치처리를 수행하는 것이다.**\r\n \r\n setState가 비동기 함수 였다면,\r\n ```js\r\n const handleClick = async () => {\r\n  console.log(\"Before setState:\", count);\r\n  await setCount(count + 1);  //  실제로는 이렇게 사용 불가능\r\n  console.log(\"After setState:\", count);\r\n};\r\n ```\r\n 이런식으로 사용할 수 있어야 하지만, `setState`는 Promise를 반환하지 않으므로 `await`을 사용할 수 없다.\r\n \r\n 즉 setState는 **React의 내부적인 상태 업데이트와 렌더링 방식**으로 인해 비동기적으로 실행되는 것처럼 보이지만 엄밀히 말하면 **동기 함수**이다.\r\n\r\n## 결론\r\n\r\nsetState를 통해 React가 상태를 업데이트하는 과정을 정리하면 다음과 같다.\r\n\r\n1.  `setState` 호출 → 상태 변경 요청 (동기적으로 동작)\r\n2.  React가 현재 실행 중인 이벤트 핸들러가 끝날 때까지 기다림\r\n3.  **배치 처리**를 수행하여 여러 개의 `setState`를 한꺼번에 처리(비동기적 최적화)\r\n4.  상태 업데이트 후 리렌더링을 트리거\r\n\r\n`setState`는 동기적으로 실행되지만,  React의 **상태 변경과 렌더링 과정이 비동기적으로 최적화되어 실행된다.**"},{"slug":"posts/React/React useState 훅과 클로저","title":"React useState 훅과 클로저","date":"2024-10-26T18:00:24.000Z","image":"index.png","summary":"클로저를 이용한 React useState 훅의 작동 원리","tags":["react","JavaScript","deepdive","useState","hook","클로저"],"content":"\r\n# React useState 훅과 클로저\r\n\r\n클로저에 대해 개념은 알고 있었지만, 사실 면접 질문때나 쓰이는 것이고, 실제로 어떻게 쓰이는지에 대해서는 와닿지 못한 부분도 있었다. 그러던 도중 react deep dive를 공부하며, react 개발자가 아마도 가장 많이 사용하는 **useState**에 클로저가 쓰인다는 사실을 알았다! \r\n어떻게 쓰이는 지 함께 살펴보자.\r\n\r\n\r\n\r\n## 상태값을 어떻게 관리할까\r\n보통 useState의 기본 사용법은 다음과 같을 것이다\r\n```js\r\nimport { useState } from 'react'\r\n\r\nconst [state, setState] = useState\r\n```\r\n인수로 state의 초깃값을 넘겨주고, 만일 아무것도 안넘겨주면 초깃값은 undefined일 것이다.\r\n훅의 반환 값은 배열이고, 배열의 첫 번째 원소는 state 값 자체이며, 두 번째 원소는 setState 함수를 통해 해당 state 값을 변경할 수 있다.\r\n\r\n\r\n**리액트에서 렌더링은 함수 컴포넌트의 return을 실행한 다음, 실행 결과를 이전의 리액트 트리와 비교해 리렌더링이 필요한 부분만 업데이트해 이뤄진다.**\r\n그렇기 때문에 렌더링 방식이랑 메커니즘이 다른 **변수**를 통해서 상태값을 관리하는 것은 적절하지 못하다. (이전 글 react virtualDOM 참고)\r\n\r\n그렇다면 다음 코드를 살펴보자.\r\n\r\n```js\r\nimport React from 'react'\r\n\r\nconst Component = () => {\r\n  const [,triggerRender] = useState()\r\n  let state = 'hello'\r\n\r\n  function handleButtonClick() {\r\n    state = 'hi'\r\n    triggerRender()\r\n  }\r\n  return (\r\n    <>\r\n      <h1>{state}</h1>\r\n      <button onClick={handleButtonClick}>hi</button>\r\n    </>\r\n  )\r\n}\r\n```\r\nuseState 반환값의 두 번째 원소를 실행해 리액트에 렌더링이 일어나게끔 변경했다. \r\n그럼에도 여전히 버튼 클릭시 state의 변경된 값이 렌더링되고 있지 않다. \r\n\r\n그 이유는 리액트의 렌더링은 **함수 컴포넌트에서 반환한 결과물인 return의 값을 비교해 실행되기 때문이다.** \r\n\r\n즉, 매번 렌더링이 발생할 때마다 함수는 새롭게 실행이 되고, 실행한 함수에서 state는 매번 hello로 초기화 되므로 아무리 state를 변경해도 hello로 초기화 되는 것이다. \r\n\r\n근데 렌더링이 될 때마다 초기화되는 변수(값)와는 달리, useState의 결과값은 어떻게 그 값을 유지할까?\r\n\r\n\r\n\r\n그럼 우리가 알고있는 useState는 대체 어떻게 구현이 되있는 것일지 한번 최대한 비슷하게 구현한 코드를 살펴보자.\r\n\r\n**먼저 useState의 결과 값이 유지되도록, state를 함수로 하여 state 값을 호출할 때마다 현재 state를 반환하게 해보자.**\r\n```js\r\nfunction useState(initialValue) {\r\n\tlet initialState = initialValue;\r\n\t\r\n\tfunction state() {\r\n\t\treturn initialState\r\n\t}\r\n\tfunction setState(newValue) {\r\n\t\tinitialState = newValue\r\n\t}\r\n\treturn [state, setState];\r\n}\r\nconst [value, setState] = useState(0);\r\nsetValue(1);\r\nconsole.log(value()); // 1\r\n```\r\n위의 코드도 나쁘진 않지만, 우리에게 익숙한 useState훅은 state를 함수가 아닌 상수처럼 사용하고 있다.\r\n어떻게 그게 가능한 걸까?\r\n\r\n## 클로저를 이용해 상태를 관리하는 useState\r\n이를 위해서 리액트는 **클로저**를 이용한 것이다. \r\nuseState는 클로저를 통해 useState 내부의 선언된 함수(setState)가 함수의 실행이 종료된 이후(useState가 호출된 이후)에도 지역변수인 state를 계속 참조할 수 있다.\r\n\r\nuseState 작동 방식을 대략적으로 흉내 낸 코드는 다음과 같다.\r\n\r\n```js\r\nconst MyReact = (function() {\r\n\tconst global = {}\r\n    let index = 0\r\n    \r\n    function useState(initialState){\r\n    \tif(!global.states) {\r\n    \t// 애플리케이션 전체의 states 배열 초기화, 최초 접근이면 빈 배열로\r\n        \tglobal.states = []\r\n        }\r\n        // states 정보를 조회해서, 현재 상태값이 있는지 확인\r\n        // 없다면 초깃값으로 설정\r\n        const currentState =  global.states[index] || initialState\r\n        // 위에서 조회한 값으로 states의 값 업데이트\r\n        global.states[index] = currentState\r\n        \r\n        // 즉시실행함수로 setter 만듬\r\n        const setState = (function() {\r\n        \t// 클로저로 index를 가둬두어서 동일한 index에 접근이 가능\r\n        \tlet currentIndex = index\r\n            return function(value){\r\n            \tglobal.states[currentIndex] = value\r\n                //컴포넌트 렌더링이 들어가는 부분이다.(실제 코드는 생략)\r\n            }\r\n    })()\r\n    // useState를 쓸 때마다 index를 하나씩 추가하는데, 이는 하나의 state마다\r\n    // index가 할당되어있어, 그 index가 배열의 값(global.states)를 가리키고,\r\n    // 필요할 때마다 그 값을 가져오게 하는 것이다.\r\n    index = index + 1\r\n        \r\n    return [currentState,setState]\r\n}\r\n\r\nfunction Component() {\r\n\tconst [value, setValue] = useState(0);\r\n}\r\n})();\r\n```\r\n\r\n실제 리액트 코드에서는 useReducer를 이용해 구현되어 있어 약간의 차이가 있다.\r\n\r\n아무튼 여기서 함수의 실행이 끝났음에도 함수가 선언된 환경을 기억할 수 있는 방법이 바로 클로저인 것이다. 만약 클로저가 없다면, `setState`는 항상 `index`의 현재 값에 의존하게 된다. 즉, 컴포넌트가 여러 상태를 갖고 있을 때 마지막 `index`만 참조하므로, `setState`가 올바른 위치를 참조하지 않게 되는 것이다.\r\n\r\n매번 실행되는 함수 컴포넌트 환경에서 state의 값을 유지하고 사용하기 위해 리액트는 클로저를 활용하고 있다.\r\n\r\n`\r\n훅에 대한 구현체를 github에서 타고 올라가다보면 __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED 라는 문구를 만나게된다(무섭다 ㅋㅋ)\r\n위의 코드는 Preact의 구현을 기준으로 하고 있다. Preact는 react의 경량화 버전으로,\r\n대부분의 리액트 API를 지원하고 있다. \r\n`\r\n## 결론\r\nReact의 `useState`는 클로저를 통해 상태값을 안정적으로 유지하며, 함수 컴포넌트가 여러 번 호출되더라도 **각 상태값이 고유한 위치에 저장**될 수 있게 한다. `useState`가 반환하는 `setState` 함수는 생성 당시의 상태 위치(`index`)를 클로저로 캡처하여, 해당 상태값만 정확히 업데이트하도록 구현되어 있다.\r\n\r\n정리하자면, 클로저는 `setState`가 함수가 선언된 당시의 환경을 유지하게 해주기 때문에 **컴포넌트가 매번 재실행될 때마다 상태가 초기화되는 것을 방지**하고, 상태가 올바르게 유지될 수 있게 해준다.\r\n\r\n**참고**\r\n\r\n[서적] 모던 리액트 Deep Dive\r\n"}]},"__N_SSG":true}
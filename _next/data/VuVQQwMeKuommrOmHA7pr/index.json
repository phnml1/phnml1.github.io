{"pageProps":{"posts":[{"slug":"posts/React/setState는 비동기일까","title":"setState는 비동기일까","date":"2025-03-11T13:00:24.000Z","image":"index.png","summary":"setState가 왜 동기 함수인지, 그리고 react서는 setState를 통해 상태 업데이트를 어떻게 하는지 알아보자.","tags":["react","JavaScript","deepdive","useState","hook"],"content":"# setState는 비동기일까?\r\n\r\n## 🔹setState가 왜 바로 반영이 안되지?\r\nReact에서 `setState`를 사용하다 보면, 처음에 많은 프론트엔드 개발자들이 한 가지 의문을 가지게 된다.\r\n```js\r\nconst [count, setCount] = useState(0);\r\n\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  console.log(count);\r\n};\r\n```\r\n`console.log(count)`에서는 업데이트된 값인 **1**이 출력되어야 할거같지만,  그게 아닌아니라 **0**이 출력됩니다.\r\n\r\n코드만 봤을 때는 업데이트된 값인 1이 출력되는게 맞는 거 같은데 **왜 이전 값인 0이 출력되는걸까?** async await를 쓰지 않지만 setState가 비동기라 그런걸까?\r\n\r\n결론부터 말하자면 setState는 **비동기 처럼 동작하지만, 실제로는 동기함수이다.**\r\n 이에 대해 자세히 살펴보자.\r\n\r\n## 🔹 setState의 동작방식\r\n\r\nsetState 자체는 동기적으로 실행되지만, setState로 인한 상태업데이트와 렌더링은 비동기적으로 이루어진다. \r\n\r\n왜 setState가 동기적인지는 우선 이따가 살펴보고, 우선 setState의 동작방식에 대해 알아보자.\r\n\r\n\r\n```js\r\nconst [count, setCount] = useState(0);\r\n\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  console.log(count); // 출력값은 1이다.\r\n};\r\n```\r\n아까 전 살펴봤던 코드이다. 왜 업데이트 된 값이 바로 반영이 안되었던 걸까?\r\n\r\n이유는 React는 최적화를 위해 상태 변경을 비동기적으로 처리하고 있기 때문입니다.\r\n\r\n### 배치 업데이트 (Batching)\r\nReact는 여러 개의 `setState` 호출을 하나로 비동기적으로 묶어서 처리하고, 이것을 **배치(batch) 업데이트**를 수행한다고합니다.  \r\n즉, 같은 이벤트 핸들러에서 여러 개의 `setState`가 호출되더라도 **한 번의 렌더링에서 처리**됩니다. \r\n\r\n```js\r\nconst handleClick = () => {\r\n  setCount(10);\r\n  setCount(count + 1);\r\n  setCount(30);\r\n  console.log(\"현재 count 값:\", count);\r\n};\r\n```\r\n즉 위의 3개의 setState는 한번에 함수 내 에서 하나씩 순서대로 실행되는 것이 아닌, **비동기적으로 한번에 처리가 되는 것 이다.**\r\n\r\n그렇다면 다음 코드를 보자.\r\n```js\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  setCount(count + 1);\r\n  setCount(count + 1);\r\n  console.log(\"현재 count 값:\", count);\r\n};\r\n```\r\n다음과 같은 경우 현재 count 값이 0으로 출력되는 것은 이제 알 것이다.\r\n```js\r\n현재 count 값: 0  // 이전 값이 출력\r\n```\r\n그렇다면 최종적으로 count 값은 몇이 될까? `\r\n\r\n`setCount(count + 1)`가 3번 호출되었지만, 최종적으로 `count` 값은 **1만 증가**한다.\r\n\r\n이유는 역시 React는 동일한 이벤트 핸들러 내에서 여러 개의 `setState`를 **배치 처리**하여 하나로 합쳐버리기 때문이다.\r\n즉, \r\n```js\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\n\r\n```\r\n-   `setState`는 바로 실행되지만, **이벤트 핸들러 내부에서는 `count` 값이 0으로 유지됨**\r\n-   따라서 모든 `setCount(count + 1)`은 결국 `setCount(1)`과 동일\r\n\r\n만일 의도한 바대로 count를 1씩증가시켜 3으로 만들고 싶다면, \r\n```js\r\nconst handleClick = () => {\r\n  setCount(prev => prev + 1);\r\n  setCount(prev => prev + 1);\r\n  setCount(prev => prev + 1);\r\n};\r\n```\r\n이런 식으로 코드를 짜면, 배치 처리와 상관없이 이전 값을 기반으로 상태를 변경한다.\r\n\r\n이렇게 setState는 React내에서 비동기적으로 상태 업데이트를 진행하는데, 왜 그럼에도 동기함수라고 하는걸까?\r\n\r\n## 🔹 setState가 동기함수인 이유\r\n\r\n**setState**의 상태 업데이트는 React내에서 배치처리를 통해 비동기적으로 이루어지지만, setState 자체는 **호출 즉시 실행**되므로 **동기 함수**이다.\r\n\r\n즉, 예를들어서,\r\n```js\r\nconst handleClick = () => {\r\n  console.log(\"Before setState:\", count);\r\n  setCount(count + 1);\r\n  console.log(\"After setState:\", count);\r\n};\r\n```\r\n위의 `setCount(count + 1);` 함수 자체는 실행될 때, 실행되는 즉시 함수가 종료가 된다. \r\n`setCount`가 진짜 비동기 함수였다면, **비동기 작업(Promise 등)을 반환**해야 하지만 그런 동작을 하지 않는 것이다.\r\n\r\n다만 setCount가 실행되어 상태 변경을 요청하면, \r\n**React가 이 요청을 현재 수행중인 이벤트가 핸들러가 끝날 때까지 기다린 후 배치처리를 수행하는 것이다.**\r\n \r\n setState가 비동기 함수 였다면,\r\n ```js\r\n const handleClick = async () => {\r\n  console.log(\"Before setState:\", count);\r\n  await setCount(count + 1);  //  실제로는 이렇게 사용 불가능\r\n  console.log(\"After setState:\", count);\r\n};\r\n ```\r\n 이런식으로 사용할 수 있어야 하지만, `setState`는 Promise를 반환하지 않으므로 `await`을 사용할 수 없다.\r\n \r\n 즉 setState는 **React의 내부적인 상태 업데이트와 렌더링 방식**으로 인해 비동기적으로 실행되는 것처럼 보이지만 엄밀히 말하면 **동기 함수**이다.\r\n\r\n## 결론\r\n\r\nsetState를 통해 React가 상태를 업데이트하는 과정을 정리하면 다음과 같다.\r\n\r\n1.  `setState` 호출 → 상태 변경 요청 (동기적으로 동작)\r\n2.  React가 현재 실행 중인 이벤트 핸들러가 끝날 때까지 기다림\r\n3.  **배치 처리**를 수행하여 여러 개의 `setState`를 한꺼번에 처리(비동기적 최적화)\r\n4.  상태 업데이트 후 리렌더링을 트리거\r\n\r\n`setState`는 동기적으로 실행되지만,  React의 **상태 변경과 렌더링 과정이 비동기적으로 최적화되어 실행된다.**"},{"slug":"posts/React/React와 Nextjs의 Suspense","title":"React와 Next.js의 Suspense에 대해 알아보자","date":"2024-11-25T00:00:24.000Z","image":"index.png","summary":"React와 Next.js에서 Suspense를 어떤 방식으로 다르게 다루는지, 그리고 Next.js에서 이로인해 발생할 수 있는 에러와 해결방법에 대해 알아보자.","tags":["react","next.js","deepdive","SSR","Suspense","렌더링"],"content":"\r\n## 들어가며\r\n프론트엔드에서 React와 Next.js에서는 비동기 로직과 데이터 페칭을 효율적으로 관리하기 위해 **Suspense**를 활용한다. \r\n\r\nReact 18부터 본격적으로 Suspense를 활용하여 관련된 로직을 수행할 수 있는데, React에서 Suspense를 어떻게 사용하는지 알아보고, Next.js에서는 13이상 부터 **자동화된 Suspense**에 대해, 그리고 이로 인해 발생한 에러와 해결방법에 대해 알아볼 것이다.\r\n\r\n## React의 Suspense\r\nReact의 **Suspense**는 비동기 로직이 완료될 때까지 대기 상태를 처리한다. 데이터 로딩, 컴포넌트 코드 스플리팅 등을 위해 주로 사용되며, 다음과 같은 방식으로 동작한다\r\n\r\n#### **Suspense 기본 동작 (React 18 이상)**\r\n\r\n1.  `Suspense`는 컴포넌트 트리의 일부에서 데이터를 로드하거나 리소스를 가져오는 작업이 끝날 때까지 렌더링을 중단한다.\r\n2.  `fallback` 프로퍼티에 지정된 컴포넌트를 먼저 렌더링한다.\r\n3.  작업이 완료되면 `Suspense` 아래의 실제 콘텐츠를 렌더링한다.\r\n\r\n```js\r\nimport React, { Suspense } from 'react';\r\n\r\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\r\n\r\nexport default function App() {\r\n  return (\r\n    <Suspense fallback={<div>Loading...</div>}>\r\n      <LazyComponent />\r\n    </Suspense>\r\n  );\r\n}\r\n\r\n```\r\n이런식으로 명시적으로 Suspense를 배치하여 이를 제어한다.\r\n\r\n`React.lazy`는 컴포넌트를 지연로딩할 때 사용되며 컴포넌트를 처음렌더링 할 때까지 로드하지 않는다.\r\n\r\n대신, 해당 컴포넌트가 실제로 화면에 렌더링될 때, 즉 \"**필요할 때**\" 로드한다.\r\n\r\n이렇게 `React.lazy()`와 `Suspense`를 같이 활용하여 컴포넌트를 지연 로딩하고, 초기 로딩 성능을 개선한다.\r\n\r\n## Next.js에서 자동화된 Suspense\r\n\r\nNext.js 13 이상에서는 App Router를 기반으로 **자동 Suspense**가 도입되었다. React의 Suspense와 비슷한 기능을 제공하되, 일부 동작이 Next.js에 의해 자동화가 된다.\r\n\r\n#### **Next.js 자동 Suspense 동작**\r\n\r\n1.  서버 컴포넌트에서 `fetch`나 비동기 로직을 처리할 때 Suspense가 자동으로 적용된다.\r\n2.  `loading.js`와 같은 특수 파일을 활용하여 Suspense의 `fallback` 역할을 수행한다.\r\n3.  클라이언트 컴포넌트의 경우 별도로 Suspense를 지정해야 동작한다\r\n\r\n즉 서버 컴포넌트에서 미리 비동기로 데이터를 가져올 때,  자동으로 지연 로딩이 되고, 로딩이 되는 동안 loading.tsx를 보여줄 수 있는 것 이다.\r\n\r\n```js\r\n// app/원하는 경로 페이지/page.tsx (서버 컴포넌트) \r\nexport default async function Page() { \r\nconst data = await fetchData(); \r\n\t// 자동 Suspense \r\n\treturn <div>{data}</div>; \r\n}\r\n```\r\n위의 코드는 Next.js의 서버 컴포넌트에서 데이터를 서버 단에서 미리 불러 올 때의 예제이다. 만일 loading.tsx를 만들면 이렇게 서버에서 미리 데이터를 불러오는 동안 사용자에게 로딩 중 컴포넌트를 보여줄 수 있다.\r\n\r\n```js\r\n// app/원하는-경로-페이지/loading.tsx \r\nexport default function Loading() {\r\n return <div>Loading...</div>; \r\n // 간단한 로딩 상태 \r\n }\r\n```\r\n이러한 경우 원하는 경로의 페이지에 접속하는 동안 loading.tsx를 볼 수 있다.\r\n\r\n## Next.js에서 React의 Suspense를 같이 써보자\r\n\r\nNext.js에서 내재되어있는 서버 컴포넌트에서 미리 데이터를 페칭할 때 자동으로 사용되는 Suspense 기능 뿐 아니라, 그 컴포넌트 안에서 react의 Suspense 역시 사용할 수 있다.\r\n\r\n다음 예제를 보자.\r\n```js\r\nimport { Suspense } from 'react';\r\nimport dynamic from 'next/dynamic';\r\n// 비동기 컴포넌트\r\nconst LazyComponent = dynamic(() => import('./LazyComponent'), { suspense: true, // Suspense를 사용하려면 이 설정이 필요하다. });\r\n\r\nexport default function Page() {\r\nconst data = await fetchData();\r\n  return (\r\n    <div>\r\n      <h1>Server Side Rendered Data</h1>\r\n      <div>{data}</div>\r\n\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        <LazyComponent />\r\n      </Suspense>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n`next/dynamic`은 **Next.js**에서 제공하는 **동적 import** 기능이다. 이 기능을 사용하면 클라이언트 사이드에서 컴포넌트를 **지연 로딩**(Lazy Loading) 할 수 있으며, **서버 사이드 렌더링(SSR)**을 제어할 수 있다. \r\n\r\n즉 **비동기 로딩**을 통해 성능 최적화와 코드 분할을 지원하는 것이다.\r\n\r\n`next/dynamic`에는 여러 옵션이 있는데\r\n\r\n- suspense :**React Suspense** 기능과 통합하여, 동적 컴포넌트 로딩 중에 fallback UI를 표시할 수 있다.\r\n - loading:  \r\n\t  ```js \r\n\t  const LazyComponent = dynamic(() => import('./LazyComponent'), {\r\n\t  \t\tloading: () => <div>Loading...</div>, \r\n\t  \t\t});\r\n\t  \r\n\t ```\r\n\t 이렇게 직접 로딩 컴포넌트를 지정할 수도 있다.\r\n- ssr: `next/dynamic`에서는 이 동적 로딩 컴포넌트가 **서버 사이드 렌더링**에서 제외될 수 있도록 `ssr: false` 옵션을 사용하여 클라이언트 사이드에서만 컴포넌트를 로드할 수 있게 한다. (이 부분으로 에러를 해결하는 포스트를 추후 쓸 것이다.)\r\n\r\nLazyComponent가 볼륨이 높은 페칭 작업을 한다고 가정했을 때 Suspense를 사용하여 데이터를 가져오는 동안 fallback 컴포넌트를 보여줄 수 있다.\r\n\r\n즉, 위의 코드에서 Suspense가 어떻게 작동하는 지 정리해보자면\r\n\r\n- 서버 단에서 데이터를 페칭하여 미리가져오고, 그 데이터를 가져오는 시간 동안 loading.tsx의 컴포넌트를 보여준다.\r\n-  데이터를 가져와서 페이지가 로드된후 Suspense로 감싸준 클라이언트 단의 **LazyComponent에서 작업을 하는 동안** **fallback 컴포넌트를 보여준다.**\r\n-  LazyComponent의 작업이 완료되면 본래 컴포넌트를 보여준다.\r\n\r\n## 마치며\r\n React와 Next.js에서 Suspense를 어떻게 쓸 수 있는지에 대해서, 그리고 next.js에서 두개를 같이 쓰는 예제까지 살펴보았다. 개발 하며 앞으로 보다 나은 사용자 경험과 최적화를 위해 유용하게 사용할 수 있을 듯하다."},{"slug":"posts/React/리액트 컴포넌트 테스트 코드 시작하기","title":"리액트 컴포넌트 테스트 코드 시작하기","date":"2024-11-18T17:00:24.000Z","image":"index.png","summary":"React Deepdive 서적의 React 컴포넌트의 테스트 코드를 정리하였다.","tags":["react","테스트","deepdive"],"content":"\r\n## 들어가며\r\n리액트에서 테스트라는 개념이 있다는 걸 알고 있었지만, 정확히 무슨 개념인지 또한 구체적으로 어떻게 하는 건지 몰랐었다. \r\n\r\nreact deep dive를 공부하며 `08 좋은 리액트 코드 작성을 위한 환경 구축하기` 단원 에서 리액트 컴포넌트 테스트코드를 작성하는 부분이 있어서 이 부분에서 공부하면서 배운 리액트 컴포넌트의 기초적인 테스트 코드를 작성하는 방법을 정리해보고자 한다. \r\n\r\n## 리액트 컴포넌트 테스트 \r\n\r\n기본적으로 리액트에서 컴포넌트 테스트는 다음과 같은 순서로 진행된다.\r\n\r\n\t1. 컴포넌트를 렌더링한다.\r\n\t2. 컴포넌트에서 특정 액션을 수행한다.\r\n\t3. 컴포넌트 렌더링과 2번의 액션을 통해 기대하는 결과와 실제 결과와 비교한다.\r\n\r\n**App.tsx**\r\n```js\r\nimport React from 'react';\r\nimport logo from './logo.svg';\r\nimport './App.css';\r\nimport StaticComponent from './components/StaticComponent';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n        <p>\r\n          Edit <code>src/App.tsx</code> and save to reload.\r\n        </p>\r\n        <a\r\n          className=\"App-link\"\r\n          href=\"https://reactjs.org\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Learn React\r\n        </a>\r\n      </header>\r\n      <StaticComponent />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n```\r\n**테스트 코드**\r\n```js\r\nimport React from 'react';\r\nimport { render, screen } from '@testing-library/react';\r\nimport App from './App';\r\n\r\ntest('renders learn react link', () => {\r\n  render(<App />);\r\n  const linkElement = screen.getByText(/learn react/i);\r\n  expect(linkElement).toBeInTheDocument();\r\n});\r\n\r\n```\r\nApp.test.tsx가 App.tsx에서 테스트하는 내용은 다음과 같이 요약할 수 있다.\r\n1. App 렌더링 \r\n2. App에서 'leartn react' 라는 문자열 가진 DOM 요소 찾기 \r\n3. expect(linkElement).toBeInTheDocument() 라는 어설션을 활용해 2번에서 찾은 요소가 document 내부에 있는지 확인하기\r\n\t\r\n위와 같이 일반적인 리액트 컴포넌트 테스트 시나리오는 특정한 무언가를 지닌 HTML 요소가 있는지 여부이다. \r\n\r\n이를 확인하는 방법은 3가지인데,\r\n\r\n- **getBy...** : 인수에 조건에 맞는 요소를 반환한다. 복수 개를 찾으려면 getAllBy.. 를 사용해야 한다.  \r\n- **findBy...** : getBy와 유사하지만 Promise를 반환, 즉 비동기로 찾는 것을 의미하며 기본적으로 1s의 타임아웃을 가지고 있다.  복수 개는 findAllBy를 사용한다.\r\n- **queryBy...** : 인수에 조건에 맞는 요소를 반환하는 대신, 요소를 찾지 못한다면 null이 반환된다. 찾지 못한경우 에 에러를 일으키지 않고 싶을 때 사용한다. 복수 개는 queryAllBy를 사용한다.\r\n\r\n\r\n자 그럼 본격적으로 리액트 컴포넌트들의 테스트 코드를 작성해보자.\r\n\r\n\r\n\r\n## 정적 컴포넌트\r\n\r\n`정적 컴포넌트`란 별도의 상태가 존재하지 않아 항상 같은 결과를 반환하는 컴포넌트이다.\r\n\r\n**정적 컴포넌트**\r\n```js\r\nimport { memo } from 'react'\r\n\r\nconst AnchorTagComponent = memo(function AnchorTagComponent({\r\n  name,\r\n  href,\r\n  targetBlank,\r\n}: {\r\n  name: string\r\n  href: string\r\n  targetBlank?: boolean\r\n}) {\r\n  return (\r\n    <a\r\n      href={href}\r\n      target={targetBlank ? '_blank' : undefined}\r\n      rel=\"noopener noreferrer\"\r\n    >\r\n      {name}\r\n    </a>\r\n  )\r\n})\r\n\r\nexport default function StaticComponent() {\r\n  return (\r\n    <>\r\n      <h1>Static Component</h1>\r\n      <div>유용한 링크</div>\r\n\r\n      <ul data-testid=\"ul\" style={{ listStyleType: 'square' }}>\r\n        <li>\r\n          <AnchorTagComponent\r\n            targetBlank\r\n            name=\"리액트\"\r\n            href=\"https://reactjs.org\"\r\n          />\r\n        </li>\r\n        <li>\r\n          <AnchorTagComponent\r\n            targetBlank\r\n            name=\"네이버\"\r\n            href=\"https://www.naver.com\"\r\n          />\r\n        </li>\r\n        <li>\r\n          <AnchorTagComponent name=\"블로그\" href=\"https://yceffort.kr\" />\r\n        </li>\r\n      </ul>\r\n    </>\r\n  )\r\n}\r\n```\r\n\r\n이 컴포넌트에서 링크가 제대로 있는지 확인해볼 것이다.\r\n\r\n**테스트 코드**\r\n```js\r\nimport { render, screen } from '@testing-library/react'\r\n\r\nimport StaticComponent from './index'\r\n\r\nbeforeEach(() => {\r\n  render(<StaticComponent />)\r\n})\r\n\r\ndescribe('링크 확인', () => {\r\n  it('링크가 3개 존재한다.', () => {\r\n    const ul = screen.getByTestId('ul')\r\n    expect(ul.children.length).toBe(3)\r\n  })\r\n\r\n  it('링크 목록의 스타일이 square다.', () => {\r\n    const ul = screen.getByTestId('ul')\r\n    expect(ul).toHaveStyle('list-style-type: square;')\r\n  })\r\n})\r\n\r\ndescribe('리액트 링크 테스트', () => {\r\n  it('리액트 링크가 존재한다.', () => {\r\n    const reactLink = screen.getByText('리액트')\r\n    expect(reactLink).toBeVisible()\r\n  })\r\n\r\n  it('리액트 링크가 올바른 주소로 존재한다.', () => {\r\n    const reactLink = screen.getByText('리액트')\r\n\r\n    expect(reactLink.tagName).toEqual('A')\r\n    expect(reactLink).toHaveAttribute('href', 'https://reactjs.org')\r\n  })\r\n})\r\n\r\ndescribe('네이버 링크 테스트', () => {\r\n  it('네이버 링크가 존재한다.', () => {\r\n    const naverLink = screen.getByText('네이버')\r\n    expect(naverLink).toBeVisible()\r\n  })\r\n\r\n  it('네이버 링크가 올바른 주소로 존재한다.', () => {\r\n    const naverLink = screen.getByText('네이버')\r\n\r\n    expect(naverLink.tagName).toEqual('A')\r\n    expect(naverLink).toHaveAttribute('href', 'https://www.naver.com')\r\n  })\r\n})\r\n\r\ndescribe('블로그 링크 테스트', () => {\r\n  it('블로그 링크가 존재한다.',()=>{\r\n    const blogLink = screen.getByText('블로그')\r\n    expect(blogLink).toBeVisible()\r\n  })\r\n  it('블로그 링크가 올바른 주소로 존재한다.', ()=>{\r\n    const blogLink = screen.getByText('블로그')\r\n\r\n    expect(blogLink.tagName).toEqual('A');\r\n    expect(blogLink).toHaveAttribute('href','https://yceffort.kr')\r\n  })\r\n\r\n  it('블로그는 같은 창에서 열려야 한다.', () => {\r\n    const blogLink = screen.getByText('블로그');\r\n    expect(blogLink).not.toHaveAttribute('target');\r\n  })\r\n})\r\n```\r\n각 테스트를 수행하기전에 StaticComponent를 렌더링하고 describe로 연관된 테스트를 묶어서 it으로 it 함수 내부에 수행하는 테스트파일이다.\r\n\r\n몇 가지 새로운 jest 메서드가 보인다.\r\n\r\n- **beforeEach** : 각 테스트들을 실행하기 전에 실행하는 함수  \r\n- **describe** : 비슷한 속성을 가진 테스트를 하나로 묶음 describe 안에 describe를 사용하는것도 가능  \r\n- **it** : test와 완전히 동일하며 축약어이다.  \r\n- **testId** : get등의 선택자로 선택하기 어렵거나 곤란한 요소를 선택하기 위해 사용한다.\r\n`\r\n참고로 HTML에 data-testid를 추가하면 getByTestId를 사용할 수 있다.\r\n이는 button의 개수가 많을 때와 같은 특정 시나리오에서 유용하게 사용할 수 있다.\r\n`\r\n\r\n## 동적 컴포넌트\r\n상태값이 있는 컴포넌트, 예를 들어 useState를 사용해 상태값을 관리하는 컴포넌트는 어떻게 테스트할까? \r\n\r\n일반적으로 리액트에서는 정적인 경우보다 동적인 경우가 훨씬 많다.\r\n\r\n이 경우도 살펴보자.\r\n```js\r\nimport { useState } from 'react'\r\n\r\nexport function InputComponent() {\r\n  const [text, setText] = useState('')\r\n\r\n  function handleInputChange(event: React.ChangeEvent<HTMLInputElement>) {\r\n    const rawValue = event.target.value\r\n    const value = rawValue.replace(/[^A-Za-z0-9]/gi, '')\r\n    setText(value)\r\n  }\r\n\r\n  function handleButtonClick() {\r\n    alert(text)\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <label htmlFor=\"input\">아이디를 입력하세요.</label>\r\n      <input\r\n        aria-label=\"input\"\r\n        id=\"input\"\r\n        value={text}\r\n        onChange={handleInputChange}\r\n        maxLength={20}\r\n      />\r\n      <button onClick={handleButtonClick} disabled={text.length === 0}>\r\n        제출하기\r\n      </button>\r\n    </>\r\n  )\r\n}\r\n```\r\n사용자의 키보드 타이핑 입력을 받는 input, 이를 alert로 띄우는 button으로 구성된 간단한 컴포넌트다. \r\n\r\ninput은 최대 20자까지, 한글 입력만 가능하도록 제한되어있으며, 이는 onChange에서 정규식을 통해 작성되어 있다. 그리고 버튼은 글자가 없으면 disable되도록 처리되어있고, 클릭 시 alert 창을 띄운다.\r\n\r\n테스트 코드는 다음과 같다.\r\n```js\r\nimport { fireEvent, render } from '@testing-library/react'\r\nimport userEvent from '@testing-library/user-event'\r\n\r\nimport { InputComponent } from '.'\r\n\r\ndescribe('InputComponent 테스트', () => {\r\n  const setup = () => {\r\n    const screen = render(<InputComponent />)\r\n    const input = screen.getByLabelText('input') as HTMLInputElement\r\n    const button = screen.getByText(/제출하기/i) as HTMLButtonElement\r\n    return {\r\n      input,\r\n      button,\r\n      ...screen,\r\n    }\r\n  }\r\n\r\n  it('input의 초기값은 빈 문자열이다.', () => {\r\n    const { input } = setup()\r\n    expect(input.value).toEqual('')\r\n  })\r\n\r\n  it('input의 최대길이가 20자로 설정되어 있다.', () => {\r\n    const { input } = setup()\r\n    expect(input).toHaveAttribute('maxlength', '20')\r\n  })\r\n\r\n  it('영문과 숫자만 입력된다.', () => {\r\n    const { input } = setup()\r\n    const inputValue = '안녕하세요123'\r\n    userEvent.type(input, inputValue)\r\n    expect(input.value).toEqual('123')\r\n  })\r\n\r\n  it('아이디를 입력하지 않으면 버튼이 활성화 되지 않는다.', () => {\r\n    const { button } = setup()\r\n    expect(button).toBeDisabled()\r\n  })\r\n\r\n  it('아이디를 입력하면 버튼이 활성화 된다.', () => {\r\n    const { button, input } = setup()\r\n\r\n    const inputValue = 'helloworld'\r\n    userEvent.type(input, inputValue)\r\n\r\n    expect(input.value).toEqual(inputValue)\r\n    expect(button).toBeEnabled()\r\n  })\r\n\r\n  it('버튼을 클릭하면 alert가 해당 아이디로 뜬다.', () => {\r\n    const alertMock = jest\r\n      .spyOn(window, 'alert')\r\n      .mockImplementation((_: string) => undefined)\r\n\r\n    const { button, input } = setup()\r\n    const inputValue = 'helloworld'\r\n\r\n    userEvent.type(input, inputValue)\r\n    fireEvent.click(button)\r\n\r\n    expect(alertMock).toHaveBeenCalledTimes(1)\r\n    expect(alertMock).toHaveBeenCalledWith(inputValue)\r\n  })\r\n})\r\n```\r\n- **setup** : 내부에서 컴포넌트를 렌더링하고 테스트에 필요한 button,input을 반환한다.  \r\n- **userEvent.type** : 사용자가 타이핑 하는것을 흉내내는 메서드이다. userEvent.type을 사용하면 사용자가 타이핑하는 것과 동일한 작동을 만들 수 있다.\r\n- **userEvent**는 fireEvent의 여러 이벤트를 순차적으로 실행해 좀 더 자세하게 사용자의 작동을 흉내낸다. \r\n\t예를 들어 **userEvent.click**를 수행하면 \r\n\t\t- fireEvent.MouseOver  \r\n\t\t- fireEvent.mouseMove \r\n\t\t- fireEvent.mouseDown \r\n\t\t- fireEvent.mouseUp  \r\n\t\t- fireEvent.click \r\n\t\t을 수행한다. \r\n  \r\n  즉 userEvent는 사용자의 작동을 **여러 fireEvent를 통해 좀 더 자세하게 흉내 내는 모듈이**라고 볼 수 있는 것이다.\r\n\r\n\t대부분의 이벤트를 테스트할 때는 fireEvent로 충분하고 훨씬 빠르지만, 특별히 사용자의 이벤트를 흉내 내야 할 때만 userEvent를 사용한다.\r\n  \r\n- **jest.spyOn(window,'alert').mockImplementation()**  \r\n\t- **spyOn** : 특정 메서드를 오염시키지 않고 실행이 되었는지 , 어떤 인수로 실행되었는지 실행과 관련된 정보만 얻고 싶을때 사용한다. 즉 위의 코드에서는 window 객체의 메서드 alert를 구현하지 않고 해당 메서드가 실행되었는지를 관찰한다는 뜻이다.\r\n\t\r\n\t\r\n\t\tspyon으로 `한번 호출되었는지`(toBeCalledTimes(1)), `원하는 인수와 함께 호출되었는지` (toBeCalledWith(1,2))를 확인할 수 있다. \r\n\t**calc.add자체에는 영향을 미치지 않는다.**\r\n\t- **mockImplementation**: 해당 메서드에 대한 모킹을 도와준다. Jest환경에서는 window.alert가 존재하지 않는데, 이를 모의함수(mock)로 구현할 수 해주는 메서드이다.\r\n\r\n\t즉 jest.spyOn을 사용해 Node.js에서 존재하지 않는 window.alert를 관찰하고, mockImpletation을 사용해 window.alert가 실행되었는지의 정보를 확인할 수 있도록 처리한 것이다.\r\n\r\n## 비동기 이벤트가 발생하는 컴포넌트\r\n그렇다면 비동기 이벤트 중 fetch가 실행되는 컴포넌트를 예로 들어보자\r\n\r\n이 코드는 버튼을 클릭하면 /todos/:id로 fetch 요청을 보내 데이터를 불러온다.\r\n\r\n이 fetch를 어떻게 테스트 할 수 있을까?\r\n\r\n우리는 이를 위해 `MSW`를 사용해 볼 것이다.\r\n \r\n **MSW**는 브라우저에서 사용할 때는 서비스 워커를 활용해 실제 네트워크 요청을 가로채는 방식으로 모킹을 구현하고, Node.js 환경에서는 https나 XMLHttpRequest의 요청을 가로채는 방식으로 작동한다.\r\n \r\n즉 node.js에서나 브라우저에서 fetch 요청을 하는 것과 동일하게 네트워크 요청을 수행하고, 이 요청을 **중간에 MSW가 감지하고 미리 준비한 모킹 데이터를 제공하는 방식**이다.\r\n\r\n이는 fetch의 모든 기능을 그대로 사용하고 응답에 대해서만 모킹할 수 있으므로 fetch를 모킹하는게 훨씬 수월해진다.\r\n\r\n비동기 함수 컴포넌트 테스트 코드\r\n```js\r\nimport { fireEvent, render, screen } from '@testing-library/react'\r\nimport { rest } from 'msw'\r\nimport { setupServer } from 'msw/node'\r\n\r\nimport { FetchComponent } from '.'\r\n\r\nconst MOCK_TODO_RESPONSE = {\r\n  userId: 1,\r\n  id: 1,\r\n  title: 'delectus aut autem',\r\n  completed: false,\r\n}\r\n// 서버를 만드는 역할\r\nconst server = setupServer(\r\n  rest.get('/todos/:id', (req, res, ctx) => {\r\n    const todoId = req.params.id\r\n\r\n    if (Number(todoId)) {\r\n      return res(ctx.json({ ...MOCK_TODO_RESPONSE, id: Number(todoId) }))\r\n    } else {\r\n      return res(ctx.status(404))\r\n    }\r\n  }),\r\n)\r\n// \r\nbeforeAll(() => server.listen())\r\n// 초기화했던 초기값유지위해서 이 테스트는 마지막이어서 상관없지만, 그렇지않으면 다른 곳에서도 503에러\r\n// afterEach(() => server.resetHandlers());\r\nafterAll(() => server.close())\r\n\r\nbeforeEach(() => {\r\n  render(<FetchComponent />)\r\n})\r\n\r\ndescribe('FetchComponent 테스트', () => {\r\n  it('데이터를 불러오기 전에는 기본 문구가 뜬다.', async () => {\r\n    const nowLoading = screen.getByText(/불러온 데이터가 없습니다./)\r\n    expect(nowLoading).toBeInTheDocument()\r\n  })\r\n\r\n  it('버튼을 클릭하면 데이터를 불러온다.', async () => {\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const data = await screen.findByText(MOCK_TODO_RESPONSE.title)\r\n    expect(data).toBeInTheDocument()\r\n  })\r\n\r\n  //여기서만 에러떠야하므로 위에서 resetHandlers 사용\r\n  it('버튼을 클릭하고 서버요청에서 에러가 발생하면 에러문구를 노출한다.', async () => {\r\n    server.use(\r\n      rest.get('/todos/:id', (req, res, ctx) => {\r\n        return res(ctx.status(503))\r\n      }),\r\n    )\r\n\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const error = await screen.findByText(/에러가 발생했습니다/)\r\n    expect(error).toBeInTheDocument()\r\n  })\r\n})\r\n```\r\n전체 코드를 나눠서 살펴보자\r\n```js\r\n// 서버를 만드는 역할\r\nconst server = setupServer(\r\n  rest.get('/todos/:id', (req, res, ctx) => {\r\n    const todoId = req.params.id\r\n\r\n    if (Number(todoId)) {\r\n      return res(ctx.json({ ...MOCK_TODO_RESPONSE, id: Number(todoId) }))\r\n    } else {\r\n      return res(ctx.status(404))\r\n    }\r\n  }),\r\n)\r\n```\r\n- **setupServer**: 이름 그대로 서버를 만드는 역할이다. \r\n라우트 /todos/:id의 요청만 가로채서 todoId가 숫자인지 확인한 다음, 숫자일 때만 MOCK_TODO_RESPONSE와 id를 반환하고, 숫자가 아니라면 404를 반환하도록 코드를 구성했다. \r\n\r\n테스트 코드를 시작하기 전에는 서버를 기동하고, 종료되면 서버를 종료시킨다. \r\n\r\nafterEach에서 server.resetHandlers()가 있는 이유는 \r\n만일 `서버가 실패가 발생하는 경우`를 테스트할 때 ctx.status(503)과 같은 형태로 변경하는데,  이를 리셋하지 않으면 실패하는 코드로 남아있을 것이므로 테스트 실행마다 **resetHandlers**를 통해 setupServer로 초기화했던 초깃값을 유지하기 위한 것이다.\r\n\r\n그 다음 **describe**를 시작으로 테스트하고 싶은 내용을 테스트 코드로 작성해보자.\r\n```js\r\nit('버튼을 클릭하면 데이터를 불러온다.', async () => {\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const data = await screen.findByText(MOCK_TODO_RESPONSE.title)\r\n    expect(data).toBeInTheDocument()\r\n  })\r\n```\r\n버튼을 클릭해 fetch가 발생하는 시나리오를 테스트한다. 버튼을 클릭하는 것 까지는 동일하지만 이후 fetch 응답이 온 뒤에서야 비로소 찾고자 하는 값을 렌더링할 것이다.\r\n\r\n요소가 렌더링될 때까지 일정 시간 동안 기다리는 `find 메서드`를 사용해 요소를 검색한다.\r\n\r\n```js\r\n//여기서만 에러떠야하므로 위에서 resetHandlers 사용\r\n  it('버튼을 클릭하고 서버요청에서 에러가 발생하면 에러문구를 노출한다.', async () => {\r\n    server.use(\r\n      rest.get('/todos/:id', (req, res, ctx) => {\r\n        return res(ctx.status(503))\r\n      }),\r\n    )\r\n\r\n    const button = screen.getByRole('button', { name: /1번/ })\r\n    fireEvent.click(button)\r\n\r\n    const error = await screen.findByText(/에러가 발생했습니다/)\r\n    expect(error).toBeInTheDocument()\r\n  })\r\n```\r\n앞서 setupServer는 정상적인 응답만 모킹했기 때문에 에러가 발생하는 경우를 테스트하기 힘들다.\r\n\r\n서버 응답이 실패하는 경우를 테스트하기 위해서는 `server.use`를 사용해 기존 `setupServer`의 내용을 새롭게 덮어쓴다. 모든 경우에 503이 오도록 작성했고, 서버 설정이 끝난 후에는 **findBy**를 이용해 에러 문구가 정상적으로 노출됐는지 확인한다.\r\n\r\n**server.use**를 활용해 서버 기본 작동을 덮어쓰는 작업은 위의 코드에서만 유효해야하고, 다른 코드에서는 원래대로 다시 서버 작동이 되어야하므로 위에서 afterEach에서 resetHandlers를 실행하는 것이다. \r\n\r\n비동기 컴포넌트의 테스트에서 중요한 것은 **MSW를 사용한 fetch 응답 모킹**과 **findBy를 활용해 비동기 요청이 끝난 뒤에 제대로 된 렌더링이 일어났는지 기다린 후에 확인하는 것**이다.\r\n## 마치며\r\n지금까지 리액트에서 사용될 수 있는 3가지 종류의 컴포넌트 `정적 컴포넌트`, `동적 컴포넌트`, `비동기 이벤트가 발생하는 컴포넌트`의 간단한 테스트 코드를 살펴보았다.\r\n\r\n책에는 이외에도 추가로 `사용자 정의 훅을 테스트하기`가 있는데, 이 부분은 조만간 테스트가 익숙해진 이후 실제로 프로젝트에서 사용해본 사용자 정의 훅을 테스트하는  글을 포스팅해볼 예정이다.\r\n\r\n테스트에 관한 글은 계속 올릴 것 이니 많관부.\r\n\r\n\r\n\r\n\r\n\r\n"}]},"__N_SSG":true}
{"pageProps":{"posts":[{"slug":"posts/React Native/React Native 칸반보드 드래그 앤 드롭 구현기_1","title":"React Native 칸반보드 드래그 앤 드롭 구현기 (1)","date":"2025-12-28T22:16:00.000Z","image":"index.png","summary":"React Native에서 칸반보드 형태의 Drag & Drop을 구현하며 PanResponder 기반 절대 좌표 시스템을 선택한 이유와 구현 과정을 공유합니다.","tags":["react native","드래그 앤 드롭","PanResponder","칸반보드","트러블슈팅"],"content":"\r\n# React Native 칸반보드 드래그 앤 드롭 구현기(1)\r\n\r\n## 서론\r\n안녕하십니까. 오랜만에 다시 글을 쓰게 되었다.\r\n여러 프로젝트와 취업준비로 인해 한동안 글을 쓰지 못했는데, (~~(사실 의지력 이슈로)~~) 지금부터라도! 다시 열심히 글을 쓰려고 한다!\r\n\r\n관광데이터 공모전에서 다시 expo기반의 React Native로 프로젝트를 진행했었는데, 여기서 구현한 다양한 기능들 중 여행 일정을 관리하기 위해 드래그 앤 드롭을 사용하여 각 Day의 일정들을 드래그 앤 드롭으로 편집할 수 있어야 했다. 백문이 불여일견이라고 실제 구현했던 부분을 보여주겠다.\r\n\r\n<img src=\"1.gif\" alt=\"드래그 앤 드롭 구현 화면\"/>\r\n\r\n\r\n다음과 같이 같은 Day 내에서의 요소의 터치를 통한 이동, 리스트간에서도 요소를 이동할 수 있어야 했고, 요소가 특정 경계선으로 갈 경우 자동 스크롤도 되어야 했다.\r\n\r\n앞으로 이 기능을 구현할 때 필요했던 기술과 리스트 내에서 요소를 놓는 것을 구현했던 방법들을 보여줄 것이다.\r\n\r\n아직 취준생이라 많이 부족해보이겠지만 모쪼록 잘 부탁드립니다!!\r\n\r\n## 라이브러리 없이 Drag & Drop을 구현하기로 한 이유\r\n사실... 라이브러리로 구현하는게 분명히 더 쉽고, 정신건강(?)상도 좋았을 것이다. 하지만, 그럼에도 직접 구현을 선택했던 이유가 있다.\r\n\r\n우선, 기존에 나와있던 라이브러리를 살펴보자.\r\n(2025 8월~10월 기준으로 구현했을 때의 기준입니다.)\r\n\r\n\r\n\r\n## 필요 기술들\r\n###  react-beautiful-dnd\r\n가장 유명한 Drag & Drop 라이브러리는 `react-beautiful-dnd`였다.  \r\n웹 환경에서는 이미 검증된 라이브러리이고, 칸반보드 구현 사례도 풍부했다. 오 이걸로 하면 되겠군! \r\n\r\n하지만,\r\n\r\n-   **웹 전용 라이브러리**\r\n    \r\n-   React Native 환경에서는 사용 불가\r\n    \r\n\r\n아무리 구현 사례가 많아도, 이번 프로젝트에는 적용할 수 없는 선택지였다.\r\n\r\n----------\r\n\r\n###  react-native-draggable-flatlist\r\n\r\n다음으로 검토한 라이브러리는 제일 유명했던  `react-native-draggable-flatlist`였다.  \r\nReact Native 환경에서 Drag & Drop을 지원하는 대표적인 라이브러리다.\r\n\r\n단일 리스트 내에서 아이템 순서를 변경하는 용도로는 충분히 잘 동작했다.  \r\n하지만 실제 요구사항과 비교해보니 결정적인 차이가 있었다.\r\n\r\n-    **단일 리스트 기준 설계**\r\n    \r\n-   여러 컬럼(Day) 간 이동을 전제로 하지 않음\r\n    \r\n-   드래그 중 다른 리스트 위로 이동하는 시나리오가 구조적으로 맞지 않음\r\n    \r\n\r\n여러 개의 날짜 컬럼을 넘나드는 **칸반보드 형태의 Drag & Drop**을 구현하기에는  \r\n라이브러리의 기본 설계 자체가 맞지 않았다.\r\n\r\n무리하게 커스터마이징할 수도 있었겠지만,  \r\n그 경우 라이브러리 내부 구현에 강하게 의존하게 되고  \r\n유지보수 비용이 급격히 증가할 가능성이 높았다.\r\n\r\n그 외에도 Stack Overflow와 구글링을 통해 꾸준히 라이브러리를 찾아보았지만, 칸반보드 형태로 리스트 간 드래그 앤 드롭을 구현하는 최신 라이브러리가 없었고, 예제들 역시 매우 예전 것들 밖에 없었다.\r\n\r\n그래서 **직접 구현하자!** 라는 결론에 도달하게 되었다.\r\n\r\n## PanResponder를 선택한 이유\r\n\r\n라이브러리를 직접 구현하기로 결정한 뒤, 가장 먼저 고민한 건  \r\n**어떤 도구로 드래그 입력을 받을 것인가**였다.\r\n\r\nReact Native에서 제스처를 다루는 선택지는 몇 가지가 있지만,  \r\n이번 구현에서는 **PanResponder**를 기반으로 하기로 했다.\r\n\r\n### PanResponder란?\r\n\r\nPanResponder는 React Native에서 제공하는 기본 제스처 시스템이다.  \r\n터치 시작, 이동, 종료와 같은 이벤트를 세밀하게 제어할 수 있고,  \r\n외부 라이브러리 없이도 드래그 인터랙션을 구현할 수 있다.\r\n\r\n```js\r\nconst panResponder = PanResponder.create({\r\n  onStartShouldSetPanResponder: () => true,\r\n  onPanResponderMove: (evt, gestureState) => {\r\n    // 터치 이동 처리\r\n  },\r\n  onPanResponderRelease: () => {\r\n    // 터치 종료 처리\r\n  },\r\n});\r\n```\r\n\r\n사실 단순한 Drag & Drop이라면,  \r\n`gestureState.dx / dy` 값을 그대로 사용해서  \r\n카드를 움직이는 방식도 충분히 가능하다.\r\n\r\n하지만 이 프로젝트에서는 **그 방식이 맞지 않았다.**\r\n\r\n----------\r\n\r\n## PanResponder를 \"드래그 엔진\"으로 쓰지 않기로 한 이유\r\n칸반보드 형태의 Drag & Drop에서는\r\n다음과 같은 상황이 동시에 발생한다.\r\n\r\n- 여러 개의 세로 리스트\r\n- 각 리스트의 독립적인 스크롤\r\n- 드래그 중 다른 컬럼으로 이동\r\n- 화면 끝에서 자동 스크롤\r\n\r\n이 환경에서 PanResponder가 제공하는 gestureState.dx / dy 기반의 상대 좌표 시스템은 빠르게 한계를 드러냈다.\r\n상대 좌표의 문제점\r\n\r\n- dx/dy는 제스처 시작점 기준 누적 이동량이라 스크롤이 개입되면 기준점이 틀어진다\r\n- 컬럼이 여러 개일수록 각각의 레이아웃 좌표를 추적하기 복잡해진다\r\n- Portal로 렌더링된 Floating Card는 화면 최상위에 위치하므로 부모 컴포넌트 기준의 상대 좌표와 기준이 어긋난다\r\n\r\n결국 중요한 건\r\n\"제스처 시작점으로부터 얼마나 움직였는가\"가 아니라\r\n**지금 손가락이 화면의 어디에 있는가**였다.\r\n절대 좌표 기반 접근\r\n그래서 PanResponder의 `gestureState.dx/dy`를 버리고\r\n`evt.nativeEvent.pageX / pageY`로 화면 절대 좌표만을 사용했다.\r\n이 방식의 장점은 명확했다.\r\n\r\n- 스크롤 여부와 상관없이 항상 동일한 기준 (화면 좌상단 기준)\r\n- 여러 컬럼 간 이동에도 좌표가 일관됨\r\n- Portal에 렌더링된 Floating Card의 위치 계산과 자연스럽게 연결됨\r\n- 드롭 타겟 판별 시 모든 요소가 같은 좌표계를 공유\r\n\r\n즉, PanResponder는\r\n**상대 이동량을 계산하는 도구**가 아니라\r\n**현재 터치 위치를 전달하는 도구**가 되었다.\r\n**역할을 명확히 나누다**\r\n\r\n이 시점에서 Drag & Drop 구조는 이렇게 나뉘었다.\r\n\r\n- PanResponder\r\n\r\n  - 터치 시작 / 이동 / 종료 감지\r\n  - 현재 손가락의 절대 좌표(pageX/pageY) 전달\r\n\r\n\r\n- 드래그 로직\r\n  - 절대 좌표 기반 상대 이동량 계산\r\n  - 드롭 위치 판별 (어느 컬럼, 어느 인덱스)\r\n  - 컬럼 간 이동 계산\r\n  - 스크롤 오프셋 보정\r\n  - 데이터 업데이트\r\n\r\n\r\n- 시각적 표현\r\n\r\n  - Portal을 통한 Floating Card 렌더링\r\n  - 절대 좌표 기반 초기 위치 설정\r\n  - Animated.Value로 이동량 반영\r\n  - opacity, scale 등의 피드백 애니메이션\r\n\r\n\r\n\r\nPanResponder가 모든 걸 책임지지 않게 되자,\r\n구현은 오히려 단순해졌고\r\n각 로직을 독립적으로 테스트하고 개선할 수 있었다.\r\n\r\n## 이어서\r\n다음 편에서는 이를 이용한 구현코드들을 보여줄 예정이다. 기대 부탁~"},{"slug":"posts/React Native/React Native에서 Google Maps 연동 및 위치 추적 기능 구현하기","title":"React Native에서 Google Maps 연동 및 위치 추적 기능 구현하기","date":"2025-03-25T13:40:00.000Z","image":"index.png","summary":"React Native에서 Google Maps 연동 및 위치 추적 기능 구현하고, 초기 위치 설정하는 과정에서 발생한 문제를 해결하는 과정입니다.","tags":["react native","트러블슈팅","google map","expo-location","졸업작품"],"content":"\r\n# React Native에서 Google Maps 연동 및 위치 추적 기능 구현하기\r\n\r\n## 1. 개요\r\n\r\n최근 졸업작품인 러닝 크루 앱을 개발하면서 `react native`를 처음 써보았다. 앱에서 사용자의 현재 위치 및 코스 표시를 위해  `react-native-maps`를 활용해 Google Maps를 연동하였고, 사용자의 위치는 `expo-location`을 활용해 실시간으로 받아왔다.\r\n\r\n본 게시글에서는 `expo-location`을 통해 사용자의 위치를 받아오는 방법, `react-native-maps`를 통해 구글맵을 연동하는 방법 및 위치를 지도에 마커로 표시하는 과정, 그리고 러닝 중이라는 가정하에 지도의 중심이 사용자의 위치를 따라가도록 하는 것을 다뤄볼 것이다.\r\n그리고 끝으로 지도의 초기 위치를 내위치로 설정하던 과정에서 발생했던 문제도 다뤄볼 예정이다.\r\n\r\n## 2. 환경 설정\r\n\r\n### 2.1. 라이브러리 설치\r\n\r\nGoogle Maps를 React Native에서 사용하기 위해 `react-native-maps`를 설치한다.\r\n\r\n```\r\nnpx expo install react-native-maps\r\n```\r\n\r\n추가로, 현재 위치를 가져오기 위해 `expo-location`을 설치한다.\r\n\r\n```\r\nnpx expo install expo-location\r\n```\r\n> npx expo install로 설치하는 이유: \r\n>나 같은 경우 expo를 사용하여 react native개발을 하고 있고, 이 명령어를 사용하면 expo에서 공식적으로 지원하는 패키지 버전으로 라이브러리가 설치된다고 한다. \r\n>그렇기 때문에 expo를 사용할때는 가급적 npm install 보다는 npx expo install을 권장한다고 한다.\r\n\r\n### 2.2. Google Maps API 키 설정\r\n\r\nGoogle Maps API를 사용하려면 Google Cloud Platform에서 API 키를 발급받아야 한다.\r\n\r\n그러기 위해서\r\n\r\n1. 구글 콘솔에서 프로젝트를 만든다\r\n2. api 및 서비스에 들어가서 `Maps for javascript sdk`를 허용한다.\r\n<img src=\"1.png\" alt=\"api 및 서비스 허용\"/>\r\n3. 그 다음 키 및 사용자 인증정보 항목에서 api키를 만들기로 api 키를 만든다.\r\n<img src=\"2.png\" alt=\"api키 생성\"/>\r\n- 키의 제한은 따로 없게했다. 보안을 위해서는 android용과  ios까지 따로따로 하는게 좋지만, 우선 본 게시글에선 따로 제한은 없게 할 것이다.\r\n<img src=\"3.png\" alt=\"키의 제한없도록 하기\"/>\r\n4. app.json에서 이런식으로 키를 넣어 구글맵을 설정한다.\r\n- android는 app.json의 \"android\"안에 아래 코드를 추가한다.\r\n```json\r\n\"config\": {\r\n\t\"googleMaps\": {\r\n\t\t\"apiKey\": \"apikey\"\r\n}\r\n```\r\n\r\n-  ios까지 설정해주려면면 이런식으로 app.json안에 설정해준다.\r\n```json\r\n\"ios\": {\r\n\t\"bundleIdentifier\": \"com.company.runnershigh\",\r\n\t\"supportsTablet\": true,\r\n\t\"config\": {\r\n\t\t\"googleMapsApiKey\": \"apikey\"\r\n\t}\r\n},\r\n```\r\n이렇게 하면 기본적인 설정은 끝이난다.\r\n## 3. 구현\r\n\r\n### 3.1 `MapView`를 사용하여 지도를 보여주기\r\n```js\r\nimport MapView, { PROVIDER_GOOGLE } from \"react-native-maps\";\r\n      <MapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: 37.78825,\r\n          longitude: -122.4324,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n      >\r\n      </MapView>\r\n```\r\n`PROVIDER_GOOGLE`을 사용하면 MapView에 굳이 키를 직접 추가하지 않더라도 미리 키가 설정되어있다면 google map을 사용할 수 있다.\r\n`initialRegion`은 말그대로 맵이 로드될 때 처음 위치를 말한다.\r\n### 3.2. `MapView`에 현재 위치 표시하기\r\n사용자의 현재 위치를 받아오기 위해 `expo-location`을 사용했다.\r\n\r\n\r\n\r\n```js\r\nimport * as Location from \"expo-location\";\r\n\r\n  const [permissionStatus, requestPermission] =\r\n    Location.useForegroundPermissions();\r\n```\r\n` Location.useForegroundPermissions()`을 통해, 앱이 켜져있을 때 사용자의 위치를 받는 것의 권한을 물어볼 수 있다.\r\n이를 포함하여 askPermission이라는 함수로\r\n```js\r\nconst askPermission = async () => {\r\n    if (!permissionStatus || !permissionStatus.granted) {\r\n      const permission = await requestPermission();\r\n      if (!permission.granted) {\r\n        return Alert.alert(\"위치 권한 필요\", \"위치 권한을 허용해주세요.\");\r\n      }\r\n    }\r\n  };\r\n```\r\n이렇게 권한을 받도록 하였다.\r\n이 `askPermission`이라는 코드는 \r\n```js\r\n  const [myLocation, setMyLocation] =\r\n    useState<Location.LocationObjectCoords | null>(null);\r\n  const [subscription, setSubscription] =\r\n    useState<Location.LocationSubscription | null>(null);\r\n```\r\n사용자의 위치를 받는 myLocation과 위치 구독정보를 받는 subscription이라는 상태를 지정해준다음,\r\n\r\n```js\r\n// 위치 추적 시작\r\nconst startLocationTracking = async () => {\r\n  const sub = await Location.watchPositionAsync(\r\n    {\r\n      accuracy: Location.Accuracy.High,\r\n      timeInterval: 3000, // 3초마다 업데이트\r\n      distanceInterval: 5, // 5m 이동마다 업데이트\r\n    },\r\n    (newLocation) => {\r\n      setMyLocation(newLocation.coords);\r\n    }\r\n  );\r\n  setSubscription(sub);\r\n};\r\n```\r\n`Location.watchPositionAsync()` 함수는 사용자의 위치를 실시간으로 받아오게 하고, 이것을 활용하여, 사용자의 위치와 위치 구독 정보를 업데이트한다.\r\n\r\n```js\r\nconst stopLocationTracking = () => {\r\n  if (subscription) {\r\n    subscription.remove();\r\n    setSubscription(null);\r\n  }\r\n};\r\n```\r\n위치 추적을 멈추게하는 코드는 다음과 같다. 위치 구독정보를 삭제해주는 코드이다.\r\n\r\n이를 `useEffect`를 통해 \r\n```js\r\nuseEffect(() => {\r\n  startLocationTracking();\r\n  return () => {\r\n    stopLocationTracking();\r\n  };\r\n}, []);\r\n```\r\n이런식으로 지정해주어 컴포넌트가 처음 마운트 될 때에 위치추적을 시작하고, 언마운트되면 위치추적을 그만둔다.\r\n\r\n`initialRegion`도 사용자의 위치를 지정해준다.\r\n```js\r\nconst mapRef = useRef<MapView>(null);\r\nmyLocation && (\r\n  <MapView\r\n    ref = {mapRef}\r\n    style={{ flex: 1 }}\r\n    provider={PROVIDER_GOOGLE}\r\n    initialRegion={{\r\n            latitude: myLocation?.latitude,\r\n            longitude: myLocation?.longitude,\r\n            latitudeDelta: 0.02,\r\n            longitudeDelta: 0.02,\r\n          }}\r\n/>\r\n)\r\n```\r\n\r\n### 3.3. 지도 중심이 사용자의 위치에 맞게 이동하게 하기\r\n\r\n이제 러닝중이라는 것을 가정하고, 현재 위치를 기준으로 지도 중심을 이동시켜 볼 것이다.\r\n우선 `MapView`의 인스턴스에 직접 접근하기 위해 ref를 사용해야 한한다.\r\n\r\n```js\r\nconst mapRef = useRef<MapView>(null);\r\n\r\n<MapView\r\n  ref = {mapRef}\r\n  style={{ flex: 1 }}\r\n  provider={PROVIDER_GOOGLE}\r\n  {/*...*/}  \r\n>\r\n```\r\n이런식으로 `mapRef`를 통해 `MapView`의 인스턴스에 직접 접근할 수 있도록 한다.\r\n그 다음 만일 사용자의 위치를 카메라가 따라가고 싶게 만들고 싶다면, \r\n```js\r\nconst mapRef = useRef<MapView>(null);\r\n\r\nuseEffect(() => {\r\n  if (myLocation) {\r\n    mapRef.current?.animateCamera({\r\n      center: myLocation,\r\n      zoom: 18,\r\n    });\r\n  }\r\n}, [myLocation]);\r\n```\r\n이런식으로 아까 지정해 준 `myLocation`을 `useEffect`의 의존성으로 집어넣어 주고, `MapView`의 인스턴스중 `animateCamera`라는 인스턴스를 이렇게 사용하여 `myLocation`에 카메라가 고정이 되도록(카메라가 사용자의 위치를 따라가도록) 할 수 있다.\r\n\r\n\r\n## 문제 해결 : 초기 위치의 범위가 지나치게 커지는 현상\r\n`initialRegion`의 latitudeDelta와 longitudeDelta가 적용이 되지 않았고, 마커자체는 내 위치이지만 지도 범위가 초기에 대한민국 한반도 전체가 보이는 문제가 발생했다.\r\n```js\r\nmyLocation && (\r\n<MapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: myLocation?.latitude,\r\n          longitude: myLocation?.longitude,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n      >\r\n      </MapView>\r\n)\r\n```\r\ninitialRegion은 처음에만 위치가 적용이되고, 그 이후에 위치가 바뀌는 것은 적용이 되지 않는다고 하는데, myLocation은 지속적으로 위치추적을 하는 코드이기 때문에 지속적으로 비동기적으로 업데이트가 된다. 그래서 그 부분에서 꼬이지 않았나 생각이 든다. \r\n\r\n그래서 이부분에 대해서 고민을 해보았고, 지도의 레이아웃이 처음에 지도를 로드할 때만 바뀌고, 그 이후에는 바뀌지 않는다라는 생각에 `MapView`의 `onLayout`이에 `animateToRegion`으로 지도의 중심 및 범위를 이동시키는 코드를 넣어봤다.\r\n\r\n- `onLayout`: MapView가 화면에 배치될 때(즉, 첫 렌더링될 때) 호출되는 이벤트(뷰의 위치와 크기를 할당하는 단계이다.)\r\n- `animateToRegion(region, duration)`: 지도 영역을 애니메이션으로 이동하는 함수\r\n```js\r\n<MapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: myLocation?.latitude,\r\n          longitude: myLocation?.longitude,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n        onLayout={() => {\r\n              if (mapRef.current) {\r\n                mapRef.current.animateToRegion(\r\n                  {\r\n                    latitude: myLocation?.latitude,\r\n                    longitude: myLocation?.longitude,\r\n                    latitudeDelta: 0.02,\r\n                    longitudeDelta: 0.02,\r\n                  },\r\n                  0\r\n                );\r\n              }\r\n            }}\r\n      />\r\n\r\n```\r\n\r\n하지만, 헤더에서 장소를 검색하여 위치를 이동시키는 기능을 구현하던 도중 문제가 발생했는데, 키보드를 열 때마다 지도가 자동으로 리사이징이 되면서 `onLayout` 안의 코드가 실행이 되는 것이었다.\r\n\r\n내가 원하는건 지도가 처음 로드가 될 때 초기에 한번만 지도가 내 위치로 설정이 되는 것인데, 키보드가 열릴때마다 원치않게 내 위치로 지도가 자동 이동이 되는 문제가 발생했다.\r\n\r\n결국 `onLayout`이 아닌 MapView의 또다른 콜백 메소드인 **onMapReady**를 통해 문제를 해결했다.\r\n\r\n- `onMapReady`: 지도가 준비되었을 때 호출되는 콜백 메서드이며, 안의 코드는 지도가 준비되었을 때 초기에 한번만 실행된다.\r\n\r\n```js\r\n<MapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: myLocation?.latitude,\r\n          longitude: myLocation?.longitude,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n        onMapReady={() => {\r\n              if (mapRef.current) {\r\n                mapRef.current.animateToRegion(\r\n                  {\r\n                    latitude: myLocation?.latitude,\r\n                    longitude: myLocation?.longitude,\r\n                    latitudeDelta: 0.02,\r\n                    longitudeDelta: 0.02,\r\n                  },\r\n                  0\r\n                );\r\n              }\r\n            }}\r\n      />\r\n```\r\n이제 키보드가 열려도 위치가 이동하지 않았다!\r\n"},{"slug":"posts/React/setState는 비동기일까","title":"setState는 비동기일까","date":"2025-03-11T13:00:24.000Z","image":"index.png","summary":"setState가 왜 동기 함수인지, 그리고 react서는 setState를 통해 상태 업데이트를 어떻게 하는지 알아보자.","tags":["react","JavaScript","deepdive","useState","hook"],"content":"# setState는 비동기일까?\r\n\r\n## 🔹setState가 왜 바로 반영이 안되지?\r\nReact에서 `setState`를 사용하다 보면, 처음에 많은 프론트엔드 개발자들이 한 가지 의문을 가지게 된다.\r\n```js\r\nconst [count, setCount] = useState(0);\r\n\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  console.log(count);\r\n};\r\n```\r\n`console.log(count)`에서는 업데이트된 값인 **1**이 출력되어야 할거같지만,  그게 아닌아니라 **0**이 출력됩니다.\r\n\r\n코드만 봤을 때는 업데이트된 값인 1이 출력되는게 맞는 거 같은데 **왜 이전 값인 0이 출력되는걸까?** async await를 쓰지 않지만 setState가 비동기라 그런걸까?\r\n\r\n결론부터 말하자면 setState는 **비동기 처럼 동작하지만, 실제로는 동기함수이다.**\r\n 이에 대해 자세히 살펴보자.\r\n\r\n## 🔹 setState의 동작방식\r\n\r\nsetState 자체는 동기적으로 실행되지만, setState로 인한 상태업데이트와 렌더링은 비동기적으로 이루어진다. \r\n\r\n왜 setState가 동기적인지는 우선 이따가 살펴보고, 우선 setState의 동작방식에 대해 알아보자.\r\n\r\n\r\n```js\r\nconst [count, setCount] = useState(0);\r\n\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  console.log(count); // 출력값은 1이다.\r\n};\r\n```\r\n아까 전 살펴봤던 코드이다. 왜 업데이트 된 값이 바로 반영이 안되었던 걸까?\r\n\r\n이유는 React는 최적화를 위해 상태 변경을 비동기적으로 처리하고 있기 때문입니다.\r\n\r\n### 배치 업데이트 (Batching)\r\nReact는 여러 개의 `setState` 호출을 하나로 비동기적으로 묶어서 처리하고, 이것을 **배치(batch) 업데이트**를 수행한다고합니다.  \r\n즉, 같은 이벤트 핸들러에서 여러 개의 `setState`가 호출되더라도 **한 번의 렌더링에서 처리**됩니다. \r\n\r\n```js\r\nconst handleClick = () => {\r\n  setCount(10);\r\n  setCount(count + 1);\r\n  setCount(30);\r\n  console.log(\"현재 count 값:\", count);\r\n};\r\n```\r\n즉 위의 3개의 setState는 한번에 함수 내 에서 하나씩 순서대로 실행되는 것이 아닌, **비동기적으로 한번에 처리가 되는 것 이다.**\r\n\r\n그렇다면 다음 코드를 보자.\r\n```js\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  setCount(count + 1);\r\n  setCount(count + 1);\r\n  console.log(\"현재 count 값:\", count);\r\n};\r\n```\r\n다음과 같은 경우 현재 count 값이 0으로 출력되는 것은 이제 알 것이다.\r\n```js\r\n현재 count 값: 0  // 이전 값이 출력\r\n```\r\n그렇다면 최종적으로 count 값은 몇이 될까? `\r\n\r\n`setCount(count + 1)`가 3번 호출되었지만, 최종적으로 `count` 값은 **1만 증가**한다.\r\n\r\n이유는 역시 React는 동일한 이벤트 핸들러 내에서 여러 개의 `setState`를 **배치 처리**하여 하나로 합쳐버리기 때문이다.\r\n즉, \r\n```js\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\n\r\n```\r\n-   `setState`는 바로 실행되지만, **이벤트 핸들러 내부에서는 `count` 값이 0으로 유지됨**\r\n-   따라서 모든 `setCount(count + 1)`은 결국 `setCount(1)`과 동일\r\n\r\n만일 의도한 바대로 count를 1씩증가시켜 3으로 만들고 싶다면, \r\n```js\r\nconst handleClick = () => {\r\n  setCount(prev => prev + 1);\r\n  setCount(prev => prev + 1);\r\n  setCount(prev => prev + 1);\r\n};\r\n```\r\n이런 식으로 코드를 짜면, 배치 처리와 상관없이 이전 값을 기반으로 상태를 변경한다.\r\n\r\n이렇게 setState는 React내에서 비동기적으로 상태 업데이트를 진행하는데, 왜 그럼에도 동기함수라고 하는걸까?\r\n\r\n## 🔹 setState가 동기함수인 이유\r\n\r\n**setState**의 상태 업데이트는 React내에서 배치처리를 통해 비동기적으로 이루어지지만, setState 자체는 **호출 즉시 실행**되므로 **동기 함수**이다.\r\n\r\n즉, 예를들어서,\r\n```js\r\nconst handleClick = () => {\r\n  console.log(\"Before setState:\", count);\r\n  setCount(count + 1);\r\n  console.log(\"After setState:\", count);\r\n};\r\n```\r\n위의 `setCount(count + 1);` 함수 자체는 실행될 때, 실행되는 즉시 함수가 종료가 된다. \r\n`setCount`가 진짜 비동기 함수였다면, **비동기 작업(Promise 등)을 반환**해야 하지만 그런 동작을 하지 않는 것이다.\r\n\r\n다만 setCount가 실행되어 상태 변경을 요청하면, \r\n**React가 이 요청을 현재 수행중인 이벤트가 핸들러가 끝날 때까지 기다린 후 배치처리를 수행하는 것이다.**\r\n \r\n setState가 비동기 함수 였다면,\r\n ```js\r\n const handleClick = async () => {\r\n  console.log(\"Before setState:\", count);\r\n  await setCount(count + 1);  //  실제로는 이렇게 사용 불가능\r\n  console.log(\"After setState:\", count);\r\n};\r\n ```\r\n 이런식으로 사용할 수 있어야 하지만, `setState`는 Promise를 반환하지 않으므로 `await`을 사용할 수 없다.\r\n \r\n 즉 setState는 **React의 내부적인 상태 업데이트와 렌더링 방식**으로 인해 비동기적으로 실행되는 것처럼 보이지만 엄밀히 말하면 **동기 함수**이다.\r\n\r\n## 결론\r\n\r\nsetState를 통해 React가 상태를 업데이트하는 과정을 정리하면 다음과 같다.\r\n\r\n1.  `setState` 호출 → 상태 변경 요청 (동기적으로 동작)\r\n2.  React가 현재 실행 중인 이벤트 핸들러가 끝날 때까지 기다림\r\n3.  **배치 처리**를 수행하여 여러 개의 `setState`를 한꺼번에 처리(비동기적 최적화)\r\n4.  상태 업데이트 후 리렌더링을 트리거\r\n\r\n`setState`는 동기적으로 실행되지만,  React의 **상태 변경과 렌더링 과정이 비동기적으로 최적화되어 실행된다.**"}]},"__N_SSG":true}
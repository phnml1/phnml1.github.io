{"pageProps":{"posts":[{"slug":"posts/React Native/React Native에서 Google Maps 연동 및 위치 추적 기능 구현하기","title":"React Native에서 Google Maps 연동 및 위치 추적 기능 구현하기","date":"2025-03-25T13:40:00.000Z","image":"index.png","summary":"React Native에서 Google Maps 연동 및 위치 추적 기능 구현하고, 초기 위치 설정하는 과정에서 발생한 문제를 해결하는 과정입니다.","tags":["react native","트러블슈팅","google map","expo-location","졸업작품"],"content":"\r\n# React Native에서 Google Maps 연동 및 위치 추적 기능 구현하기\r\n\r\n## 1. 개요\r\n\r\n최근 졸업작품인 러닝 크루 앱을 개발하면서 `react native`를 처음 써보았다. 앱에서 사용자의 현재 위치 및 코스 표시를 위해  `react-native-maps`를 활용해 Google Maps를 연동하였고, 사용자의 위치는 `expo-location`을 활용해 실시간으로 받아왔다.\r\n\r\n본 게시글에서는 `expo-location`을 통해 사용자의 위치를 받아오는 방법, `react-native-maps`를 통해 구글맵을 연동하는 방법 및 위치를 지도에 마커로 표시하는 과정, 그리고 러닝 중이라는 가정하에 지도의 중심이 사용자의 위치를 따라가도록 하는 것을 다뤄볼 것이다.\r\n그리고 끝으로 지도의 초기 위치를 내위치로 설정하던 과정에서 발생했던 문제도 다뤄볼 예정이다.\r\n\r\n## 2. 환경 설정\r\n\r\n### 2.1. 라이브러리 설치\r\n\r\nGoogle Maps를 React Native에서 사용하기 위해 `react-native-maps`를 설치한다.\r\n\r\n```\r\nnpx expo install react-native-maps\r\n```\r\n\r\n추가로, 현재 위치를 가져오기 위해 `expo-location`을 설치한다.\r\n\r\n```\r\nnpx expo install expo-location\r\n```\r\n> npx expo install로 설치하는 이유: \r\n>나 같은 경우 expo를 사용하여 react native개발을 하고 있고, 이 명령어를 사용하면 expo에서 공식적으로 지원하는 패키지 버전으로 라이브러리가 설치된다고 한다. \r\n>그렇기 때문에 expo를 사용할때는 가급적 npm install 보다는 npx expo install을 권장한다고 한다.\r\n\r\n### 2.2. Google Maps API 키 설정\r\n\r\nGoogle Maps API를 사용하려면 Google Cloud Platform에서 API 키를 발급받아야 한다.\r\n\r\n그러기 위해서\r\n\r\n1. 구글 콘솔에서 프로젝트를 만든다\r\n2. api 및 서비스에 들어가서 `Maps for javascript sdk`를 허용한다.\r\n<img src=\"1.png\" alt=\"api 및 서비스 허용\"/>\r\n3. 그 다음 키 및 사용자 인증정보 항목에서 api키를 만들기로 api 키를 만든다.\r\n<img src=\"2.png\" alt=\"api키 생성\"/>\r\n- 키의 제한은 따로 없게했다. 보안을 위해서는 android용과  ios까지 따로따로 하는게 좋지만, 우선 본 게시글에선 따로 제한은 없게 할 것이다.\r\n<img src=\"3.png\" alt=\"키의 제한없도록 하기\"/>\r\n4. app.json에서 이런식으로 키를 넣어 구글맵을 설정한다.\r\n- android는 app.json의 \"android\"안에 아래 코드를 추가한다.\r\n```json\r\n\"config\": {\r\n\t\"googleMaps\": {\r\n\t\t\"apiKey\": \"apikey\"\r\n}\r\n```\r\n\r\n-  ios까지 설정해주려면면 이런식으로 app.json안에 설정해준다.\r\n```json\r\n\"ios\": {\r\n\t\"bundleIdentifier\": \"com.company.runnershigh\",\r\n\t\"supportsTablet\": true,\r\n\t\"config\": {\r\n\t\t\"googleMapsApiKey\": \"apikey\"\r\n\t}\r\n},\r\n```\r\n이렇게 하면 기본적인 설정은 끝이난다.\r\n## 3. 구현\r\n\r\n### 3.1 MapView를 사용하여 지도를 보여주기\r\n```js\r\nimport MapView, { PROVIDER_GOOGLE } from \"react-native-maps\";\r\n      <MapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: 37.78825,\r\n          longitude: -122.4324,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n      >\r\n      </MapView>\r\n```\r\n`PROVIDER_GOOGLE`을 사용하면 MapView에 굳이 키를 직접 추가하지 않더라도 미리 키가 설정되어있다면 google map을 사용할 수 있다.\r\n`initialRegion`은 말그대로 맵이 로드될 때 처음 위치를 말한다.\r\n### 3.2. MapView에 현재 위치 표시하기\r\n사용자의 현재 위치를 받아오기 위해 `expo-location`을 사용했다.\r\n\r\n\r\n\r\n```js\r\nimport * as Location from \"expo-location\";\r\n\r\n  const [permissionStatus, requestPermission] =\r\n    Location.useForegroundPermissions();\r\n```\r\n` Location.useForegroundPermissions()`을 통해, 앱이 켜져있을 때 사용자의 위치를 받는 것의 권한을 물어볼 수 있다.\r\n이를 포함하여 askPermission이라는 함수로\r\n```js\r\nconst askPermission = async () => {\r\n    if (!permissionStatus || !permissionStatus.granted) {\r\n      const permission = await requestPermission();\r\n      if (!permission.granted) {\r\n        return Alert.alert(\"위치 권한 필요\", \"위치 권한을 허용해주세요.\");\r\n      }\r\n    }\r\n  };\r\n```\r\n이렇게 권한을 받도록 하였다.\r\n이 `askPermission`이라는 코드는 \r\n```js\r\n  const [myLocation, setMyLocation] =\r\n    useState<Location.LocationObjectCoords | null>(null);\r\n  const [subscription, setSubscription] =\r\n    useState<Location.LocationSubscription | null>(null);\r\n```\r\n사용자의 위치를 받는 myLocation과 위치 구독정보를 받는 subscription이라는 상태를 지정해준다음,\r\n\r\n```js\r\n// 위치 추적 시작\r\nconst startLocationTracking = async () => {\r\n  const sub = await Location.watchPositionAsync(\r\n    {\r\n      accuracy: Location.Accuracy.High,\r\n      timeInterval: 3000, // 3초마다 업데이트\r\n      distanceInterval: 5, // 5m 이동마다 업데이트\r\n    },\r\n    (newLocation) => {\r\n      setMyLocation(newLocation.coords);\r\n    }\r\n  );\r\n  setSubscription(sub);\r\n};\r\n```\r\n`Location.watchPositionAsync()` 함수는 사용자의 위치를 실시간으로 받아오게 하고, 이것을 활용하여, 사용자의 위치와 위치 구독 정보를 업데이트한다.\r\n\r\n```js\r\nconst stopLocationTracking = () => {\r\n  if (subscription) {\r\n    subscription.remove();\r\n    setSubscription(null);\r\n  }\r\n};\r\n```\r\n위치 추적을 멈추게하는 코드는 다음과 같다. 위치 구독정보를 삭제해주는 코드이다.\r\n\r\n이를 `useEffect`를 통해 \r\n```js\r\nuseEffect(() => {\r\n  startLocationTracking();\r\n  return () => {\r\n    stopLocationTracking();\r\n  };\r\n}, []);\r\n```\r\n이런식으로 지정해주어 컴포넌트가 처음 마운트 될 때에 위치추적을 시작하고, 언마운트되면 위치추적을 그만둔다.\r\n\r\n`initialRegion`도 사용자의 위치를 지정해준다.\r\n```js\r\nconst mapRef = useRef<MapView>(null);\r\nmyLocation && (\r\n  <MapView\r\n    ref = {mapRef}\r\n    style={{ flex: 1 }}\r\n    provider={PROVIDER_GOOGLE}\r\n    initialRegion={{\r\n            latitude: myLocation?.latitude,\r\n            longitude: myLocation?.longitude,\r\n            latitudeDelta: 0.02,\r\n            longitudeDelta: 0.02,\r\n          }}\r\n/>\r\n)\r\n```\r\n\r\n### 3.3. 지도 중심이 사용자의 위치에 맞게 이동하게 하기\r\n\r\n이제 러닝중이라는 것을 가정하고, 현재 위치를 기준으로 지도 중심을 이동시켜 볼 것이다.\r\n우선 `MapView`의 인스턴스에 직접 접근하기 위해 ref를 사용해야 한한다.\r\n\r\n```js\r\nconst mapRef = useRef<MapView>(null);\r\n\r\n<MapView\r\n  ref = {mapRef}\r\n  style={{ flex: 1 }}\r\n  provider={PROVIDER_GOOGLE}\r\n  {/*...*/}  \r\n>\r\n```\r\n이런식으로 `mapRef`를 통해 `MapView`의 인스턴스에 직접 접근할 수 있도록 한다.\r\n그 다음 만일 사용자의 위치를 카메라가 따라가고 싶게 만들고 싶다면, \r\n```js\r\nconst mapRef = useRef<MapView>(null);\r\n\r\nuseEffect(() => {\r\n  if (myLocation) {\r\n    mapRef.current?.animateCamera({\r\n      center: myLocation,\r\n      zoom: 18,\r\n    });\r\n  }\r\n}, [myLocation]);\r\n```\r\n이런식으로 아까 지정해 준 `myLocation`을 `useEffect`의 의존성으로 집어넣어 주고, `MapView`의 인스턴스중 `animateCamera`라는 인스턴스를 이렇게 사용하여 `myLocation`에 카메라가 고정이 되도록(카메라가 사용자의 위치를 따라가도록) 할 수 있다.\r\n\r\n\r\n## 문제 해결 : 초기 위치의 범위가 지나치게 커지는 현상\r\n`initialRegion`의 latitudeDelta와 longitudeDelta가 적용이 되지 않았고, 마커자체는 내 위치이지만 지도 범위가 초기에 대한민국 한반도 전체가 보이는 문제가 발생했다.\r\n```js\r\nmyLocation && (\r\n<MapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: myLocation?.latitude,\r\n          longitude: myLocation?.longitude,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n      >\r\n      </MapView>\r\n)\r\n```\r\ninitialRegion은 처음에만 위치가 적용이되고, 그 이후에 위치가 바뀌는 것은 적용이 되지 않는다고 하는데, myLocation은 지속적으로 위치추적을 하는 코드이기 때문에 지속적으로 비동기적으로 업데이트가 된다. 그래서 그 부분에서 꼬이지 않았나 생각이 든다. \r\n\r\n그래서 이부분에 대해서 고민을 해보았고, 지도의 레이아웃이 처음에 지도를 로드할 때만 바뀌고, 그 이후에는 바뀌지 않는다라는 생각에 `MapView`의 `onLayout`이에 `animateToRegion`으로 지도의 중심 및 범위를 이동시키는 코드를 넣어봤다.\r\n\r\n- `onLayout`: MapView가 화면에 배치될 때(즉, 첫 렌더링될 때) 호출되는 이벤트(뷰의 위치와 크기를 할당하는 단계이다.)\r\n- `animateToRegion(region, duration)`: 지도 영역을 애니메이션으로 이동하는 함수\r\n```js\r\n<MapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: myLocation?.latitude,\r\n          longitude: myLocation?.longitude,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n        onLayout={() => {\r\n              if (mapRef.current) {\r\n                mapRef.current.animateToRegion(\r\n                  {\r\n                    latitude: myLocation?.latitude,\r\n                    longitude: myLocation?.longitude,\r\n                    latitudeDelta: 0.02,\r\n                    longitudeDelta: 0.02,\r\n                  },\r\n                  0\r\n                );\r\n              }\r\n            }}\r\n      />\r\n\r\n```\r\n\r\n하지만, 헤더에서 장소를 검색하여 위치를 이동시키는 기능을 구현하던 도중 문제가 발생했는데, 키보드를 열 때마다 지도가 자동으로 리사이징이 되면서 `onLayout` 안의 코드가 실행이 되는 것이었다.\r\n\r\n내가 원하는건 지도가 처음 로드가 될 때 초기에 한번만 지도가 내 위치로 설정이 되는 것인데, 키보드가 열릴때마다 원치않게 내 위치로 지도가 자동 이동이 되는 문제가 발생했다.\r\n\r\n결국 `onLayout`이 아닌 MapView의 또다른 콜백 메소드인 **onMapReady**를 통해 문제를 해결했다.\r\n\r\n- `onMapReady`: 지도가 준비되었을 때 호출되는 콜백 메서드이며, 안의 코드는 지도가 준비되었을 때 초기에 한번만 실행된다.\r\n\r\n```js\r\n<MapView\r\n        style={styles.map}\r\n        provider={PROVIDER_GOOGLE}\r\n        initialRegion={{\r\n          latitude: myLocation?.latitude,\r\n          longitude: myLocation?.longitude,\r\n          latitudeDelta: 0.02,\r\n          longitudeDelta: 0.02,\r\n        }}\r\n        onMapReady={() => {\r\n              if (mapRef.current) {\r\n                mapRef.current.animateToRegion(\r\n                  {\r\n                    latitude: myLocation?.latitude,\r\n                    longitude: myLocation?.longitude,\r\n                    latitudeDelta: 0.02,\r\n                    longitudeDelta: 0.02,\r\n                  },\r\n                  0\r\n                );\r\n              }\r\n            }}\r\n      />\r\n```\r\n이제 키보드가 열려도 위치가 이동하지 않았다!\r\n"},{"slug":"posts/React/setState는 비동기일까","title":"setState는 비동기일까","date":"2025-03-11T13:00:24.000Z","image":"index.png","summary":"setState가 왜 동기 함수인지, 그리고 react서는 setState를 통해 상태 업데이트를 어떻게 하는지 알아보자.","tags":["react","JavaScript","deepdive","useState","hook"],"content":"# setState는 비동기일까?\r\n\r\n## 🔹setState가 왜 바로 반영이 안되지?\r\nReact에서 `setState`를 사용하다 보면, 처음에 많은 프론트엔드 개발자들이 한 가지 의문을 가지게 된다.\r\n```js\r\nconst [count, setCount] = useState(0);\r\n\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  console.log(count);\r\n};\r\n```\r\n`console.log(count)`에서는 업데이트된 값인 **1**이 출력되어야 할거같지만,  그게 아닌아니라 **0**이 출력됩니다.\r\n\r\n코드만 봤을 때는 업데이트된 값인 1이 출력되는게 맞는 거 같은데 **왜 이전 값인 0이 출력되는걸까?** async await를 쓰지 않지만 setState가 비동기라 그런걸까?\r\n\r\n결론부터 말하자면 setState는 **비동기 처럼 동작하지만, 실제로는 동기함수이다.**\r\n 이에 대해 자세히 살펴보자.\r\n\r\n## 🔹 setState의 동작방식\r\n\r\nsetState 자체는 동기적으로 실행되지만, setState로 인한 상태업데이트와 렌더링은 비동기적으로 이루어진다. \r\n\r\n왜 setState가 동기적인지는 우선 이따가 살펴보고, 우선 setState의 동작방식에 대해 알아보자.\r\n\r\n\r\n```js\r\nconst [count, setCount] = useState(0);\r\n\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  console.log(count); // 출력값은 1이다.\r\n};\r\n```\r\n아까 전 살펴봤던 코드이다. 왜 업데이트 된 값이 바로 반영이 안되었던 걸까?\r\n\r\n이유는 React는 최적화를 위해 상태 변경을 비동기적으로 처리하고 있기 때문입니다.\r\n\r\n### 배치 업데이트 (Batching)\r\nReact는 여러 개의 `setState` 호출을 하나로 비동기적으로 묶어서 처리하고, 이것을 **배치(batch) 업데이트**를 수행한다고합니다.  \r\n즉, 같은 이벤트 핸들러에서 여러 개의 `setState`가 호출되더라도 **한 번의 렌더링에서 처리**됩니다. \r\n\r\n```js\r\nconst handleClick = () => {\r\n  setCount(10);\r\n  setCount(count + 1);\r\n  setCount(30);\r\n  console.log(\"현재 count 값:\", count);\r\n};\r\n```\r\n즉 위의 3개의 setState는 한번에 함수 내 에서 하나씩 순서대로 실행되는 것이 아닌, **비동기적으로 한번에 처리가 되는 것 이다.**\r\n\r\n그렇다면 다음 코드를 보자.\r\n```js\r\nconst handleClick = () => {\r\n  setCount(count + 1);\r\n  setCount(count + 1);\r\n  setCount(count + 1);\r\n  console.log(\"현재 count 값:\", count);\r\n};\r\n```\r\n다음과 같은 경우 현재 count 값이 0으로 출력되는 것은 이제 알 것이다.\r\n```js\r\n현재 count 값: 0  // 이전 값이 출력\r\n```\r\n그렇다면 최종적으로 count 값은 몇이 될까? `\r\n\r\n`setCount(count + 1)`가 3번 호출되었지만, 최종적으로 `count` 값은 **1만 증가**한다.\r\n\r\n이유는 역시 React는 동일한 이벤트 핸들러 내에서 여러 개의 `setState`를 **배치 처리**하여 하나로 합쳐버리기 때문이다.\r\n즉, \r\n```js\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\nsetCount(count + 1);  // count + 1 → 0 + 1 → setCount(1)\r\n\r\n```\r\n-   `setState`는 바로 실행되지만, **이벤트 핸들러 내부에서는 `count` 값이 0으로 유지됨**\r\n-   따라서 모든 `setCount(count + 1)`은 결국 `setCount(1)`과 동일\r\n\r\n만일 의도한 바대로 count를 1씩증가시켜 3으로 만들고 싶다면, \r\n```js\r\nconst handleClick = () => {\r\n  setCount(prev => prev + 1);\r\n  setCount(prev => prev + 1);\r\n  setCount(prev => prev + 1);\r\n};\r\n```\r\n이런 식으로 코드를 짜면, 배치 처리와 상관없이 이전 값을 기반으로 상태를 변경한다.\r\n\r\n이렇게 setState는 React내에서 비동기적으로 상태 업데이트를 진행하는데, 왜 그럼에도 동기함수라고 하는걸까?\r\n\r\n## 🔹 setState가 동기함수인 이유\r\n\r\n**setState**의 상태 업데이트는 React내에서 배치처리를 통해 비동기적으로 이루어지지만, setState 자체는 **호출 즉시 실행**되므로 **동기 함수**이다.\r\n\r\n즉, 예를들어서,\r\n```js\r\nconst handleClick = () => {\r\n  console.log(\"Before setState:\", count);\r\n  setCount(count + 1);\r\n  console.log(\"After setState:\", count);\r\n};\r\n```\r\n위의 `setCount(count + 1);` 함수 자체는 실행될 때, 실행되는 즉시 함수가 종료가 된다. \r\n`setCount`가 진짜 비동기 함수였다면, **비동기 작업(Promise 등)을 반환**해야 하지만 그런 동작을 하지 않는 것이다.\r\n\r\n다만 setCount가 실행되어 상태 변경을 요청하면, \r\n**React가 이 요청을 현재 수행중인 이벤트가 핸들러가 끝날 때까지 기다린 후 배치처리를 수행하는 것이다.**\r\n \r\n setState가 비동기 함수 였다면,\r\n ```js\r\n const handleClick = async () => {\r\n  console.log(\"Before setState:\", count);\r\n  await setCount(count + 1);  //  실제로는 이렇게 사용 불가능\r\n  console.log(\"After setState:\", count);\r\n};\r\n ```\r\n 이런식으로 사용할 수 있어야 하지만, `setState`는 Promise를 반환하지 않으므로 `await`을 사용할 수 없다.\r\n \r\n 즉 setState는 **React의 내부적인 상태 업데이트와 렌더링 방식**으로 인해 비동기적으로 실행되는 것처럼 보이지만 엄밀히 말하면 **동기 함수**이다.\r\n\r\n## 결론\r\n\r\nsetState를 통해 React가 상태를 업데이트하는 과정을 정리하면 다음과 같다.\r\n\r\n1.  `setState` 호출 → 상태 변경 요청 (동기적으로 동작)\r\n2.  React가 현재 실행 중인 이벤트 핸들러가 끝날 때까지 기다림\r\n3.  **배치 처리**를 수행하여 여러 개의 `setState`를 한꺼번에 처리(비동기적 최적화)\r\n4.  상태 업데이트 후 리렌더링을 트리거\r\n\r\n`setState`는 동기적으로 실행되지만,  React의 **상태 변경과 렌더링 과정이 비동기적으로 최적화되어 실행된다.**"},{"slug":"posts/React/React와 Nextjs의 Suspense","title":"React와 Next.js의 Suspense에 대해 알아보자","date":"2024-11-25T00:00:24.000Z","image":"index.png","summary":"React와 Next.js에서 Suspense를 어떤 방식으로 다르게 다루는지, 그리고 Next.js에서 이로인해 발생할 수 있는 에러와 해결방법에 대해 알아보자.","tags":["react","next.js","deepdive","SSR","Suspense","렌더링"],"content":"\r\n## 들어가며\r\n프론트엔드에서 React와 Next.js에서는 비동기 로직과 데이터 페칭을 효율적으로 관리하기 위해 **Suspense**를 활용한다. \r\n\r\nReact 18부터 본격적으로 Suspense를 활용하여 관련된 로직을 수행할 수 있는데, React에서 Suspense를 어떻게 사용하는지 알아보고, Next.js에서는 13이상 부터 **자동화된 Suspense**에 대해, 그리고 이로 인해 발생한 에러와 해결방법에 대해 알아볼 것이다.\r\n\r\n## React의 Suspense\r\nReact의 **Suspense**는 비동기 로직이 완료될 때까지 대기 상태를 처리한다. 데이터 로딩, 컴포넌트 코드 스플리팅 등을 위해 주로 사용되며, 다음과 같은 방식으로 동작한다\r\n\r\n#### **Suspense 기본 동작 (React 18 이상)**\r\n\r\n1.  `Suspense`는 컴포넌트 트리의 일부에서 데이터를 로드하거나 리소스를 가져오는 작업이 끝날 때까지 렌더링을 중단한다.\r\n2.  `fallback` 프로퍼티에 지정된 컴포넌트를 먼저 렌더링한다.\r\n3.  작업이 완료되면 `Suspense` 아래의 실제 콘텐츠를 렌더링한다.\r\n\r\n```js\r\nimport React, { Suspense } from 'react';\r\n\r\nconst LazyComponent = React.lazy(() => import('./LazyComponent'));\r\n\r\nexport default function App() {\r\n  return (\r\n    <Suspense fallback={<div>Loading...</div>}>\r\n      <LazyComponent />\r\n    </Suspense>\r\n  );\r\n}\r\n\r\n```\r\n이런식으로 명시적으로 Suspense를 배치하여 이를 제어한다.\r\n\r\n`React.lazy`는 컴포넌트를 지연로딩할 때 사용되며 컴포넌트를 처음렌더링 할 때까지 로드하지 않는다.\r\n\r\n대신, 해당 컴포넌트가 실제로 화면에 렌더링될 때, 즉 \"**필요할 때**\" 로드한다.\r\n\r\n이렇게 `React.lazy()`와 `Suspense`를 같이 활용하여 컴포넌트를 지연 로딩하고, 초기 로딩 성능을 개선한다.\r\n\r\n## Next.js에서 자동화된 Suspense\r\n\r\nNext.js 13 이상에서는 App Router를 기반으로 **자동 Suspense**가 도입되었다. React의 Suspense와 비슷한 기능을 제공하되, 일부 동작이 Next.js에 의해 자동화가 된다.\r\n\r\n#### **Next.js 자동 Suspense 동작**\r\n\r\n1.  서버 컴포넌트에서 `fetch`나 비동기 로직을 처리할 때 Suspense가 자동으로 적용된다.\r\n2.  `loading.js`와 같은 특수 파일을 활용하여 Suspense의 `fallback` 역할을 수행한다.\r\n3.  클라이언트 컴포넌트의 경우 별도로 Suspense를 지정해야 동작한다\r\n\r\n즉 서버 컴포넌트에서 미리 비동기로 데이터를 가져올 때,  자동으로 지연 로딩이 되고, 로딩이 되는 동안 loading.tsx를 보여줄 수 있는 것 이다.\r\n\r\n```js\r\n// app/원하는 경로 페이지/page.tsx (서버 컴포넌트) \r\nexport default async function Page() { \r\nconst data = await fetchData(); \r\n\t// 자동 Suspense \r\n\treturn <div>{data}</div>; \r\n}\r\n```\r\n위의 코드는 Next.js의 서버 컴포넌트에서 데이터를 서버 단에서 미리 불러 올 때의 예제이다. 만일 loading.tsx를 만들면 이렇게 서버에서 미리 데이터를 불러오는 동안 사용자에게 로딩 중 컴포넌트를 보여줄 수 있다.\r\n\r\n```js\r\n// app/원하는-경로-페이지/loading.tsx \r\nexport default function Loading() {\r\n return <div>Loading...</div>; \r\n // 간단한 로딩 상태 \r\n }\r\n```\r\n이러한 경우 원하는 경로의 페이지에 접속하는 동안 loading.tsx를 볼 수 있다.\r\n\r\n## Next.js에서 React의 Suspense를 같이 써보자\r\n\r\nNext.js에서 내재되어있는 서버 컴포넌트에서 미리 데이터를 페칭할 때 자동으로 사용되는 Suspense 기능 뿐 아니라, 그 컴포넌트 안에서 react의 Suspense 역시 사용할 수 있다.\r\n\r\n다음 예제를 보자.\r\n```js\r\nimport { Suspense } from 'react';\r\nimport dynamic from 'next/dynamic';\r\n// 비동기 컴포넌트\r\nconst LazyComponent = dynamic(() => import('./LazyComponent'), { suspense: true, // Suspense를 사용하려면 이 설정이 필요하다. });\r\n\r\nexport default function Page() {\r\nconst data = await fetchData();\r\n  return (\r\n    <div>\r\n      <h1>Server Side Rendered Data</h1>\r\n      <div>{data}</div>\r\n\r\n      <Suspense fallback={<div>Loading...</div>}>\r\n        <LazyComponent />\r\n      </Suspense>\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n`next/dynamic`은 **Next.js**에서 제공하는 **동적 import** 기능이다. 이 기능을 사용하면 클라이언트 사이드에서 컴포넌트를 **지연 로딩**(Lazy Loading) 할 수 있으며, **서버 사이드 렌더링(SSR)**을 제어할 수 있다. \r\n\r\n즉 **비동기 로딩**을 통해 성능 최적화와 코드 분할을 지원하는 것이다.\r\n\r\n`next/dynamic`에는 여러 옵션이 있는데\r\n\r\n- suspense :**React Suspense** 기능과 통합하여, 동적 컴포넌트 로딩 중에 fallback UI를 표시할 수 있다.\r\n - loading:  \r\n\t  ```js \r\n\t  const LazyComponent = dynamic(() => import('./LazyComponent'), {\r\n\t  \t\tloading: () => <div>Loading...</div>, \r\n\t  \t\t});\r\n\t  \r\n\t ```\r\n\t 이렇게 직접 로딩 컴포넌트를 지정할 수도 있다.\r\n- ssr: `next/dynamic`에서는 이 동적 로딩 컴포넌트가 **서버 사이드 렌더링**에서 제외될 수 있도록 `ssr: false` 옵션을 사용하여 클라이언트 사이드에서만 컴포넌트를 로드할 수 있게 한다. (이 부분으로 에러를 해결하는 포스트를 추후 쓸 것이다.)\r\n\r\nLazyComponent가 볼륨이 높은 페칭 작업을 한다고 가정했을 때 Suspense를 사용하여 데이터를 가져오는 동안 fallback 컴포넌트를 보여줄 수 있다.\r\n\r\n즉, 위의 코드에서 Suspense가 어떻게 작동하는 지 정리해보자면\r\n\r\n- 서버 단에서 데이터를 페칭하여 미리가져오고, 그 데이터를 가져오는 시간 동안 loading.tsx의 컴포넌트를 보여준다.\r\n-  데이터를 가져와서 페이지가 로드된후 Suspense로 감싸준 클라이언트 단의 **LazyComponent에서 작업을 하는 동안** **fallback 컴포넌트를 보여준다.**\r\n-  LazyComponent의 작업이 완료되면 본래 컴포넌트를 보여준다.\r\n\r\n## 마치며\r\n React와 Next.js에서 Suspense를 어떻게 쓸 수 있는지에 대해서, 그리고 next.js에서 두개를 같이 쓰는 예제까지 살펴보았다. 개발 하며 앞으로 보다 나은 사용자 경험과 최적화를 위해 유용하게 사용할 수 있을 듯하다."}]},"__N_SSG":true}